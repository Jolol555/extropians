<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
                      "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>
<HEAD>
<TITLE>extropians: Mostly stuff about software (was Homeless + Jobs, L</TITLE>
<META NAME="Author" CONTENT="James Rogers (jamesr@best.com)">
<META NAME="Subject" CONTENT="Mostly stuff about software (was Homeless + Jobs, Lots of stuff about Software world)">
</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<H1>Mostly stuff about software (was Homeless + Jobs, Lots of stuff about Software world)</H1>
<!-- received="Sun Sep 24 17:06:41 2000" -->
<!-- isoreceived="20000924230641" -->
<!-- sent="Sun, 24 Sep 2000 08:35:21 -0700" -->
<!-- isosent="20000924153521" -->
<!-- name="James Rogers" -->
<!-- email="jamesr@best.com" -->
<!-- subject="Mostly stuff about software (was Homeless + Jobs, Lots of stuff about Software world)" -->
<!-- id="00092408471800.00819@tachyon" -->
<!-- inreplyto="14788.33551.428768.650557@lrz.uni-muenchen.de" -->
<STRONG>From:</STRONG> James Rogers (<A HREF="mailto:jamesr@best.com?Subject=Re:%20Mostly%20stuff%20about%20software%20(was%20Homeless%20%2B%20Jobs,%20Lots%20of%20stuff%20about%20Software%20world)&In-Reply-To=&lt;00092408471800.00819@tachyon&gt;"><EM>jamesr@best.com</EM></A>)<BR>
<STRONG>Date:</STRONG> Sun Sep 24 2000 - 09:35:21 MDT
<P>
<!-- next="start" -->
<UL>
<LI><STRONG>Next message:</STRONG> <A HREF="5611.html">David Lubkin: "Re: Why would AI want to be friendly?"</A>
<LI><STRONG>Previous message:</STRONG> <A HREF="5609.html">David Lubkin: "Re: GUNS: Why here?"</A>
<LI><STRONG>In reply to:</STRONG> <A HREF="5131.html">Eugene Leitl: "Re: Homeless, (+ Jobs, Lots of stuff about Software world)"</A>
<!-- nextthread="start" -->
<LI><STRONG>Next in thread:</STRONG> <A HREF="5614.html">Samantha Atkins: "Re: Mostly stuff about software (was Homeless + Jobs, Lots of stuff  about Software world)"</A>
<LI><STRONG>Reply:</STRONG> <A HREF="5614.html">Samantha Atkins: "Re: Mostly stuff about software (was Homeless + Jobs, Lots of stuff  about Software world)"</A>
<LI><STRONG>Reply:</STRONG> <A HREF="5821.html">Bryan Moss: "Re: Mostly stuff about software (was Homeless + Jobs, Lots of stuff about Software world)"</A>
<!-- reply="end" -->
<LI><STRONG>Messages sorted by:</STRONG> 
<A HREF="date.html#5610">[ date ]</A>
<A HREF="index.html#5610">[ thread ]</A>
<A HREF="subject.html#5610">[ subject ]</A>
<A HREF="author.html#5610">[ author ]</A>
</UL>
<HR NOSHADE><P>
<!-- body="start" -->
<P>
On Sun, 17 Sep 2000, Eugene wrote:
<BR>
<EM>&gt; Samantha Atkins writes:
</EM><BR>
<EM>&gt;
</EM><BR>
<EM>&gt;  &gt; closer.  And a pretty good argument can be made that without
</EM><BR>
<EM>&gt;  &gt; concentrations of wealth in private hands their is no energy/resources
</EM><BR>
<EM>&gt;  &gt; to enable many types of innovation.  Of course there are also
</EM><BR>
<EM>&gt;
</EM><BR>
<EM>&gt; Good point. Robbing the rich to feed the poor makes us collectively
</EM><BR>
<EM>&gt; poorer. We'll never make it into space if there's not enough loose
</EM><BR>
<EM>&gt; cash in the pockets of wealthy geeks. I think there *is* a window of
</EM><BR>
<EM>&gt; opportunity, and we already let a lot of know-how (there is a reason
</EM><BR>
<EM>&gt; it's called &quot;rocket science&quot;) trapped in people's and group of
</EM><BR>
<EM>&gt; people's heads drift to /dev/null.
</EM><BR>
<P><P>This is my biggest objection to oppressive taxation; it damages my ability
<BR>
to invest time and money in necessary technological R&amp;D.  Of course,
<BR>
the government that doesn't trust me with my money (ahem, Gore,
<BR>
Nader, et al.), is the same government that I would hopefully obsolete
<BR>
through the development of fundamentally important new technology.
<BR>
<P><P><EM>&gt; A nominal 9-5 (or part time) job will pay for the rent, and leave time
</EM><BR>
<EM>&gt; for the hobbies. If I can't do truly interesting things in my job, I
</EM><BR>
<EM>&gt; could as well let the nominal day job pay for my rent, and do
</EM><BR>
<EM>&gt; interesting things in my spare time.
</EM><BR>
<P><P>It depends on what your hobbies are, as some can be rather expensive.
<BR>
Or maybe I just try to do too many things at once...
<BR>
<P><P><EM>&gt;  &gt; Don't bet on it.  What changes between then and now is the raw power of
</EM><BR>
<EM>&gt;  &gt; the hardware.  As it becomes more powerful it becomes more tractable to
</EM><BR>
<EM>&gt;  &gt; automate large segments of the work programmers currently do.  Of
</EM><BR>
<EM>&gt;
</EM><BR>
<EM>&gt; Sure, now it's easier to make a GUI, by just painting it on the
</EM><BR>
<EM>&gt; screen. Program generators are not exactly new. Apart from wizards
</EM><BR>
<EM>&gt; like our very own James Rogers (and sci things like ATLAS,
</EM><BR>
<EM>&gt; automatically juggling source to optimize for a given architecture) we
</EM><BR>
<EM>&gt; don't see automatic programming hitting the streets any time soon. And
</EM><BR>
<EM>&gt; then people would still have to write specs in a formal language. Even
</EM><BR>
<EM>&gt; if you don't write a protocol stack explicitly, you still have to
</EM><BR>
<EM>&gt; codify it's behaviour.
</EM><BR>
<P><P>I should mention that I am able to do what I did be cause the domain
<BR>
is severely constrained. While I am working on the generalized
<BR>
problem, it is useful to both validate design components in a
<BR>
real-world environment and fund general development by selling limited
<BR>
implementations of the general technology to solve hard problems that can
<BR>
be effectively attacked with limited but relatively &quot;smart&quot; software. It is
<BR>
also a rich space for coming across interesting problems that need to be
<BR>
solved, which keeps me happy. :^)
<BR>
<P>For the application I mentioned previously, I don't need a formal spec
<BR>
per se. Rather, I have a big goal (maximize profits) that doesn't
<BR>
change, and a small set of sub goals created by suits that are subject
<BR>
to occasional change.  The dataspace is large (typically around 25Gb),
<BR>
quite complex, and subject to some rather sudden and dynamic changes
<BR>
both in content and nature. Given basic code on how to navigate the
<BR>
dataspace, I let the system figure out the best way to achieve the
<BR>
stated goals and to take advantage of emerging patterns. In short, I
<BR>
have limited the code generation to working with the business problem
<BR>
dataspace rather than to the framework itself; it puts the flesh on
<BR>
the skeleton. A set of algorithms that observe the system's runtime
<BR>
behavior determine when code gets re-written. One could easily write a
<BR>
book on this topic (though I certainly won't).  It really only deviates
<BR>
significantly from the general problem of intelligent code generation in
<BR>
one aspect, but the difference is an important one.
<BR>
<P>The biggest problem with runtime code generators is debugging the
<BR>
resulting mess. However, it has allowed me to work on the some
<BR>
of the many interesting problems of self-observation. Designing methods to
<BR>
resolve issues such as detecting complex and non-procedural
<BR>
infinite loops (e.g. infinite loops caused by how the data interacts with
<BR>
the code at runtime, without compile-time knowledge of what the data can
<BR>
look like) has been fun.
<BR>
<P><P><EM>&gt; Jeez. If you think C++ is an improvement upon C you really have a
</EM><BR>
<EM>&gt; strange mind.
</EM><BR>
<P><P>To my mind, useable C++ looks a lot like well-organized C. The only
<BR>
real improvement of C++ is that it formalized a syntax for things that
<BR>
good C programmers had been doing for a long time.  For that reason,
<BR>
very few applications actually justify using C++ over C, if your C
<BR>
programmers are competent enough.  And if they aren't competent with
<BR>
C, you certainly don't want them working in C++. :^)
<BR>
<P><P><EM>&gt; I do not see anything new cropping up since
</EM><BR>
<EM>&gt; Lisp. Because I can't have Lisp machine in current technology (and am
</EM><BR>
<EM>&gt; too dumb/poor to afford a DSP cluster running Forth), I've settled on
</EM><BR>
<EM>&gt; Python/C in a OpenSource *nix environment (currently Linux).
</EM><BR>
<P><P>C/Python/Java on Unix is my environment of choice, both because I am
<BR>
extremely comfortable with them (C on Unix is like comfortable old
<BR>
shoes), and because I can use one of them well in every design space I
<BR>
am likely to come across.
<BR>
<P>I have noticed that a lot of good programmers with broad platform
<BR>
experience tend to settle on the same tools with time.  Despite coming
<BR>
from wildly different backgrounds, most of the programmers I know who
<BR>
have been working with computers for a long time seem to have very
<BR>
similar notions of what &quot;optimal environments&quot; actually are.
<BR>
Coincidence?  I doubt it.
<BR>
<P><P><EM>&gt;  &gt; We are beginning to address problems of programming in the large but
</EM><BR>
<EM>&gt;  &gt; frankly many of the solutions are giant kludges that are severely
</EM><BR>
<EM>&gt;  &gt; over-hyped and over-sold.  I have gotten quite disgruntled with this
</EM><BR>
<EM>&gt;  &gt; industry.  We spend more time trying to lock up &quot;intellectual property&quot;
</EM><BR>
<EM>&gt;
</EM><BR>
<EM>&gt; Amen, verily, etc. etc.
</EM><BR>
<P><P>There is a lot of pressure (business and lawyerly) to turn
<BR>
everything into an intellectual property action. There are a lot of
<BR>
benefits, both material and immaterial, to doing so, *particularly*
<BR>
if your organization is poorly funded.
<BR>
<P>I actually started the patent process for a few different thing
<BR>
(largely software technologies of the type mentioned above), but
<BR>
dropped it after deciding that I would probably have an easier time
<BR>
keeping the technology out from under the thumb of big business by
<BR>
*not* patenting the tech.  That and I object personally to the
<BR>
software patent concept.  Makes it a little harder to get funding
<BR>
though.
<BR>
<P>Of course, Yudkowskian technologies have an *enormous* first-to-market
<BR>
advantage that is hard to ignore. :^)
<BR>
<P><P><EM>&gt;  &gt; My greatest expertise is in object persistence.  Persistence is far, far
</EM><BR>
<EM>&gt;  &gt; from &quot;automated&quot;.  Persistence cross-cuts applications and products but
</EM><BR>
<EM>&gt;  &gt; is often done as a series of hacks within a particular project
</EM><BR>
<EM>&gt;  &gt; life-cycle.  Or a product is bought that promises to take the worries
</EM><BR>
<EM>&gt;
</EM><BR>
<EM>&gt; OO is far from being the silver bullet, i.e. code reuse by inheritance
</EM><BR>
<EM>&gt; from former projects does not seem to scale.
</EM><BR>
<P><P>To me, OO attempts to enforce &quot;organized&quot; coding practices in syntax.
<BR>
Except for very limited cases, code re-use through inheritance is a
<BR>
nearly worthless feature in practice, and many times the headaches it
<BR>
can create offset any benefits. The biggest niceties of OO (IMO) are
<BR>
the typing models and interfacing conventions.
<BR>
<P>Again, if you write really good procedural code, you are not likely to
<BR>
benefit much from OO. Perhaps it would be better just to teach people
<BR>
good code design.
<BR>
<P><P><EM>&gt;  &gt; We have automated certain classes of GUIs but the GUI story is far from
</EM><BR>
<EM>&gt;  &gt; complete or adequate.  Many projects are now being seriously perverted
</EM><BR>
<EM>&gt;  &gt; to use only a Web Browser as their GUI!  It is as if we are stepping
</EM><BR>
<EM>&gt;
</EM><BR>
<EM>&gt; Well, a web browser is an ubiquitous, easy way to control a system,
</EM><BR>
<EM>&gt; and you can put it within few 100 Bytes of assembly. A remote GUI is
</EM><BR>
<EM>&gt; not something too bad.
</EM><BR>
<P><P>The web browser is great for ubiquity, but has too many limitations at
<BR>
both the low- and high-level to make a good GUI.  Usable for simple
<BR>
things (such as remote control), but very difficult to work with for
<BR>
applications with complex interfaces (imagine running an application
<BR>
like GIMP or Photoshop inside a web browser). However, there are a lot
<BR>
of advantages to having a network aware UI, a capability where MS
<BR>
Windows really blows goats.
<BR>
<P>I would really like to see the development of a capable, clean,
<BR>
platform independent, network aware GUI system. Maybe something that
<BR>
falls somewhere in between X (too big and crufty) and the Web.
<BR>
Current widely available &quot;cross-platform&quot; GUI implementations such as
<BR>
the Java AWT are an abomination -- all of the downside and none of
<BR>
the upside IMHO.
<BR>
<P><P><EM>&gt; We do have an interest in peer to peer information sharing (though not
</EM><BR>
<EM>&gt; yet collaboration) rising recently. Parallel applications (based on
</EM><BR>
<EM>&gt; PVM/MPI message passing libraries), including cluster file systems are
</EM><BR>
<EM>&gt; fairly widespread in science, and soon commerce. High-availability and
</EM><BR>
<EM>&gt; high-performance clusters for commerce are the hottest topics right
</EM><BR>
<EM>&gt; now. Things are not hopeless.
</EM><BR>
<P><P>I think it will be five years or more or so before clusters become
<BR>
really ubiquitous.  One of the biggest difficulties is that most
<BR>
programmers have no clue how to develop &quot;cluster-aware&quot; software, and
<BR>
aren't likely to get one any time soon.  When you consider that most
<BR>
programmers still can't figure out how to design even moderately
<BR>
complex locking schemes for multithreaded applications on a
<BR>
single-processor system or to ensure something resembling
<BR>
transactional integrity of complex shared data, both of which have
<BR>
been around for years, I doubt that cluster-aware applications will be
<BR>
quick to penetrate most market spaces. It is easier just to throw
<BR>
bigger hardware at the problem.
<BR>
<P>The people that &quot;get&quot; cluster design now because they find it
<BR>
fascinating are going to be the majority of people who &quot;get&quot; cluster
<BR>
design later. Most programmers will implement clustering badly,
<BR>
which will essentially negate the benefits and slow adoption in many
<BR>
organizations.
<BR>
<P>A majority of programmers quickly lose competence when they move past
<BR>
the &quot;one user, one CPU, one process, one machine&quot; design space. In my
<BR>
experience, as more of these variables become &gt;1, the greater
<BR>
difficulty many programmers have producing efficient code. Only a
<BR>
relative handful of working software engineers will produce efficient
<BR>
code design when you have multi-user, multi-process, SMP, and
<BR>
clustering as explicit design optimization considerations.  Too many
<BR>
variables for some minds to wrap around I guess.
<BR>
<P><P><EM>&gt;  &gt; good tools for finding the right components and simulating their
</EM><BR>
<EM>&gt;  &gt; interaction.  Much of our code base is still language and OS dependent
</EM><BR>
<EM>&gt;  &gt; and not componentized at all.  Most of code is still application
</EM><BR>
<EM>&gt;  &gt; stovepipes with little/no reuse or reuseability.  In short, almost no
</EM><BR>
<EM>&gt;  &gt; automation or next-level engineering applied to our own work.  It had
</EM><BR>
<EM>&gt;  &gt; better not continue like this.
</EM><BR>
<P><P>Part of the problem with components is that the components as designed
<BR>
today are only data aware in the grossest declarative sense.  As a
<BR>
result, components are only useful for very narrowly defined problems
<BR>
that rarely translate into something that can be re-used for all but
<BR>
the most narrow domains. The brittleness and rigidity of current
<BR>
component design methodologies is part of the reason that &quot;cut, paste,
<BR>
and modify&quot; is a viable software development methodology.
<BR>
<P>But components don't really matter; I have strong doubts as to
<BR>
whether components are a correct solution in the long-term anyway.
<BR>
Components exist more to solve a human weakness in software
<BR>
implementation than to solve any particular weakness intrinsic
<BR>
to software design itself. I can't imagine why a smart machine would
<BR>
use components to write software.
<BR>
<P><P>-James Rogers
<BR>
&nbsp;<A HREF="mailto:jamesr@best.com?Subject=Re:%20Mostly%20stuff%20about%20software%20(was%20Homeless%20%2B%20Jobs,%20Lots%20of%20stuff%20about%20Software%20world)&In-Reply-To=&lt;00092408471800.00819@tachyon&gt;">jamesr@best.com</A>
<BR>
<P><!-- body="end" -->
<HR NOSHADE>
<UL>
<!-- next="start" -->
<LI><STRONG>Next message:</STRONG> <A HREF="5611.html">David Lubkin: "Re: Why would AI want to be friendly?"</A>
<LI><STRONG>Previous message:</STRONG> <A HREF="5609.html">David Lubkin: "Re: GUNS: Why here?"</A>
<LI><STRONG>In reply to:</STRONG> <A HREF="5131.html">Eugene Leitl: "Re: Homeless, (+ Jobs, Lots of stuff about Software world)"</A>
<!-- nextthread="start" -->
<LI><STRONG>Next in thread:</STRONG> <A HREF="5614.html">Samantha Atkins: "Re: Mostly stuff about software (was Homeless + Jobs, Lots of stuff  about Software world)"</A>
<LI><STRONG>Reply:</STRONG> <A HREF="5614.html">Samantha Atkins: "Re: Mostly stuff about software (was Homeless + Jobs, Lots of stuff  about Software world)"</A>
<LI><STRONG>Reply:</STRONG> <A HREF="5821.html">Bryan Moss: "Re: Mostly stuff about software (was Homeless + Jobs, Lots of stuff about Software world)"</A>
<!-- reply="end" -->
<LI><STRONG>Messages sorted by:</STRONG> 
<A HREF="date.html#5610">[ date ]</A>
<A HREF="index.html#5610">[ thread ]</A>
<A HREF="subject.html#5610">[ subject ]</A>
<A HREF="author.html#5610">[ author ]</A>
</UL>
<!-- trailer="footer" -->
<HR NOSHADE>
<P>
<SMALL>
<EM>
This archive was generated by <A HREF="http://www.hypermail.org/">hypermail 2b29</A> 
: <EM>Mon Oct 02 2000 - 17:38:49 MDT</EM>
</EM>
</SMALL>
</BODY>
</HTML>
