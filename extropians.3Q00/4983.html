<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
                      "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>
<HEAD>
<TITLE>extropians: Re: Jobs, Lots of stuff about Software world (was r</TITLE>
<META NAME="Author" CONTENT="Samantha Atkins (samantha@objectent.com)">
<META NAME="Subject" CONTENT="Re: Jobs, Lots of stuff about Software world (was re: Homeless)">
</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<H1>Re: Jobs, Lots of stuff about Software world (was re: Homeless)</H1>
<!-- received="Thu Sep 14 13:17:01 2000" -->
<!-- isoreceived="20000914191701" -->
<!-- sent="Thu, 14 Sep 2000 12:18:34 -0700" -->
<!-- isosent="20000914191834" -->
<!-- name="Samantha Atkins" -->
<!-- email="samantha@objectent.com" -->
<!-- subject="Re: Jobs, Lots of stuff about Software world (was re: Homeless)" -->
<!-- id="39C1248A.D163DCF5@objectent.com" -->
<!-- inreplyto="00cf01c01e63$e5ca4d50$bc630c3d@squashy2000" -->
<STRONG>From:</STRONG> Samantha Atkins (<A HREF="mailto:samantha@objectent.com?Subject=Re:%20Jobs,%20Lots%20of%20stuff%20about%20Software%20world%20(was%20re:%20Homeless)&In-Reply-To=&lt;39C1248A.D163DCF5@objectent.com&gt;"><EM>samantha@objectent.com</EM></A>)<BR>
<STRONG>Date:</STRONG> Thu Sep 14 2000 - 13:18:34 MDT
<P>
<!-- next="start" -->
<UL>
<LI><STRONG>Next message:</STRONG> <A HREF="4984.html">Dan Fabulich: "Re: Dogmalaritarianism (was Re: Goals was: Transparency and IP)"</A>
<LI><STRONG>Previous message:</STRONG> <A HREF="4982.html">Brian D Williams: "Re: Arcologys"</A>
<LI><STRONG>In reply to:</STRONG> <A HREF="4959.html">Emlyn O'Regan: "Jobs, Lots of stuff about Software world (was re: Homeless)"</A>
<!-- nextthread="start" -->
<LI><STRONG>Next in thread:</STRONG> <A HREF="4989.html">Emlyn O'Regan: "Where's genetic programming at? (was Re: Jobs, Lots of stuff about Software world (was re: Homeless))"</A>
<LI><STRONG>Reply:</STRONG> <A HREF="4989.html">Emlyn O'Regan: "Where's genetic programming at? (was Re: Jobs, Lots of stuff about Software world (was re: Homeless))"</A>
<!-- reply="end" -->
<LI><STRONG>Messages sorted by:</STRONG> 
<A HREF="date.html#4983">[ date ]</A>
<A HREF="index.html#4983">[ thread ]</A>
<A HREF="subject.html#4983">[ subject ]</A>
<A HREF="author.html#4983">[ author ]</A>
</UL>
<HR NOSHADE><P>
<!-- body="start" -->
<P>
Emlyn O'Regan wrote:
<BR>
<EM>&gt; 
</EM><BR>
<EM>&gt; Or maybe it just seems harder as you get older; maybe the new guys &amp; gals
</EM><BR>
<EM>&gt; will swim like fish in the latest version of the techno-whirlpool. Can fish
</EM><BR>
<EM>&gt; swim through a whirlpool? I guess we'll find out.
</EM><BR>
<EM>&gt;
</EM><BR>
<P><EM>&gt;From what I see people nearly *gasp* half my age doing much of the
</EM><BR>
difficulty is experienced by all.  People who have pretty much grown up
<BR>
with computers and especially the WEB are often more adept at webifying
<BR>
things.  But programming environment issues and infrastructure concerns
<BR>
are no more transparent to them. 
<BR>
&nbsp;
<BR>
<EM>&gt; &gt;
</EM><BR>
<EM>&gt; &gt; Actually, having been in the software world myself for 20 years, I
</EM><BR>
<EM>&gt; &gt; suspect the truth is a bit dimmer than that.  Many of the tools I use
</EM><BR>
<EM>&gt; &gt; haven't evolved hardly at all in all of that time.  C lead to C++ but
</EM><BR>
<EM>&gt; &gt; the tools used to graft C++ have not exactly gone through any major
</EM><BR>
<EM>&gt; &gt; revolution.  C++ itself is quite primitive in many ways.  Java?
</EM><BR>
<EM>&gt; &gt; Interesting things have been done to exploit some of its features but
</EM><BR>
<EM>&gt; &gt; the language itself is not that powerful and not sufficient for many
</EM><BR>
<EM>&gt; &gt; types of problems.  Any interpreted or semi-interpreted language with
</EM><BR>
<EM>&gt; &gt; equal or more reflection could be used in most of the contexts that Java
</EM><BR>
<EM>&gt; &gt; is used.  Some of these languages, such as Lisp and Smalltalk, are or
</EM><BR>
<EM>&gt; &gt; have been much more powerful and advanced in capability, usage, or
</EM><BR>
<EM>&gt; &gt; development environment than Java, C++, VB and so on are today.  Most of
</EM><BR>
<EM>&gt; &gt; the central abilities in languages were first invented and explored in
</EM><BR>
<EM>&gt; &gt; Lisp.
</EM><BR>
<EM>&gt; 
</EM><BR>
<EM>&gt; ... and none of them are really relevant to this discussion. Sure, the ideas
</EM><BR>
<EM>&gt; are have been around a long time, everything's been thought up before in any
</EM><BR>
<EM>&gt; case. It's all about how you put them together into new things.
</EM><BR>
<EM>&gt;
</EM><BR>
<P>Actually they are powerfully relevant.  The shape of the tools and
<BR>
languages at our disposal determine what can be thought and done and how
<BR>
easily which is a huge determiner on our future.  A huge determiner of
<BR>
the shape is the socio-political/business climate that does not often
<BR>
allow the best technology, especially in development tools to be built
<BR>
or if it is built, to win.
<BR>
&nbsp;
<BR>
<EM>&gt; I would point to things like the libraries of prebuilt functions and
</EM><BR>
<EM>&gt; components which are available, the infrastructure that is now a given, the
</EM><BR>
<EM>&gt; system architectures which are commonplace now, as places where you see the
</EM><BR>
<EM>&gt; advancements. Sure, I might write a system in C++ today, just like someone
</EM><BR>
<EM>&gt; might have done 10 years ago. But things I can achieve with that system now,
</EM><BR>
<EM>&gt; the toolset I have available to do it, the very fact that the system itself
</EM><BR>
<EM>&gt; is less important than the mighty global super-system in which it takes its
</EM><BR>
<EM>&gt; humble place... this is the march forward. And it's not a march, so much as
</EM><BR>
<EM>&gt; a sprint.
</EM><BR>
<EM>&gt;
</EM><BR>
<P>What libraries are you refferring too?  Most libraries have been around
<BR>
a long time.  I've been building libraries and components since 1983. 
<BR>
Most libraries today aren't done with much better technology and don't
<BR>
address the issues inherent in such any better than back then.   With
<BR>
the exception of libraries of components, beans and COM/Corba things. 
<BR>
The system architectures frankly mostly suck.  They are unnecessarily
<BR>
fragile and constricting.  C++ is a modern aseembly language, little
<BR>
more.  The global super-system is mere hand-waving in this context.  In
<BR>
the trenches of software design and development the &quot;global
<BR>
super-system&quot; is largely irrelevant where it is not downright pernicious
<BR>
to the work.  A sprint?  More like millions of lemmings bolting for the
<BR>
sea with a few standing still or trying to strike out in a different
<BR>
direction.
<BR>
&nbsp;
<BR>
<EM>&gt; It's a long time since I got to write some software with the fundamental
</EM><BR>
<EM>&gt; assumptions that it would run on one computer and be used by a handful of
</EM><BR>
<EM>&gt; people, in isolation, sitting on top of an OS and not much more.
</EM><BR>
<EM>&gt;
</EM><BR>
<P>So, I guess you don't write much VB after all?  :-)
<BR>
<P>&nbsp;
<BR>
<EM>&gt; &gt;
</EM><BR>
<EM>&gt; &gt; We are beginning to address problems of programming in the large but
</EM><BR>
<EM>&gt; &gt; frankly many of the solutions are giant kludges that are severely
</EM><BR>
<EM>&gt; &gt; over-hyped and over-sold.  I have gotten quite disgruntled with this
</EM><BR>
<EM>&gt; &gt; industry.  We spend more time trying to lock up &quot;intellectual property&quot;
</EM><BR>
<EM>&gt; &gt; and out-hype the competition than we do actually designing and building
</EM><BR>
<EM>&gt; &gt; good systems.  And fixing our development tools themselves takes a
</EM><BR>
<EM>&gt; &gt; backseat to even that.  I designed and built things in the 80s ( and I
</EM><BR>
<EM>&gt; &gt; am not unique in this at all) that are as or more advanced than some
</EM><BR>
<EM>&gt; &gt; parts of the current highly-hyped baseline.
</EM><BR>
<EM>&gt; &gt;
</EM><BR>
<EM>&gt; 
</EM><BR>
<EM>&gt; Point is, they were a fair way from the baseline then, and probably aren't
</EM><BR>
<EM>&gt; now. I know lots of technocrats get cranky because what's just come out as
</EM><BR>
<EM>&gt; some Windows 2000 feature &quot;was old news back when I was programming Eniac&quot;.
</EM><BR>
<EM>&gt; It doesn't mean anything. Excel uses maths, that's been around for millenia.
</EM><BR>
<EM>&gt; I still run on essentially the same wetware that the fishies have been using
</EM><BR>
<EM>&gt; for ever.
</EM><BR>
<EM>&gt;
</EM><BR>
<P>That rather misses a lot of the points I raised.  The central question
<BR>
is why the advances are largely lost and when incorporated why more
<BR>
energy is spent/wasted over-selling them than actually fully
<BR>
incorporating and extending them?  This is a quite crucial question for
<BR>
the future of this industry (and for my continuing part in it).  I think
<BR>
you are seeing played out early in software some central conflicts as
<BR>
the world heads more towards information being the most essential
<BR>
commodity.  I see the problems in software but I don't believe they stop
<BR>
there.  
<BR>
<P>&nbsp;
<BR>
<EM>&gt; I've had people tell me that the internet is nothing new, and hey, the
</EM><BR>
<EM>&gt; French had a bigger system way back when, with computers linked together in
</EM><BR>
<EM>&gt; the hands of the general populace (a centralised system I think). Sure the
</EM><BR>
<EM>&gt; net is old (relative to what?), but it's also new; it's not the same thing
</EM><BR>
<EM>&gt; that it was five years ago, two years ago, last week. Sure the french had
</EM><BR>
<EM>&gt; some automated phone book thing, big deal. Would you swap it for this?
</EM><BR>
<EM>&gt;
</EM><BR>
<P>The web is new but is it not as good as it should be and needs to be and
<BR>
must be to be used for what we wish to use it for.  What is to be done
<BR>
about it?  How is it symptomatic of deeper concerns/currents in software
<BR>
systems? 
<BR>
<P>Don't get hung up on the way back then vs. now subthread.  It is used to
<BR>
illustrate trends rather than being primary to the point I was
<BR>
attempting to make.
<BR>
<P>&nbsp;
<BR>
<EM>&gt; The baseline is one of the big things. Now we've got distributed
</EM><BR>
<EM>&gt; transaction/object systems, multi-tiered system infrastructure, all these
</EM><BR>
<EM>&gt; neat things that have been around for donkey's years. So what? So, they are
</EM><BR>
<EM>&gt; turning up in the baseline. As a lowest common denominator. Admitedly it's
</EM><BR>
<EM>&gt; all heterogeous madness still, but it's coming together. That's not a cause
</EM><BR>
<EM>&gt; for cynicism, that &quot;yeah, been there, done that&quot; attitude. It really ought
</EM><BR>
<EM>&gt; to blow your mind.
</EM><BR>
<EM>&gt;
</EM><BR>
<P>We have toy transaction/object systems that break badly on real world
<BR>
problems outside of the small window they can handle and get held
<BR>
together with chewing gum.  Multi-tiered systems have been built (with
<BR>
less hype) for 20 years minimum and we still don't solve some of the
<BR>
issues that were unearthed then, although we pretend we do.  J2EE and
<BR>
EJB do tuck a lot of plumbing issues out of the way although there is
<BR>
still much to be done to make that sort of progress less intrusive and
<BR>
more responsive.  
<BR>
<P>I am the last person that it can even remotedly be suggested that I am
<BR>
cynical.  I am a wild, flag waving idealistic optimistist who keeps
<BR>
charging out onto the bleeding edge to make it better.  I am not cynical
<BR>
but I am quite tired of assumptions that the current state of the art is
<BR>
oh so admirable and that the tide of software progress is flowing well. 
<BR>
It isn't and I've wrestled with enough broken software systems and
<BR>
company politics to have a pretty good idea of what the damage and
<BR>
problems are.  
<BR>
&nbsp;
<BR>
<EM>&gt; It's all in how you look at it... for instance, is Napster a hopelessly
</EM><BR>
<EM>&gt; technologically boorish file transfer utility, or is it a major social
</EM><BR>
<EM>&gt; revolution, the outcome of which, while unknowable, is certain to be major
</EM><BR>
<EM>&gt; and irreversible?
</EM><BR>
<EM>&gt; 
</EM><BR>
<P>Both and.
<BR>
<P><EM>&gt; Because you can do things with it that you could never conceive of doing
</EM><BR>
<EM>&gt; before. This &quot;new economy&quot; thing is not some hyped up joke; it's happening.
</EM><BR>
<EM>&gt; The technology, important as it is, doesn't matter at all. It's what we can
</EM><BR>
<EM>&gt; do, and are doing, that matters.
</EM><BR>
<EM>&gt;
</EM><BR>
<P>Without the tech you can't do shit.  Without a deep understanding of the
<BR>
tech you will miss more than you think of doing.  Sure we are in a
<BR>
revolution in many ways but some of us like me are attempting to see
<BR>
where the underlying tech needs extension and cleanup and where the next
<BR>
great thing will/should be.  It doesn't mean we don't see what is now. 
<BR>
It doesn't mean something so facile as that we are &quot;cynical&quot;. 
<BR>
&nbsp;
<BR>
<EM>&gt; &gt; Sorry.  Most of that is an aside and off-topic.  I needed to rant. But
</EM><BR>
<EM>&gt; &gt; personally I don't think software development will get significantly
</EM><BR>
<EM>&gt; &gt; better until something like Open Source (better add Open Design) and
</EM><BR>
<EM>&gt; &gt; changes in the basis of software business occur.  I don't see how the
</EM><BR>
<EM>&gt; &gt; current model has room to get out of its own way.
</EM><BR>
<EM>&gt; 
</EM><BR>
<EM>&gt; Open Source... hmmm. I've been in the MS world too long, I don't have more
</EM><BR>
<EM>&gt; than a passing knowledge of how it works. I think you are right; it is the
</EM><BR>
<EM>&gt; way forward. It's going to be a bumpy, crazy, messy, perilous way, but it'll
</EM><BR>
<EM>&gt; become clear that it's the only road open I think.
</EM><BR>
<EM>&gt;
</EM><BR>
<P>&nbsp;
<BR>
<EM>&gt; I don't think software will get any better, however. The best we can
</EM><BR>
<EM>&gt; probably hope for is that it will remain feasible to develop software. And
</EM><BR>
<EM>&gt; that'll do fine!
</EM><BR>
<EM>&gt;
</EM><BR>
<P>Now who's cynical?  
<BR>
<P>Software must get significantly better.  What is demanded of software
<BR>
systems is ever more crucial.  Serving roughly the same old slop can
<BR>
kill people and economies.  As we step toward ever greater automation
<BR>
and to nanotech this is even more true.  There is no conceivable way
<BR>
that most current software practice and languages will enable building
<BR>
massively fine-grained parallel, distributed programming environments
<BR>
that will be very much required in many nanotech solutions dreamed of
<BR>
today.  There are some mostly academic things on the shelves gathering
<BR>
dust that may provide some keys to solutions.  Even in far less exotic
<BR>
software spaces, the Web economy is running on systems that are quite
<BR>
poorly adapted to the load.  There are problems like handling long
<BR>
transations and massively interacting transactions that we don't have
<BR>
even academic general solutions to yet they are endemic to many things
<BR>
we do or need to do out on the global network.  Some of these things
<BR>
require not just new breakthroughs but new ways of designing, developing
<BR>
and fielding software.  It is a very exciting time in the industry.   
<BR>
<P><EM>&gt; &gt; GAG!  VB is one of the worst blights exemplifying the very problems in
</EM><BR>
<EM>&gt; &gt; the industry I spoke of above.  The very idea of inflicting on millions
</EM><BR>
<EM>&gt; &gt; of programmers a language environment that has a badly scaled Basic at
</EM><BR>
<EM>&gt; &gt; its core pretending to be object oriented (laugh) and which is not even
</EM><BR>
<EM>&gt; &gt; powerful enough to handle full COM components and on top of this has the
</EM><BR>
<EM>&gt; &gt; IDE, your program and the debugger in one process so any problems crash
</EM><BR>
<EM>&gt; &gt; the entire mess - well, the whole thing is simply and utterly
</EM><BR>
<EM>&gt; &gt; infuriating.  I can and have designed better programming environments in
</EM><BR>
<EM>&gt; &gt; my sleep.  Microsoft should be shot for gross ineptitude and programmer
</EM><BR>
<EM>&gt; &gt; abuse.  Of course they were never really about making the world better
</EM><BR>
<EM>&gt; &gt; for software development  They are only in it to capture the market and
</EM><BR>
<EM>&gt; &gt; eliminate the competition.  Or at least any good tendencies in its
</EM><BR>
<EM>&gt; &gt; people are subsumed by that bottom line over and over again.
</EM><BR>
<EM>&gt; 
</EM><BR>
<EM>&gt; Crocodile tears? I agree with the technological assessment; a shocking
</EM><BR>
<EM>&gt; language, horrible, the costs of which will become apparent as time wears
</EM><BR>
<EM>&gt; on, and the legacy mountain of VB grows.
</EM><BR>
<EM>&gt; 
</EM><BR>
<EM>&gt; But then again, from what I've seen, you can throw together some pretty
</EM><BR>
<EM>&gt; amazing stuff in very short time. Go back to '85, and ask someone how long
</EM><BR>
<EM>&gt; it'll take to get an app together with a slick user interface, which talks
</EM><BR>
<EM>&gt; to a database backend (on another computer! gosh!), and, let's see, checks
</EM><BR>
<EM>&gt; for and downloads new config files from the internet, and, urm, displays
</EM><BR>
<EM>&gt; some slick graphs &amp; pie charts, and, ah, yeah, plays a full motion video for
</EM><BR>
<EM>&gt; a tutorial. And it's got to generate some letters to customers in an
</EM><BR>
<EM>&gt; interchangeable word processor format. The '85 programmer will say &quot;long&quot;.
</EM><BR>
<EM>&gt; And wait till you see that slick interface. Console apps; whoa; remember
</EM><BR>
<EM>&gt; those?
</EM><BR>
<EM>&gt;
</EM><BR>
<P>I remember developing a distributed persistent development and
<BR>
deployment system at that time personally.  The interface was Display
<BR>
Postscript.  Before that I was hacking Smalltalk and doing rapid
<BR>
prototyping of interface. Before that I was working on multi-process,
<BR>
multi-computer systems creating large document storage and retrieval
<BR>
systems that actually did several of the things mentioned.  So? 
<BR>
&nbsp;
<BR>
<EM>&gt; Then compare the skill required of each of those programmers to achieve the
</EM><BR>
<EM>&gt; same thing. The modern vb coder can be a relative doofus. Meanwhile, the
</EM><BR>
<EM>&gt; genius who coded this app back in '85 is now doing... something... hard and
</EM><BR>
<EM>&gt; scary. Like trying to make that damned VB app scalable (good luck!).
</EM><BR>
<EM>&gt; 
</EM><BR>
<P>A relative doofus with a bunch of sharp tools leaves a lot of blood on
<BR>
the floor.  The genius is refusing to try to make VB BS be what it was
<BR>
never designed to be.  
<BR>
<P><EM>&gt; &gt; Putting various things in the OS is not a very bright idea.  The things
</EM><BR>
<EM>&gt; &gt; in the OS should be the minimum that can be handled more efficiently and
</EM><BR>
<EM>&gt; &gt; cleanly there.  A web browser is not an example of such.
</EM><BR>
<EM>&gt; &gt;
</EM><BR>
<EM>&gt; 
</EM><BR>
<EM>&gt; Maybe it's a question of terminology. What's an OS? What's my computer?
</EM><BR>
<EM>&gt; What's the internet? Where's the boundary? I'm starting to side with MS on
</EM><BR>
<EM>&gt; the browser issue; that browser really truly is part of the OS (well, the
</EM><BR>
<EM>&gt; GUI anyway); and why not? The computer's part of the internet... why
</EM><BR>
<EM>&gt; shouldn't the OS provide support for that?
</EM><BR>
<EM>&gt;
</EM><BR>
<P>Because the browser is an application rather than a set of services that
<BR>
enable all applications.  It is an application framework if you squint
<BR>
just so but not bedrock system services. Pulling the browser into the OS
<BR>
also potentially pulls in everything you might want to associate with a
<BR>
browser like rendering engines, scripting language support, various file
<BR>
format supports on and on.  The OS becomes a black hole sucking in
<BR>
everything else.  You end up with a massively entangled system that can
<BR>
be disentangled to build subsets in embedded systems or to easily port
<BR>
OS swallowed things outside that OS environment.  And the debugging and
<BR>
maintenance gets much more convuluted.  You also introduce the
<BR>
possibility of far deeper security holes when you move more software
<BR>
into or closer to the kernel shell.  
<BR>
<P>The computer being part of the internet is supported by OS level support
<BR>
for internet protocols like TCP/IP.  A particular set of HTML/CSS/XML/?
<BR>
rendering tools and interfaces to the WEB is not a fundamental enabling
<BR>
protocol and is something you would like to be able to examine,change,
<BR>
modify, replace without hacking your OS (which means begging Microsoft)
<BR>
to do it.
<BR>
<P>&nbsp;
<BR>
<EM>&gt; I'm surprised to see someone who understands COM holding such an opinion,
</EM><BR>
<EM>&gt; actually.
</EM><BR>
<EM>&gt;
</EM><BR>
<P>Perhaps it is because I do understand COM and what it is and is not.
<BR>
<P>&nbsp;
<BR>
<EM>&gt; &gt;
</EM><BR>
<EM>&gt; &gt; VB will not allow you to do most of these things.  Back when I (shameful
</EM><BR>
<EM>&gt; &gt; to admit) hacked some VB I had to write anything interesting in C++/DCOM
</EM><BR>
<EM>&gt; &gt; and then do the GUI in VB and have it call the C++ COM objects.   It
</EM><BR>
<EM>&gt; &gt; works, but is totally proprietary to Microsloth.
</EM><BR>
<EM>&gt; 
</EM><BR>
<EM>&gt; Write it in Delphi.
</EM><BR>
<EM>&gt;
</EM><BR>
<P>And make it proprietary to Borland... 
<BR>
&nbsp;
<BR>
<EM>&gt; There are far better development tools than MS provides, for the windows
</EM><BR>
<EM>&gt; environment. Don't believe the hype; they actually turn out fantastically
</EM><BR>
<EM>&gt; good code. Delphi, for instance, does the interface as easily as VB, and the
</EM><BR>
<EM>&gt; COM/DCOM/COM+/(add acronym of choice) as well as, and far more easily than,
</EM><BR>
<EM>&gt; C++. I assume you are talking about MS Visual C; there are other kinds, with
</EM><BR>
<EM>&gt; better toolsets available.
</EM><BR>
<EM>&gt;
</EM><BR>
<P>I know.  As long as Microsoft doesn't hack parts of their system to
<BR>
destroy compatibility yet again. 
<BR>
&nbsp;
<BR>
<EM>&gt; &gt;
</EM><BR>
<EM>&gt; &gt; You must be in a very different world or you don't see beneath the
</EM><BR>
<EM>&gt; &gt; wizards and the push-button IDE.  The underlying stuff has largely not
</EM><BR>
<EM>&gt; &gt; improved at all except for the addition of binary components using CORBA
</EM><BR>
<EM>&gt; &gt; and COM.  Even those two are not a great improvement over a
</EM><BR>
<EM>&gt; &gt; distributed/persistent peer-peer object application environment I
</EM><BR>
<EM>&gt; &gt; created in 1986-1987.  It was unfortunately ahead of its time and
</EM><BR>
<EM>&gt; &gt; created under the auspices of a company that had no idea what to do with
</EM><BR>
<EM>&gt; &gt; it.
</EM><BR>
<EM>&gt; &gt;
</EM><BR>
<EM>&gt; 
</EM><BR>
<EM>&gt; You ought to start a dotcom to market this thing, go out and change the
</EM><BR>
<EM>&gt; world.
</EM><BR>
<EM>&gt; 
</EM><BR>
<EM>&gt; It's all in the baseline. In 1986, you had to build it yourself. Every
</EM><BR>
<EM>&gt; company that wanted it had to build it themselves (if they could be
</EM><BR>
<EM>&gt; bothered). Now it's out there, or an unmanageable, barely workable, hacked
</EM><BR>
<EM>&gt; up heterogeneous version of it is, anyway. Next week there'll be a new
</EM><BR>
<EM>&gt; version, a bit better, the week after that another version, even better, and
</EM><BR>
<EM>&gt; three weeks later it'll be stable and perfect, and meanwhile the next big
</EM><BR>
<EM>&gt; thing will have taken us all in a new direction; another 20 year old
</EM><BR>
<EM>&gt; technology whose time has come, which is cantankerous and immature and
</EM><BR>
<EM>&gt; horrible for developers, and which will kick off the next quiet (?) little
</EM><BR>
<EM>&gt; revolution, and have it's fifteen minutes of fame.
</EM><BR>
<EM>&gt;
</EM><BR>
<P>These better versions won't get out there without Open Source.  We are
<BR>
building deeper layers of IP laws now than anything I had to deal with
<BR>
in 1986.  The current IP laws would have either stopped me dead in the
<BR>
water or made me extremely rich at the price of a lot of innovation
<BR>
being stifled.  Today, if I actually took the time to do due diligence
<BR>
search for software patents that my current project may be in violation
<BR>
of, I would be stopped dead.  Without Open Source the guts of these
<BR>
infrastructures and frameworks are not exposed and not open to evolution
<BR>
except by  or with the express consent and usually prohibitively high
<BR>
licensing fees of the originating company. In the meantime the
<BR>
originating company is fighting to increase sales and acceptance and
<BR>
casting the core technology in stone that even they will not dare break
<BR>
open and reinvent because they have too much riding on it and are too
<BR>
busy fixing the bugs, especially systemic ones that grow out of the
<BR>
architecture's limitations and the ever expanding attempt to sell it as
<BR>
all things to all people.  
<BR>
<P><P><EM>&gt; If it's mature, it's obsolete.
</EM><BR>
<EM>&gt;
</EM><BR>
<P>Unless it is flexible enough to evolve more or less gracefully.  Unless
<BR>
the societal/marketing environment is such to allow more evolution.
<BR>
&nbsp;
<BR>
<EM>&gt; &gt;
</EM><BR>
<EM>&gt; &gt; Our present underlying compiler and linker technology is not much better
</EM><BR>
<EM>&gt; &gt; than it was then.  Linkers have changed almost not at all.  DLLs?  Came
</EM><BR>
<EM>&gt; &gt; out in the mid 80s.  The productivity tools for programmers leave a lot
</EM><BR>
<EM>&gt; &gt; to be desired.  In the Microsloth world to browse the call graphs of
</EM><BR>
<EM>&gt; &gt; functions and objects the software entity must first be fully compiled
</EM><BR>
<EM>&gt; &gt; with a bunch of special purpose flags set.  From one component you can't
</EM><BR>
<EM>&gt; &gt; browse into such details of another one.  The information is not unified
</EM><BR>
<EM>&gt; &gt; into some database you can query about various software artifacts and
</EM><BR>
<EM>&gt; &gt; their interaction and inter-dependencies.  What data that is gathered is
</EM><BR>
<EM>&gt; &gt; in a Microsoft proprietary format that you cannot use to develop
</EM><BR>
<EM>&gt; &gt; something more intelligent.  Yet Lisp and Smalltalk environment have had
</EM><BR>
<EM>&gt; &gt; such abilities for the last decade or even two.  I wrote such an
</EM><BR>
<EM>&gt; &gt; information extractor myself for some &lt;gasp&gt; Cobol legacy stuff I got
</EM><BR>
<EM>&gt; &gt; stuck with once in 1984.
</EM><BR>
<EM>&gt; 
</EM><BR>
<EM>&gt; Why aren't we using Lisp and Smalltalk then? I mean this as a serious
</EM><BR>
<EM>&gt; question; there's a serious answer there somewhere. Anyone?
</EM><BR>
<EM>&gt;
</EM><BR>
<P>Lisp is almost too powerful.  It takes a rarer programmer to use it
<BR>
elegantly and well than to use languages like VB, C++ and Java.  In Lisp
<BR>
you often design a programming environment for tackling the type of
<BR>
application you are building before building the application.  This is
<BR>
quite good and productive if you are good at it but that first new
<BR>
application of a particular kind might take longer and be less
<BR>
understandable to less talented programmers.  Lisp was also mis-sold as
<BR>
requiring dedicated hardware to run well by a company in the business of
<BR>
creating such dedicated hardware.  In actuality lisp interpreters,
<BR>
compilers and optimizers were written for many heterogeneous platforms
<BR>
and by the early 90s the optimized speed was only 2 or 3 times optimized
<BR>
C.  That is faster than most of the Java machinery today.  Lisp also
<BR>
suffered from the repurcussion of the great AI oversell.  
<BR>
<P>Smalltalk got hurt imho by not evolving fast enough.  It had and has a
<BR>
killer programming environment except that it was pretty much a private
<BR>
user/developer sandbox not well integrated (generally speaking) to team
<BR>
level projects.  There were tools developed to get around this limit but
<BR>
too little and too late.  Also, producing standalone executables was not
<BR>
so well addressed.  And, until say 93 or so, average machines were less
<BR>
than stellar running Smalltalk.  Perhaps the largest gap was not
<BR>
extending smalltalk into the scripting space (quite easy to do) into
<BR>
inter-process communication and into applet building when the Web came
<BR>
along.  
<BR>
<P>Thruthfully though, there are way too many business, media and cultural
<BR>
factors that also played a part in the outcome for me to pretend to
<BR>
untangle them all. 
<BR>
&nbsp;
<BR>
<EM>&gt; &gt;
</EM><BR>
<EM>&gt; &gt; The reason it is getting more difficult is the systems needed are more
</EM><BR>
<EM>&gt; &gt; sophisticated and the tools and infrastructure have not kept up with
</EM><BR>
<EM>&gt; &gt; them.  It is difficult to pour energy into better programming tools when
</EM><BR>
<EM>&gt; &gt; that kind of product doesn't pay off so well at the bank to make the VC
</EM><BR>
<EM>&gt; &gt; happy.  It is difficult to build them in house without the sponsoring
</EM><BR>
<EM>&gt; &gt; management looking like they don't have an eye on the bottom line.  So
</EM><BR>
<EM>&gt; &gt; we race faster and faster armed with inadequate tools and every more
</EM><BR>
<EM>&gt; &gt; pressing requirements, busily trying to automate everyone else's work
</EM><BR>
<EM>&gt; &gt; except our own.
</EM><BR>
<EM>&gt; 
</EM><BR>
<EM>&gt; That's true; we automate everyone else's work except our own. Meanwhile
</EM><BR>
<EM>&gt; someone else is bustin their behind to automate our work. It's not sensible
</EM><BR>
<EM>&gt; to say that the tools are there because no one can be bothered building
</EM><BR>
<EM>&gt; them; providing the best tools is a market worth a fortune. So there must be
</EM><BR>
<EM>&gt; another reason.
</EM><BR>
<EM>&gt;
</EM><BR>
<P><P>Actually it is not so lucrative a business.  Consider.  I build the best
<BR>
say, Java, environment around.  If I price it inline with current
<BR>
products I can charge, oh, say $600 for it.  At that price a lot of
<BR>
developers will not try it and probably can't get their manager to risk
<BR>
their development schedule on this new tool.  But assume I can get it. 
<BR>
Probably no more than 10% of the developers are going to buy this tool
<BR>
in the first year of its being on the shelf.  To get to that first year
<BR>
probably took on the order of 2-3 years of business startup cost,
<BR>
development and marketing.  Assuming roughly 2 million java developers
<BR>
gives me 200000 x $600 = $12 million in sales.  Barely my startup costs
<BR>
to date.   And that is if everything goes quite well.  Most VCs are not
<BR>
impressed with such ROI.  
<BR>
<P>&nbsp;
<BR>
<EM>&gt; I think the tools are barely adequate to the task. Only just enough to be
</EM><BR>
<EM>&gt; able to build what needs building. If they weren't adequate, we wouldn't be
</EM><BR>
<EM>&gt; able to build things. If they were mature, they'd be obsolete.
</EM><BR>
<EM>&gt;
</EM><BR>
<P>They are not adequate to build some of what is needed.  We hack it
<BR>
together the best we can anyway.  All turing machines are equivalent in
<BR>
capability but not in what they enable at what cost.  As someone that
<BR>
has been around for awhile I don't buy into mature == obsolete. :-)
<BR>
&nbsp;
<BR>
<EM>&gt; Again, it's that drive to reach as far as we can possibly reach. The front
</EM><BR>
<EM>&gt; line is always out where it is barely possible to do what is required. So of
</EM><BR>
<EM>&gt; course the tools are only just coping, of course things are cobbled together
</EM><BR>
<EM>&gt; and crazy and kludgey; there's no other way to succeed. When there is a
</EM><BR>
<EM>&gt; better way, the race will have moved on.
</EM><BR>
<P>It is not quite that simple.  Bread and butter programming is being done
<BR>
today with tools that suck.  The results suck so much that most
<BR>
companies will not even market them without huge disclaimers stating
<BR>
that they are not fit for consumption.  Producing really good dependable
<BR>
software is not easy. The ugly truth is we don't know that terribly much
<BR>
about how to do so and that we ignore a great deal of what we do know
<BR>
because we are in too much of a hurry to field something/anything that
<BR>
might be at least no worse than what the competition is fielding. 
<BR>
Beware the coming backlash.  
<BR>
<P><EM>&gt; &gt;
</EM><BR>
<EM>&gt; &gt; How does this tie-in to  extropian interests?  The future and the tech
</EM><BR>
<EM>&gt; &gt; we all so crave is built largely on top of software.  Keep most software
</EM><BR>
<EM>&gt; &gt; proprietary and don't invest in better software tools and the future
</EM><BR>
<EM>&gt; &gt; will be much more stunted than it could/should be.
</EM><BR>
<EM>&gt; &gt;
</EM><BR>
<EM>&gt; 
</EM><BR>
<EM>&gt; So do it. Build the better tools (again, apparently). If you are right,
</EM><BR>
<EM>&gt; you'll be really, really rich.
</EM><BR>
<EM>&gt;
</EM><BR>
<P>Money is just another resource, an enabler.  Thinking about it overmuch
<BR>
in terms of how rich you can get takes the focus off of what you are
<BR>
attempting to enable.  It is a trap. 
<BR>
&nbsp;
<BR>
<EM>&gt; &gt;
</EM><BR>
<EM>&gt; &gt; It is more cranky and brittle than it needs to be in part because of the
</EM><BR>
<EM>&gt; &gt; problems I mentioned.  There are also some real bearish problems in some
</EM><BR>
<EM>&gt; &gt; of our currently dreamed up systems.  Things that will take real R&amp;D
</EM><BR>
<EM>&gt; &gt; projects to solve and then under the current model would come out as a
</EM><BR>
<EM>&gt; &gt; bunch of hacked up tools positioned to maximize profit instead of being
</EM><BR>
<EM>&gt; &gt; shared across the entire industry that needs them so desparately.
</EM><BR>
<EM>&gt; 
</EM><BR>
<EM>&gt; This is not like aid to the poor or something. It's a wealthy industry. Us
</EM><BR>
<EM>&gt; poor, struggling, underappreciated developers, crushed under the weight of
</EM><BR>
<EM>&gt; ill-informed feudal overlords, are doing very nicely indeed. There's no
</EM><BR>
<EM>&gt; martyrdom available in the world of IT.
</EM><BR>
<EM>&gt;
</EM><BR>
<P>Nope.  It is a commons, a shared bedrock of experience and knowledge
<BR>
that all our success and greatness can build upon.  We instead build
<BR>
fenced in little claims on the commons and keep the information from
<BR>
flowing freely to invigorate all our efforts.   
<BR>
<P>Software developers, some of us at least, make good money.  But that
<BR>
does not equate automagically with our skills being well utilized to
<BR>
maximize the creation of ever greater real wealth and benefits.  Our
<BR>
making a bushel of money does not auto-translate to maximally enabling
<BR>
the extropian dream futures.  
<BR>
<P>Actually, we already have a software saint that largely changed the face
<BR>
of computing - Richard Stallman.  He was not alone.   Ask yourself why
<BR>
he managed to succeed and why that sort of working outside the rich
<BR>
rewards was needed to accomplish what he did.  Then you will perhaps see
<BR>
my point. 
<BR>
<P><EM>&gt; &gt;
</EM><BR>
<EM>&gt; &gt; &gt; People have been worried about the contrary point of view; that our
</EM><BR>
<EM>&gt; systems
</EM><BR>
<EM>&gt; &gt; &gt; are getting so big, so unwieldy, that at some point we cross a failure
</EM><BR>
<EM>&gt; &gt; &gt; threshold, beyond which we cannot, as a bunch of humans, reliably
</EM><BR>
<EM>&gt; maintain
</EM><BR>
<EM>&gt; &gt; &gt; the systems any more. Why would this be true?
</EM><BR>
<EM>&gt; &gt; &gt;
</EM><BR>
<EM>&gt; &gt;
</EM><BR>
<EM>&gt; &gt; Without the proper tools and without more and better automation it is
</EM><BR>
<EM>&gt; &gt; inevitable.
</EM><BR>
<EM>&gt; 
</EM><BR>
<EM>&gt; I'm not holding my breath. It's impossible to do when you are running.
</EM><BR>
<P><P>Sure, but are we progressing or spinning the little wheel in the cage
<BR>
ever faster? Or both?  How fast would we progress if we spent less
<BR>
energy spinning the wheel and going nowhere?
<BR>
<P><P><EM>&gt; 
</EM><BR>
<EM>&gt; &gt; We have automated certain classes of GUIs but the GUI story is far from
</EM><BR>
<EM>&gt; &gt; complete or adequate.  Many projects are now being seriously perverted
</EM><BR>
<EM>&gt; &gt; to use only a Web Browser as their GUI!  It is as if we are stepping
</EM><BR>
<EM>&gt; &gt; firmly into the past and putting more and more energy into centralized
</EM><BR>
<EM>&gt; &gt; servers even though we have more power on our desktops than we dared
</EM><BR>
<EM>&gt; &gt; dream of in the very recent past.  We need good massively distributed
</EM><BR>
<EM>&gt; &gt; peer-peer systems.  Not a sleazy 21st century rework of time-sharing
</EM><BR>
<EM>&gt; &gt; systems.
</EM><BR>
<EM>&gt; &gt;
</EM><BR>
<EM>&gt; 
</EM><BR>
<EM>&gt; Yep, I'm building some of those evil server-based, browser front-end gui
</EM><BR>
<EM>&gt; systems. They're shonky, the technology is immature and brittle and cranky,
</EM><BR>
<EM>&gt; and it's the right thing for the times. I can write software that can be
</EM><BR>
<EM>&gt; used by zillions of people all over the world, and yet I have central
</EM><BR>
<EM>&gt; control (and all the hideous problems, like scalability, which go with it).
</EM><BR>
<EM>&gt; I can do stuff which only recently became possible. These systems,
</EM><BR>
<EM>&gt; reminiscent as they are of the mainframe days of yore, are qualitatively
</EM><BR>
<EM>&gt; different, because they are doing the right job in this particular world.
</EM><BR>
<EM>&gt;
</EM><BR>
<P>It is not the right thing for the times.  It is merely what the
<BR>
interlocking forces are producing now.  What is is not &quot;right&quot; simply by
<BR>
being what is. 
<BR>
<P>Scalability is a problem even in massively distributed systems. 
<BR>
Massively distributed systems and their enabling technology are how you
<BR>
deal with scalability problems.  Centralization is not required. 
<BR>
Actually all the stuff we are doing with client-server web applications
<BR>
has been possible and done in some environments ever since the internet
<BR>
became ubiquitous which greatly predates the WEB.  I disagree that these
<BR>
systems are so qualitatively different.  Things like software agents are
<BR>
different.  But most of our web applications servers are relearning
<BR>
lessons learned by timesharing systems folks some time ago.  Yes some
<BR>
new solutions and ways of incorporating old and new solutions are being
<BR>
invented.  But the overarching architecture is still a step into the
<BR>
past.
<BR>
&nbsp;
<BR>
<EM>&gt; If I'm still building the same things in 2 years, someone come round and
</EM><BR>
<EM>&gt; give me a good slapping!
</EM><BR>
<EM>&gt;
</EM><BR>
<P>OK.  Are previews acceptable? :-)
<BR>
<P>&nbsp;
<BR>
<EM>&gt; &gt;
</EM><BR>
<EM>&gt; &gt; Sure.  Although of a quite different sort.  What disturbs me is how
</EM><BR>
<EM>&gt; &gt; often I am still doing the same tired old tasks in much the same tired
</EM><BR>
<EM>&gt; &gt; way.  There is not often enough time to both meet the current
</EM><BR>
<EM>&gt; &gt; over-inflated deadline for an underdesigned product and automate as much
</EM><BR>
<EM>&gt; &gt; of my own process as would satisfy me.
</EM><BR>
<EM>&gt; &gt;
</EM><BR>
<EM>&gt; 
</EM><BR>
<EM>&gt; We programmers have to get passed trying to automate our own tasks; it's not
</EM><BR>
<EM>&gt; our job. Our job is to do the tasks. Somewhere, someone will have the job of
</EM><BR>
<EM>&gt; trying to automate the tasks we are charged to do, and yet they will be
</EM><BR>
<EM>&gt; rankling because *their* job is less automated than they would like.
</EM><BR>
<EM>&gt;
</EM><BR>
<P>There is no one but us to do the job of automating our own work.  Who
<BR>
else knows as well what is needed or has the required automation skills?
<BR>
&nbsp;
<BR>
<EM>&gt; When your job is automated, it doesn't need you. The things you do will
</EM><BR>
<EM>&gt; always be unautomated, and hence a manual slog, by definition I think.
</EM><BR>
<EM>&gt;
</EM><BR>
<P>When more is automated I get to move on to hopefully more interesting
<BR>
and newer challenges.  That is progress.  I am not crying because what
<BR>
is not automated is not but because it can/should be and I want to get
<BR>
on with doing it and do not have the time and money to do so yet.
<BR>
&nbsp;
<BR>
<EM>&gt; &gt;
</EM><BR>
<EM>&gt; &gt; We don't yet do enough with well-defined and trusted components and with
</EM><BR>
<EM>&gt; &gt; good tools for finding the right components and simulating their
</EM><BR>
<EM>&gt; &gt; interaction.  Much of our code base is still language and OS dependent
</EM><BR>
<EM>&gt; &gt; and not componentized at all.  Most of code is still application
</EM><BR>
<EM>&gt; &gt; stovepipes with little/no reuse or reuseability.  In short, almost no
</EM><BR>
<EM>&gt; &gt; automation or next-level engineering applied to our own work.  It had
</EM><BR>
<EM>&gt; &gt; better not continue like this.
</EM><BR>
<EM>&gt; &gt;
</EM><BR>
<EM>&gt; 
</EM><BR>
<EM>&gt; I think this is getting better. Reusable components exist en-masse now;
</EM><BR>
<EM>&gt; that's pretty new. They're still in their early days, but damned impressive
</EM><BR>
<EM>&gt; really. I think it'll get better; open source may be the way.
</EM><BR>
<EM>&gt;
</EM><BR>
<P>I am not sure what you mean by components existing &quot;en-masse&quot;.  Most
<BR>
code is still not written with reuse as a high priority much less
<BR>
produced as full software components. 
<BR>
&nbsp;
<BR>
<EM>&gt; At some point, people will get genetic programming to the point where you
</EM><BR>
<EM>&gt; can make formal specs for a bit of a system (a component), with rigourous
</EM><BR>
<EM>&gt; definitions of the pre-built pieces (components) that system depends on and
</EM><BR>
<EM>&gt; the interface it will provide, and you will be able to evolve it. Arguably
</EM><BR>
<EM>&gt; that technique could build some very complex systems. Eventually you might
</EM><BR>
<EM>&gt; be able to evolve the design, as well as the implementation; and then we
</EM><BR>
<EM>&gt; begin to move into uncharted territory. Yet I still think that, even then,
</EM><BR>
<EM>&gt; there'll be a level for humans, hacking away at something which is still not
</EM><BR>
<EM>&gt; amenable to automation, standing on the generated systems and reaching for
</EM><BR>
<EM>&gt; the stars.
</EM><BR>
<EM>&gt;
</EM><BR>
<P>I agree.  So why aren't we out building that system today?  Wanna put
<BR>
together a business plan and go looking for funding?  Seriously.
<BR>
<P><P>- samantha
<BR>
<P><!-- body="end" -->
<HR NOSHADE>
<UL>
<!-- next="start" -->
<LI><STRONG>Next message:</STRONG> <A HREF="4984.html">Dan Fabulich: "Re: Dogmalaritarianism (was Re: Goals was: Transparency and IP)"</A>
<LI><STRONG>Previous message:</STRONG> <A HREF="4982.html">Brian D Williams: "Re: Arcologys"</A>
<LI><STRONG>In reply to:</STRONG> <A HREF="4959.html">Emlyn O'Regan: "Jobs, Lots of stuff about Software world (was re: Homeless)"</A>
<!-- nextthread="start" -->
<LI><STRONG>Next in thread:</STRONG> <A HREF="4989.html">Emlyn O'Regan: "Where's genetic programming at? (was Re: Jobs, Lots of stuff about Software world (was re: Homeless))"</A>
<LI><STRONG>Reply:</STRONG> <A HREF="4989.html">Emlyn O'Regan: "Where's genetic programming at? (was Re: Jobs, Lots of stuff about Software world (was re: Homeless))"</A>
<!-- reply="end" -->
<LI><STRONG>Messages sorted by:</STRONG> 
<A HREF="date.html#4983">[ date ]</A>
<A HREF="index.html#4983">[ thread ]</A>
<A HREF="subject.html#4983">[ subject ]</A>
<A HREF="author.html#4983">[ author ]</A>
</UL>
<!-- trailer="footer" -->
<HR NOSHADE>
<P>
<SMALL>
<EM>
This archive was generated by <A HREF="http://www.hypermail.org/">hypermail 2b29</A> 
: <EM>Mon Oct 02 2000 - 17:37:59 MDT</EM>
</EM>
</SMALL>
</BODY>
</HTML>
