<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
                      "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>
<HEAD>
<TITLE>extropians: Jobs, Lots of stuff about Software world (was re: H</TITLE>
<META NAME="Author" CONTENT="Emlyn O'Regan (emlyn@one.net.au)">
<META NAME="Subject" CONTENT="Jobs, Lots of stuff about Software world (was re: Homeless)">
</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<H1>Jobs, Lots of stuff about Software world (was re: Homeless)</H1>
<!-- received="Thu Sep 14 08:56:44 2000" -->
<!-- isoreceived="20000914145644" -->
<!-- sent="Fri, 15 Sep 2000 01:49:55 +1000" -->
<!-- isosent="20000914154955" -->
<!-- name="Emlyn O'Regan" -->
<!-- email="emlyn@one.net.au" -->
<!-- subject="Jobs, Lots of stuff about Software world (was re: Homeless)" -->
<!-- id="00cf01c01e63$e5ca4d50$bc630c3d@squashy2000" -->
<!-- inreplyto="39C07846.87F63FF7@objectent.com" -->
<STRONG>From:</STRONG> Emlyn O'Regan (<A HREF="mailto:emlyn@one.net.au?Subject=Re:%20Jobs,%20Lots%20of%20stuff%20about%20Software%20world%20(was%20re:%20Homeless)&In-Reply-To=&lt;00cf01c01e63$e5ca4d50$bc630c3d@squashy2000&gt;"><EM>emlyn@one.net.au</EM></A>)<BR>
<STRONG>Date:</STRONG> Thu Sep 14 2000 - 09:49:55 MDT
<P>
<!-- next="start" -->
<UL>
<LI><STRONG>Next message:</STRONG> <A HREF="4960.html">Emlyn O'Regan: "All my best ideas are my wife's (pertains to the &quot;how to change values&quot; thread)"</A>
<LI><STRONG>Previous message:</STRONG> <A HREF="4958.html">Scott Badger: "Nano News and Human Extinction"</A>
<LI><STRONG>In reply to:</STRONG> <A HREF="4930.html">Samantha Atkins: "Re: Homeless, (+ Jobs, Lots of stuff about Software world)"</A>
<!-- nextthread="start" -->
<LI><STRONG>Next in thread:</STRONG> <A HREF="4983.html">Samantha Atkins: "Re: Jobs, Lots of stuff about Software world (was re: Homeless)"</A>
<LI><STRONG>Reply:</STRONG> <A HREF="4983.html">Samantha Atkins: "Re: Jobs, Lots of stuff about Software world (was re: Homeless)"</A>
<!-- reply="end" -->
<LI><STRONG>Messages sorted by:</STRONG> 
<A HREF="date.html#4959">[ date ]</A>
<A HREF="index.html#4959">[ thread ]</A>
<A HREF="subject.html#4959">[ subject ]</A>
<A HREF="author.html#4959">[ author ]</A>
</UL>
<HR NOSHADE><P>
<!-- body="start" -->
<P>
Samantha (hello, nice to meet you in the weird world of this list) wrote:
<BR>
<EM>&gt; Emlyn O'Regan wrote:
</EM><BR>
<EM>&gt;
</EM><BR>
(snipped the first set of stuff; my response is &quot;yes&quot;)
<BR>
<EM>&gt;
</EM><BR>
<EM>&gt; &gt; &gt;
</EM><BR>
<EM>&gt; &gt; &gt; I worry about another problem.  Technology is still marching forward.
</EM><BR>
I
<BR>
<EM>&gt; &gt; &gt; support this 101% of course.  But, as it advances it automates more
</EM><BR>
and
<BR>
<EM>&gt; &gt; &gt; more job levels.  I predict that within 5-10 years it will automate
</EM><BR>
most
<BR>
<EM>&gt; &gt; &gt; of what is called programming today.  This is only one example.  As we
</EM><BR>
<EM>&gt; &gt; &gt; get more powerful computers at lower cost with more AIish abilities
</EM><BR>
more
<BR>
<EM>&gt; &gt; &gt; and more jobs will fall to them.  We had best be thinking really hard
</EM><BR>
<EM>&gt; &gt; &gt; right now about how we plan to have people have a decent life without
</EM><BR>
a
<BR>
<EM>&gt; &gt; &gt; regular for pay job.  Despite the current rather slanted rosy
</EM><BR>
<EM>&gt; &gt; &gt; unemployment statistics in the US, the problem is real and it will
</EM><BR>
<EM>&gt; &gt; &gt; eventually hit even many of us.
</EM><BR>
<EM>&gt; &gt;
</EM><BR>
<EM>&gt; &gt; Hee hee, the old &quot;programmers will be redundant in 5-10 years&quot; line.
</EM><BR>
Haven't
<BR>
<EM>&gt; &gt; heard that for a while; supposedly it's been kicking around since at
</EM><BR>
least
<BR>
<EM>&gt; &gt; the 70s. It's no truer today than it has ever been.
</EM><BR>
<EM>&gt; &gt;
</EM><BR>
<EM>&gt;
</EM><BR>
<EM>&gt; Don't bet on it.  What changes between then and now is the raw power of
</EM><BR>
<EM>&gt; the hardware.  As it becomes more powerful it becomes more tractable to
</EM><BR>
<EM>&gt; automate large segments of the work programmers currently do.  Of
</EM><BR>
<EM>&gt; course, the demand for programming is so huge that it will take a while
</EM><BR>
<EM>&gt; before the automation cuts into the need for programmers too much.  But
</EM><BR>
<EM>&gt; the level of programmer needed will continue to rise also, stranding
</EM><BR>
<EM>&gt; many who are now in that profession.  Don't believe me?  Wait and see.
</EM><BR>
<P>I don't believe you, I will have to wait and see.
<BR>
<P>Seriously, the key here is that the work that programmers *currently* do
<BR>
will be automated. But no one will automate the new stuff that we 1:want to
<BR>
do, and 2: can do because we automated all the stuff that used to be hard,
<BR>
but 3: can't actually automate yet. Because we wont be able to automate it
<BR>
yet. But if there's advantage to be had, people will still *do* it, just
<BR>
using more people.
<BR>
<P>I agree that the job of the programmer will probably get even harder. I
<BR>
think we are already seeing the most drastic shortages in the newest areas,
<BR>
especially where the work is actually really hard. That's probably going to
<BR>
keep happening.
<BR>
<P>Or maybe it just seems harder as you get older; maybe the new guys &amp; gals
<BR>
will swim like fish in the latest version of the techno-whirlpool. Can fish
<BR>
swim through a whirlpool? I guess we'll find out.
<BR>
<P><EM>&gt;
</EM><BR>
<EM>&gt;
</EM><BR>
<EM>&gt; &gt; It is true that we continue to automate things which used to be done
</EM><BR>
<EM>&gt; &gt; manually. So why aren't all the coders on the dole queue? It's because,
</EM><BR>
as
<BR>
<EM>&gt; &gt; something is automated, it becomes qualitatively different (easier) to
</EM><BR>
build
<BR>
<EM>&gt; &gt; systems based on that something. In terms of possible systems, entirely
</EM><BR>
new
<BR>
<EM>&gt; &gt; vistas open up, which although reliant on the newly automated something,
</EM><BR>
are
<BR>
<EM>&gt; &gt; not themselves automated, and require lots of people to build them.
</EM><BR>
<EM>&gt; &gt;
</EM><BR>
<EM>&gt;
</EM><BR>
<EM>&gt; Actually, having been in the software world myself for 20 years, I
</EM><BR>
<EM>&gt; suspect the truth is a bit dimmer than that.  Many of the tools I use
</EM><BR>
<EM>&gt; haven't evolved hardly at all in all of that time.  C lead to C++ but
</EM><BR>
<EM>&gt; the tools used to graft C++ have not exactly gone through any major
</EM><BR>
<EM>&gt; revolution.  C++ itself is quite primitive in many ways.  Java?
</EM><BR>
<EM>&gt; Interesting things have been done to exploit some of its features but
</EM><BR>
<EM>&gt; the language itself is not that powerful and not sufficient for many
</EM><BR>
<EM>&gt; types of problems.  Any interpreted or semi-interpreted language with
</EM><BR>
<EM>&gt; equal or more reflection could be used in most of the contexts that Java
</EM><BR>
<EM>&gt; is used.  Some of these languages, such as Lisp and Smalltalk, are or
</EM><BR>
<EM>&gt; have been much more powerful and advanced in capability, usage, or
</EM><BR>
<EM>&gt; development environment than Java, C++, VB and so on are today.  Most of
</EM><BR>
<EM>&gt; the central abilities in languages were first invented and explored in
</EM><BR>
<EM>&gt; Lisp.
</EM><BR>
<P>... and none of them are really relevant to this discussion. Sure, the ideas
<BR>
are have been around a long time, everything's been thought up before in any
<BR>
case. It's all about how you put them together into new things.
<BR>
<P>I would point to things like the libraries of prebuilt functions and
<BR>
components which are available, the infrastructure that is now a given, the
<BR>
system architectures which are commonplace now, as places where you see the
<BR>
advancements. Sure, I might write a system in C++ today, just like someone
<BR>
might have done 10 years ago. But things I can achieve with that system now,
<BR>
the toolset I have available to do it, the very fact that the system itself
<BR>
is less important than the mighty global super-system in which it takes its
<BR>
humble place... this is the march forward. And it's not a march, so much as
<BR>
a sprint.
<BR>
<P>It's a long time since I got to write some software with the fundamental
<BR>
assumptions that it would run on one computer and be used by a handful of
<BR>
people, in isolation, sitting on top of an OS and not much more.
<BR>
<P><EM>&gt;
</EM><BR>
<EM>&gt; We are beginning to address problems of programming in the large but
</EM><BR>
<EM>&gt; frankly many of the solutions are giant kludges that are severely
</EM><BR>
<EM>&gt; over-hyped and over-sold.  I have gotten quite disgruntled with this
</EM><BR>
<EM>&gt; industry.  We spend more time trying to lock up &quot;intellectual property&quot;
</EM><BR>
<EM>&gt; and out-hype the competition than we do actually designing and building
</EM><BR>
<EM>&gt; good systems.  And fixing our development tools themselves takes a
</EM><BR>
<EM>&gt; backseat to even that.  I designed and built things in the 80s ( and I
</EM><BR>
<EM>&gt; am not unique in this at all) that are as or more advanced than some
</EM><BR>
<EM>&gt; parts of the current highly-hyped baseline.
</EM><BR>
<EM>&gt;
</EM><BR>
<P>Point is, they were a fair way from the baseline then, and probably aren't
<BR>
now. I know lots of technocrats get cranky because what's just come out as
<BR>
some Windows 2000 feature &quot;was old news back when I was programming Eniac&quot;.
<BR>
It doesn't mean anything. Excel uses maths, that's been around for millenia.
<BR>
I still run on essentially the same wetware that the fishies have been using
<BR>
for ever.
<BR>
<P>I've had people tell me that the internet is nothing new, and hey, the
<BR>
French had a bigger system way back when, with computers linked together in
<BR>
the hands of the general populace (a centralised system I think). Sure the
<BR>
net is old (relative to what?), but it's also new; it's not the same thing
<BR>
that it was five years ago, two years ago, last week. Sure the french had
<BR>
some automated phone book thing, big deal. Would you swap it for this?
<BR>
<P>The baseline is one of the big things. Now we've got distributed
<BR>
transaction/object systems, multi-tiered system infrastructure, all these
<BR>
neat things that have been around for donkey's years. So what? So, they are
<BR>
turning up in the baseline. As a lowest common denominator. Admitedly it's
<BR>
all heterogeous madness still, but it's coming together. That's not a cause
<BR>
for cynicism, that &quot;yeah, been there, done that&quot; attitude. It really ought
<BR>
to blow your mind.
<BR>
<P>It's all in how you look at it... for instance, is Napster a hopelessly
<BR>
technologically boorish file transfer utility, or is it a major social
<BR>
revolution, the outcome of which, while unknowable, is certain to be major
<BR>
and irreversible?
<BR>
<P>Because you can do things with it that you could never conceive of doing
<BR>
before. This &quot;new economy&quot; thing is not some hyped up joke; it's happening.
<BR>
The technology, important as it is, doesn't matter at all. It's what we can
<BR>
do, and are doing, that matters.
<BR>
<P><EM>&gt; Sorry.  Most of that is an aside and off-topic.  I needed to rant. But
</EM><BR>
<EM>&gt; personally I don't think software development will get significantly
</EM><BR>
<EM>&gt; better until something like Open Source (better add Open Design) and
</EM><BR>
<EM>&gt; changes in the basis of software business occur.  I don't see how the
</EM><BR>
<EM>&gt; current model has room to get out of its own way.
</EM><BR>
<P>Open Source... hmmm. I've been in the MS world too long, I don't have more
<BR>
than a passing knowledge of how it works. I think you are right; it is the
<BR>
way forward. It's going to be a bumpy, crazy, messy, perilous way, but it'll
<BR>
become clear that it's the only road open I think.
<BR>
<P>I don't think software will get any better, however. The best we can
<BR>
probably hope for is that it will remain feasible to develop software. And
<BR>
that'll do fine!
<BR>
<P><EM>&gt;
</EM><BR>
<EM>&gt; &gt; Once upon a time, to write software, you had to write your own OS. Then
</EM><BR>
OSes
<BR>
<EM>&gt; &gt; started to appear, and provided basic functionality (loading a progrm
</EM><BR>
into
<BR>
<EM>&gt; &gt; memory, talking to disks, basic screen handling, and all kinds of other
</EM><BR>
<EM>&gt; &gt; stuff). Later, programmers spent a lot of time writing (console based)
</EM><BR>
user
<BR>
<EM>&gt; &gt; interface code, reading and writing from primitive disk files, all those
</EM><BR>
<EM>&gt; &gt; good things. Then databases started to become common, and GUIs became
</EM><BR>
<EM>&gt; &gt; common, and other things became the programmer's task. Now people wanted
</EM><BR>
<EM>&gt; &gt; nicer printouts, programs that interoperated, pretty gui front ends,
</EM><BR>
and,
<BR>
<EM>&gt; &gt; urm, networking! Programmers wrote lots and lots of code by hand,
</EM><BR>
performing
<BR>
<EM>&gt; &gt; those tasks; evetually it was again subsumed into the OS. At some point
</EM><BR>
<EM>&gt; &gt; Microsoft invented VB, and programmers were redundant forever shortly
</EM><BR>
<EM>&gt; &gt; thereafter.
</EM><BR>
<EM>&gt; &gt;
</EM><BR>
<EM>&gt;
</EM><BR>
<EM>&gt; GAG!  VB is one of the worst blights exemplifying the very problems in
</EM><BR>
<EM>&gt; the industry I spoke of above.  The very idea of inflicting on millions
</EM><BR>
<EM>&gt; of programmers a language environment that has a badly scaled Basic at
</EM><BR>
<EM>&gt; its core pretending to be object oriented (laugh) and which is not even
</EM><BR>
<EM>&gt; powerful enough to handle full COM components and on top of this has the
</EM><BR>
<EM>&gt; IDE, your program and the debugger in one process so any problems crash
</EM><BR>
<EM>&gt; the entire mess - well, the whole thing is simply and utterly
</EM><BR>
<EM>&gt; infuriating.  I can and have designed better programming environments in
</EM><BR>
<EM>&gt; my sleep.  Microsoft should be shot for gross ineptitude and programmer
</EM><BR>
<EM>&gt; abuse.  Of course they were never really about making the world better
</EM><BR>
<EM>&gt; for software development  They are only in it to capture the market and
</EM><BR>
<EM>&gt; eliminate the competition.  Or at least any good tendencies in its
</EM><BR>
<EM>&gt; people are subsumed by that bottom line over and over again.
</EM><BR>
<P>Crocodile tears? I agree with the technological assessment; a shocking
<BR>
language, horrible, the costs of which will become apparent as time wears
<BR>
on, and the legacy mountain of VB grows.
<BR>
<P>But then again, from what I've seen, you can throw together some pretty
<BR>
amazing stuff in very short time. Go back to '85, and ask someone how long
<BR>
it'll take to get an app together with a slick user interface, which talks
<BR>
to a database backend (on another computer! gosh!), and, let's see, checks
<BR>
for and downloads new config files from the internet, and, urm, displays
<BR>
some slick graphs &amp; pie charts, and, ah, yeah, plays a full motion video for
<BR>
a tutorial. And it's got to generate some letters to customers in an
<BR>
interchangeable word processor format. The '85 programmer will say &quot;long&quot;.
<BR>
And wait till you see that slick interface. Console apps; whoa; remember
<BR>
those?
<BR>
<P>Then compare the skill required of each of those programmers to achieve the
<BR>
same thing. The modern vb coder can be a relative doofus. Meanwhile, the
<BR>
genius who coded this app back in '85 is now doing... something... hard and
<BR>
scary. Like trying to make that damned VB app scalable (good luck!).
<BR>
<P><EM>&gt; Putting various things in the OS is not a very bright idea.  The things
</EM><BR>
<EM>&gt; in the OS should be the minimum that can be handled more efficiently and
</EM><BR>
<EM>&gt; cleanly there.  A web browser is not an example of such.
</EM><BR>
<EM>&gt;
</EM><BR>
<P>Maybe it's a question of terminology. What's an OS? What's my computer?
<BR>
What's the internet? Where's the boundary? I'm starting to side with MS on
<BR>
the browser issue; that browser really truly is part of the OS (well, the
<BR>
GUI anyway); and why not? The computer's part of the internet... why
<BR>
shouldn't the OS provide support for that?
<BR>
<P>I'm surprised to see someone who understands COM holding such an opinion,
<BR>
actually.
<BR>
<P><EM>&gt; &gt; Or that's the hype... oddly enough, there is such a thing as a VB
</EM><BR>
<EM>&gt; &gt; programmer, with possibly more positions available than any other
</EM><BR>
<EM>&gt; &gt; language/environment. Because the things it makes easy to do are easy to
</EM><BR>
do,
<BR>
<EM>&gt; &gt; sure. But now people can imagine even more complex systems, which they
</EM><BR>
would
<BR>
<EM>&gt; &gt; not have attempted before, which they can now just accomplish by writing
</EM><BR>
<EM>&gt; &gt; lots and lots of code. If they do these things in VB, it's often even
</EM><BR>
<EM>&gt; &gt; harder.
</EM><BR>
<EM>&gt; &gt;
</EM><BR>
<EM>&gt;
</EM><BR>
<EM>&gt; VB will not allow you to do most of these things.  Back when I (shameful
</EM><BR>
<EM>&gt; to admit) hacked some VB I had to write anything interesting in C++/DCOM
</EM><BR>
<EM>&gt; and then do the GUI in VB and have it call the C++ COM objects.   It
</EM><BR>
<EM>&gt; works, but is totally proprietary to Microsloth.
</EM><BR>
<P>Write it in Delphi.
<BR>
<P>There are far better development tools than MS provides, for the windows
<BR>
environment. Don't believe the hype; they actually turn out fantastically
<BR>
good code. Delphi, for instance, does the interface as easily as VB, and the
<BR>
COM/DCOM/COM+/(add acronym of choice) as well as, and far more easily than,
<BR>
C++. I assume you are talking about MS Visual C; there are other kinds, with
<BR>
better toolsets available.
<BR>
<P><EM>&gt;
</EM><BR>
<EM>&gt; &gt; This continues. As far as I can see, the tools have improved incredibly
</EM><BR>
<EM>&gt; &gt; beyond what I was using 10 years ago when I started uni. So much more is
</EM><BR>
<EM>&gt; &gt; possible; it's astounding. And yet, paradoxically, it is harder than
</EM><BR>
ever to
<BR>
<EM>&gt; &gt; be a programmer. The job is getting more and more difficult. Why?
</EM><BR>
<EM>&gt; &gt;
</EM><BR>
<EM>&gt;
</EM><BR>
<EM>&gt; You must be in a very different world or you don't see beneath the
</EM><BR>
<EM>&gt; wizards and the push-button IDE.  The underlying stuff has largely not
</EM><BR>
<EM>&gt; improved at all except for the addition of binary components using CORBA
</EM><BR>
<EM>&gt; and COM.  Even those two are not a great improvement over a
</EM><BR>
<EM>&gt; distributed/persistent peer-peer object application environment I
</EM><BR>
<EM>&gt; created in 1986-1987.  It was unfortunately ahead of its time and
</EM><BR>
<EM>&gt; created under the auspices of a company that had no idea what to do with
</EM><BR>
<EM>&gt; it.
</EM><BR>
<EM>&gt;
</EM><BR>
<P>You ought to start a dotcom to market this thing, go out and change the
<BR>
world.
<BR>
<P>It's all in the baseline. In 1986, you had to build it yourself. Every
<BR>
company that wanted it had to build it themselves (if they could be
<BR>
bothered). Now it's out there, or an unmanageable, barely workable, hacked
<BR>
up heterogeneous version of it is, anyway. Next week there'll be a new
<BR>
version, a bit better, the week after that another version, even better, and
<BR>
three weeks later it'll be stable and perfect, and meanwhile the next big
<BR>
thing will have taken us all in a new direction; another 20 year old
<BR>
technology whose time has come, which is cantankerous and immature and
<BR>
horrible for developers, and which will kick off the next quiet (?) little
<BR>
revolution, and have it's fifteen minutes of fame.
<BR>
<P>If it's mature, it's obsolete.
<BR>
<P><EM>&gt;
</EM><BR>
<EM>&gt; Our present underlying compiler and linker technology is not much better
</EM><BR>
<EM>&gt; than it was then.  Linkers have changed almost not at all.  DLLs?  Came
</EM><BR>
<EM>&gt; out in the mid 80s.  The productivity tools for programmers leave a lot
</EM><BR>
<EM>&gt; to be desired.  In the Microsloth world to browse the call graphs of
</EM><BR>
<EM>&gt; functions and objects the software entity must first be fully compiled
</EM><BR>
<EM>&gt; with a bunch of special purpose flags set.  From one component you can't
</EM><BR>
<EM>&gt; browse into such details of another one.  The information is not unified
</EM><BR>
<EM>&gt; into some database you can query about various software artifacts and
</EM><BR>
<EM>&gt; their interaction and inter-dependencies.  What data that is gathered is
</EM><BR>
<EM>&gt; in a Microsoft proprietary format that you cannot use to develop
</EM><BR>
<EM>&gt; something more intelligent.  Yet Lisp and Smalltalk environment have had
</EM><BR>
<EM>&gt; such abilities for the last decade or even two.  I wrote such an
</EM><BR>
<EM>&gt; information extractor myself for some &lt;gasp&gt; Cobol legacy stuff I got
</EM><BR>
<EM>&gt; stuck with once in 1984.
</EM><BR>
<P>Why aren't we using Lisp and Smalltalk then? I mean this as a serious
<BR>
question; there's a serious answer there somewhere. Anyone?
<BR>
<P><EM>&gt;
</EM><BR>
<EM>&gt; The reason it is getting more difficult is the systems needed are more
</EM><BR>
<EM>&gt; sophisticated and the tools and infrastructure have not kept up with
</EM><BR>
<EM>&gt; them.  It is difficult to pour energy into better programming tools when
</EM><BR>
<EM>&gt; that kind of product doesn't pay off so well at the bank to make the VC
</EM><BR>
<EM>&gt; happy.  It is difficult to build them in house without the sponsoring
</EM><BR>
<EM>&gt; management looking like they don't have an eye on the bottom line.  So
</EM><BR>
<EM>&gt; we race faster and faster armed with inadequate tools and every more
</EM><BR>
<EM>&gt; pressing requirements, busily trying to automate everyone else's work
</EM><BR>
<EM>&gt; except our own.
</EM><BR>
<P>That's true; we automate everyone else's work except our own. Meanwhile
<BR>
someone else is bustin their behind to automate our work. It's not sensible
<BR>
to say that the tools are there because no one can be bothered building
<BR>
them; providing the best tools is a market worth a fortune. So there must be
<BR>
another reason.
<BR>
<P>I think the tools are barely adequate to the task. Only just enough to be
<BR>
able to build what needs building. If they weren't adequate, we wouldn't be
<BR>
able to build things. If they were mature, they'd be obsolete.
<BR>
<P>Again, it's that drive to reach as far as we can possibly reach. The front
<BR>
line is always out where it is barely possible to do what is required. So of
<BR>
course the tools are only just coping, of course things are cobbled together
<BR>
and crazy and kludgey; there's no other way to succeed. When there is a
<BR>
better way, the race will have moved on.
<BR>
<EM>&gt;
</EM><BR>
<EM>&gt; How does this tie-in to  extropian interests?  The future and the tech
</EM><BR>
<EM>&gt; we all so crave is built largely on top of software.  Keep most software
</EM><BR>
<EM>&gt; proprietary and don't invest in better software tools and the future
</EM><BR>
<EM>&gt; will be much more stunted than it could/should be.
</EM><BR>
<EM>&gt;
</EM><BR>
<P>So do it. Build the better tools (again, apparently). If you are right,
<BR>
you'll be really, really rich.
<BR>
<P><EM>&gt; &gt; Well, because people want to interoperate. Heterogeneous networks,
</EM><BR>
<EM>&gt; &gt; applications, software layers, layer upon layer like a crazy croissant,
</EM><BR>
<EM>&gt; &gt; building new, more ambitious, more interesting systems than ever before.
</EM><BR>
The
<BR>
<EM>&gt; &gt; new economy, with the 'net as the centerpiece, is a mish mash of
</EM><BR>
components
<BR>
<EM>&gt; &gt; and chunks and layers and stuff, all trying to talk to each other, all
</EM><BR>
<EM>&gt; &gt; idiosyncratic, brittle, cranky code stretched out like a net weaved of
</EM><BR>
scrap
<BR>
<EM>&gt; &gt; metal. Making this stuff hang together is a mad job, done at a frenetic
</EM><BR>
<EM>&gt; &gt; speed as old technologies die and new technologies are born. There's no
</EM><BR>
<EM>&gt; &gt; comfort zone. There's no pause for breath. There's certainly no sign of
</EM><BR>
AI
<BR>
<EM>&gt; &gt; taking over any time soon!
</EM><BR>
<EM>&gt; &gt;
</EM><BR>
<EM>&gt;
</EM><BR>
<EM>&gt; It is more cranky and brittle than it needs to be in part because of the
</EM><BR>
<EM>&gt; problems I mentioned.  There are also some real bearish problems in some
</EM><BR>
<EM>&gt; of our currently dreamed up systems.  Things that will take real R&amp;D
</EM><BR>
<EM>&gt; projects to solve and then under the current model would come out as a
</EM><BR>
<EM>&gt; bunch of hacked up tools positioned to maximize profit instead of being
</EM><BR>
<EM>&gt; shared across the entire industry that needs them so desparately.
</EM><BR>
<P>This is not like aid to the poor or something. It's a wealthy industry. Us
<BR>
poor, struggling, underappreciated developers, crushed under the weight of
<BR>
ill-informed feudal overlords, are doing very nicely indeed. There's no
<BR>
martyrdom available in the world of IT.
<BR>
<P>The hacked-up tools are all about time. You can get the hacked up tools out
<BR>
there way before the wonderfully designed, standards driven, mana from the
<BR>
gods, perfect tools. And weirdly, by the time those perfect tools come out,
<BR>
there's no demand. They're obsolete.
<BR>
<P>Actually, that's not fair. By the time the really good stuff comes out, the
<BR>
tower of technology has been built higher. But, the hacked up tools that you
<BR>
are replacing are stuffed under the next couple of levels; this makes those
<BR>
levels shaky and unstable (and they of course are also cobbled together out
<BR>
of crap, so it's a scary place to be). If you're lucky, people will whip out
<BR>
the hacked crap, replace it with the excellent new stuff, and the tower can
<BR>
climb even higher.
<BR>
<P><EM>&gt;
</EM><BR>
<EM>&gt; &gt; People have been worried about the contrary point of view; that our
</EM><BR>
systems
<BR>
<EM>&gt; &gt; are getting so big, so unwieldy, that at some point we cross a failure
</EM><BR>
<EM>&gt; &gt; threshold, beyond which we cannot, as a bunch of humans, reliably
</EM><BR>
maintain
<BR>
<EM>&gt; &gt; the systems any more. Why would this be true?
</EM><BR>
<EM>&gt; &gt;
</EM><BR>
<EM>&gt;
</EM><BR>
<EM>&gt; Without the proper tools and without more and better automation it is
</EM><BR>
<EM>&gt; inevitable.
</EM><BR>
<P>I'm not holding my breath. It's impossible to do when you are running.
<BR>
<P><EM>&gt;
</EM><BR>
<EM>&gt; &gt; Well, much of the problem is that, even though basic OS features are
</EM><BR>
<EM>&gt; &gt; &quot;automated&quot;, even though the user interface (gui), persistent storage
</EM><BR>
<EM>&gt; &gt; (databases), communications (networks) are &quot;automated&quot;, they actually
</EM><BR>
<EM>&gt; &gt; aren't. These things work well now, but they are never quite perfect
</EM><BR>
(some
<BR>
<EM>&gt; &gt; people would say they are not even close!). Just ask UI programmers,
</EM><BR>
<EM>&gt; &gt; database programmers, OS coders, network engineers. All the hordes of
</EM><BR>
<EM>&gt; &gt; people, working to make/maintain the  &quot;automated&quot; systems, the stuff
</EM><BR>
that is
<BR>
<EM>&gt; &gt; already &quot;done&quot;.
</EM><BR>
<EM>&gt; &gt;
</EM><BR>
<EM>&gt;
</EM><BR>
<EM>&gt; My greatest expertise is in object persistence.  Persistence is far, far
</EM><BR>
<EM>&gt; from &quot;automated&quot;.  Persistence cross-cuts applications and products but
</EM><BR>
<EM>&gt; is often done as a series of hacks within a particular project
</EM><BR>
<EM>&gt; life-cycle.  Or a product is bought that promises to take the worries
</EM><BR>
<EM>&gt; all away but actually seriously perverts all application building
</EM><BR>
<EM>&gt; thereafter because its needs have to be met for the application to work
</EM><BR>
<EM>&gt; at all and its needs are to perturbing to everything else.  And the
</EM><BR>
<EM>&gt; solution ties the product and the organization often to the solution
</EM><BR>
<EM>&gt; provider firmly.  At the moment there is not a good persistent
</EM><BR>
<EM>&gt; middleware out there that fully meets what is needed.  There are various
</EM><BR>
<EM>&gt; attempts of greater/lesser goodness.  I plan to do large parts of that
</EM><BR>
<EM>&gt; problem better and to eventually release a series of Open Source
</EM><BR>
<EM>&gt; persistent middleware tools.  I am tired of seeing ugly solutions to
</EM><BR>
<EM>&gt; this set of problems I know well.
</EM><BR>
<EM>&gt;
</EM><BR>
<P>Excellent! That's the spirit! If you don't like it, fix it. Once you build
<BR>
the better tools, people will build on top of them, and reach to the kinds
<BR>
of possibilities you imagine opening up, given the existence of the new
<BR>
tools.
<BR>
<P>And what they'll use on top of your stuff, to reach those heights, will be
<BR>
shonky, hacked together crap. But at least they'll have a firm foundation.
<BR>
<P><EM>&gt; We have automated certain classes of GUIs but the GUI story is far from
</EM><BR>
<EM>&gt; complete or adequate.  Many projects are now being seriously perverted
</EM><BR>
<EM>&gt; to use only a Web Browser as their GUI!  It is as if we are stepping
</EM><BR>
<EM>&gt; firmly into the past and putting more and more energy into centralized
</EM><BR>
<EM>&gt; servers even though we have more power on our desktops than we dared
</EM><BR>
<EM>&gt; dream of in the very recent past.  We need good massively distributed
</EM><BR>
<EM>&gt; peer-peer systems.  Not a sleazy 21st century rework of time-sharing
</EM><BR>
<EM>&gt; systems.
</EM><BR>
<EM>&gt;
</EM><BR>
<P>Yep, I'm building some of those evil server-based, browser front-end gui
<BR>
systems. They're shonky, the technology is immature and brittle and cranky,
<BR>
and it's the right thing for the times. I can write software that can be
<BR>
used by zillions of people all over the world, and yet I have central
<BR>
control (and all the hideous problems, like scalability, which go with it).
<BR>
I can do stuff which only recently became possible. These systems,
<BR>
reminiscent as they are of the mainframe days of yore, are qualitatively
<BR>
different, because they are doing the right job in this particular world.
<BR>
<P>If I'm still building the same things in 2 years, someone come round and
<BR>
give me a good slapping!
<BR>
<P><EM>&gt; &gt; Something really different will have to happen to change this picture.
</EM><BR>
Super
<BR>
<EM>&gt; &gt; intelligent AI could do it (so could the wish fairies). Genetic
</EM><BR>
programming
<BR>
<EM>&gt; &gt; advances might have a shot, but will still require humans to coordinate
</EM><BR>
them
<BR>
<EM>&gt; &gt; at some level, especially given that our ambitions will increase by
</EM><BR>
orders
<BR>
<EM>&gt; &gt; of magnitude as our abilities increase, to keep us focused on what is
</EM><BR>
just
<BR>
<EM>&gt; &gt; out of reach. The job of configuring such magical genetic programmed
</EM><BR>
<EM>&gt; &gt; automated systems to reach these new goals will look a lot like, well,
</EM><BR>
<EM>&gt; &gt; programming.
</EM><BR>
<EM>&gt; &gt;
</EM><BR>
<EM>&gt;
</EM><BR>
<EM>&gt; Sure.  Although of a quite different sort.  What disturbs me is how
</EM><BR>
<EM>&gt; often I am still doing the same tired old tasks in much the same tired
</EM><BR>
<EM>&gt; way.  There is not often enough time to both meet the current
</EM><BR>
<EM>&gt; over-inflated deadline for an underdesigned product and automate as much
</EM><BR>
<EM>&gt; of my own process as would satisfy me.
</EM><BR>
<EM>&gt;
</EM><BR>
<P>We programmers have to get passed trying to automate our own tasks; it's not
<BR>
our job. Our job is to do the tasks. Somewhere, someone will have the job of
<BR>
trying to automate the tasks we are charged to do, and yet they will be
<BR>
rankling because *their* job is less automated than they would like.
<BR>
<P>When your job is automated, it doesn't need you. The things you do will
<BR>
always be unautomated, and hence a manual slog, by definition I think.
<BR>
<P><EM>&gt;
</EM><BR>
<EM>&gt; &gt; Sure the techniques will change. Sure the skill set required will
</EM><BR>
change.
<BR>
<EM>&gt; &gt; But the basic programming job will remain, and grow wider in my opinion.
</EM><BR>
<EM>&gt; &gt; Lots of things will begin to look like programming in the future, which
</EM><BR>
do
<BR>
<EM>&gt; &gt; not now. Biotech might get to a point of &quot;automation&quot; where it starts
</EM><BR>
using
<BR>
<EM>&gt; &gt; programmers. Through nanotech, even the bricks &amp; mortar world will start
</EM><BR>
to
<BR>
<EM>&gt; &gt; become a programming concern.
</EM><BR>
<EM>&gt; &gt;
</EM><BR>
<EM>&gt;
</EM><BR>
<EM>&gt; We don't yet do enough with well-defined and trusted components and with
</EM><BR>
<EM>&gt; good tools for finding the right components and simulating their
</EM><BR>
<EM>&gt; interaction.  Much of our code base is still language and OS dependent
</EM><BR>
<EM>&gt; and not componentized at all.  Most of code is still application
</EM><BR>
<EM>&gt; stovepipes with little/no reuse or reuseability.  In short, almost no
</EM><BR>
<EM>&gt; automation or next-level engineering applied to our own work.  It had
</EM><BR>
<EM>&gt; better not continue like this.
</EM><BR>
<EM>&gt;
</EM><BR>
<P>I think this is getting better. Reusable components exist en-masse now;
<BR>
that's pretty new. They're still in their early days, but damned impressive
<BR>
really. I think it'll get better; open source may be the way.
<BR>
<P>At some point, people will get genetic programming to the point where you
<BR>
can make formal specs for a bit of a system (a component), with rigourous
<BR>
definitions of the pre-built pieces (components) that system depends on and
<BR>
the interface it will provide, and you will be able to evolve it. Arguably
<BR>
that technique could build some very complex systems. Eventually you might
<BR>
be able to evolve the design, as well as the implementation; and then we
<BR>
begin to move into uncharted territory. Yet I still think that, even then,
<BR>
there'll be a level for humans, hacking away at something which is still not
<BR>
amenable to automation, standing on the generated systems and reaching for
<BR>
the stars.
<BR>
<P>Emlyn
<BR>
<P><!-- body="end" -->
<HR NOSHADE>
<UL>
<!-- next="start" -->
<LI><STRONG>Next message:</STRONG> <A HREF="4960.html">Emlyn O'Regan: "All my best ideas are my wife's (pertains to the &quot;how to change values&quot; thread)"</A>
<LI><STRONG>Previous message:</STRONG> <A HREF="4958.html">Scott Badger: "Nano News and Human Extinction"</A>
<LI><STRONG>In reply to:</STRONG> <A HREF="4930.html">Samantha Atkins: "Re: Homeless, (+ Jobs, Lots of stuff about Software world)"</A>
<!-- nextthread="start" -->
<LI><STRONG>Next in thread:</STRONG> <A HREF="4983.html">Samantha Atkins: "Re: Jobs, Lots of stuff about Software world (was re: Homeless)"</A>
<LI><STRONG>Reply:</STRONG> <A HREF="4983.html">Samantha Atkins: "Re: Jobs, Lots of stuff about Software world (was re: Homeless)"</A>
<!-- reply="end" -->
<LI><STRONG>Messages sorted by:</STRONG> 
<A HREF="date.html#4959">[ date ]</A>
<A HREF="index.html#4959">[ thread ]</A>
<A HREF="subject.html#4959">[ subject ]</A>
<A HREF="author.html#4959">[ author ]</A>
</UL>
<!-- trailer="footer" -->
<HR NOSHADE>
<P>
<SMALL>
<EM>
This archive was generated by <A HREF="http://www.hypermail.org/">hypermail 2b29</A> 
: <EM>Mon Oct 02 2000 - 17:37:58 MDT</EM>
</EM>
</SMALL>
</BODY>
</HTML>
