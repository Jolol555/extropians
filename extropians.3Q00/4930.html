<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
                      "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>
<HEAD>
<TITLE>extropians: Re: Homeless, (+ Jobs, Lots of stuff about Software</TITLE>
<META NAME="Author" CONTENT="Samantha Atkins (samantha@objectent.com)">
<META NAME="Subject" CONTENT="Re: Homeless, (+ Jobs, Lots of stuff about Software world)">
</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<H1>Re: Homeless, (+ Jobs, Lots of stuff about Software world)</H1>
<!-- received="Thu Sep 14 01:02:14 2000" -->
<!-- isoreceived="20000914070214" -->
<!-- sent="Thu, 14 Sep 2000 00:03:34 -0700" -->
<!-- isosent="20000914070334" -->
<!-- name="Samantha Atkins" -->
<!-- email="samantha@objectent.com" -->
<!-- subject="Re: Homeless, (+ Jobs, Lots of stuff about Software world)" -->
<!-- id="39C07846.87F63FF7@objectent.com" -->
<!-- inreplyto="007501c01d7f$9b9b9250$41600c3d@squashy2000" -->
<STRONG>From:</STRONG> Samantha Atkins (<A HREF="mailto:samantha@objectent.com?Subject=Re:%20Homeless,%20(%2B%20Jobs,%20Lots%20of%20stuff%20about%20Software%20world)&In-Reply-To=&lt;39C07846.87F63FF7@objectent.com&gt;"><EM>samantha@objectent.com</EM></A>)<BR>
<STRONG>Date:</STRONG> Thu Sep 14 2000 - 01:03:34 MDT
<P>
<!-- next="start" -->
<UL>
<LI><STRONG>Next message:</STRONG> <A HREF="4931.html">Samantha Atkins: "Re: how to change values"</A>
<LI><STRONG>Previous message:</STRONG> <A HREF="4929.html">Samantha Atkins: "Re: POLI: US Pres. was Re: GUNS: Why here?"</A>
<LI><STRONG>In reply to:</STRONG> <A HREF="4870.html">Emlyn O'Regan: "Re: Homeless"</A>
<!-- nextthread="start" -->
<LI><STRONG>Next in thread:</STRONG> <A HREF="4959.html">Emlyn O'Regan: "Jobs, Lots of stuff about Software world (was re: Homeless)"</A>
<LI><STRONG>Reply:</STRONG> <A HREF="4959.html">Emlyn O'Regan: "Jobs, Lots of stuff about Software world (was re: Homeless)"</A>
<LI><STRONG>Reply:</STRONG> <A HREF="5131.html">Eugene Leitl: "Re: Homeless, (+ Jobs, Lots of stuff about Software world)"</A>
<!-- reply="end" -->
<LI><STRONG>Messages sorted by:</STRONG> 
<A HREF="date.html#4930">[ date ]</A>
<A HREF="index.html#4930">[ thread ]</A>
<A HREF="subject.html#4930">[ subject ]</A>
<A HREF="author.html#4930">[ author ]</A>
</UL>
<HR NOSHADE><P>
<!-- body="start" -->
<P>
Emlyn O'Regan wrote:
<BR>
<EM>&gt; 
</EM><BR>
<EM>&gt; Right on, I support this position 100%. The fruit or side effect of
</EM><BR>
<EM>&gt; increased automation, depending on your point of view, is increased
</EM><BR>
<EM>&gt; redundancy for people. This isn't always true; as some jobs go away because
</EM><BR>
<EM>&gt; of automation, more jobs are created at the &quot;next level up&quot;, doing the next
</EM><BR>
<EM>&gt; thing that the machines can't do yet, and that we never tried before because
</EM><BR>
<EM>&gt; they were too hard without the current level of automation as support. But
</EM><BR>
<EM>&gt; to a large extent, automation has a goal of reducing manual work, and often
</EM><BR>
<EM>&gt; succeeds.
</EM><BR>
<P>I doubt the &quot;we create more jobs one level up&quot; idea or that it
<BR>
ameliorates the problem much.  I doubt we created more programmer jobs
<BR>
than the total number of factory workers, secretaries, typists, human
<BR>
number twiddlers and so on displaced by automation.  Even if we did
<BR>
these next level jobs are reguiring progressive higher skills and higher
<BR>
intelligence.  Looking at the bell-shaped curve for human IQ leads me to
<BR>
the conclusion that a lot of people are not going to qualify for these
<BR>
next-level jobs.  What should happen to them?
<BR>
<P><P><P><EM>&gt; 
</EM><BR>
<EM>&gt; Currently I think that more opportunities are being created as previous
</EM><BR>
<EM>&gt; opportunities dissapear. I don't think we are seeing ever rising
</EM><BR>
<EM>&gt; unemployment statistics in the west; it seems that the opposite is currently
</EM><BR>
<EM>&gt; true. That would be what people call an economy, I guess.
</EM><BR>
<EM>&gt; 
</EM><BR>
<P>You are seeing them in Europe more than in the US.  In the US people on
<BR>
welfare, and the chronically unemployed and a few other categories are
<BR>
not counted.  So the statistics are a bit misleading.  Also, I wonder
<BR>
how many jobs in the US are there simply to keep people employed and
<BR>
really are pretty pointless today.  From what I've seen as a consultant
<BR>
in large corporations, the number of such is not small.  
<BR>
<P><EM>&gt; However, as the machines get smarter (not really happening yet), the jobs
</EM><BR>
<EM>&gt; left for people will trend more and more toward mentally difficult stuff;
</EM><BR>
<EM>&gt; stuff that the machines aren't smart enough to do, and which many people are
</EM><BR>
<EM>&gt; also ill equipped to handle. This is the track toward AI; Drexler talks
</EM><BR>
<EM>&gt; about intelligent engineering systems, if I remember that book 'o' his
</EM><BR>
<EM>&gt; correctly. I think people (or at least most people) will start to become
</EM><BR>
<EM>&gt; entirely unable to fill any useful job at some point.
</EM><BR>
<EM>&gt; 
</EM><BR>
<EM>&gt; If this happened in our current economic climate, I wouldn't think much for
</EM><BR>
<EM>&gt; the chances of these redundant masses. I've read some stuff I didn't really
</EM><BR>
<EM>&gt; understand about &quot;democratisation of capital&quot;, maybe someone can explain
</EM><BR>
<EM>&gt; this? Maybe the &quot;new economy&quot; has built in mechanisms which will kick in to
</EM><BR>
<EM>&gt; balance out ensuing social problems from mega-redundancy? I'd be grateful if
</EM><BR>
<EM>&gt; someone informed would comment on this.
</EM><BR>
<EM>&gt;
</EM><BR>
<P>We are in agreement on the problem.  I am not sure what to do about it. 
<BR>
We are at an interesting place.  There is not quite enough wealth to
<BR>
both give everyone a good guaranteed income and let them decide what if
<BR>
anything to do with their time including working for more money if they
<BR>
have the skills needed.  we're arguably not quite there yet.  But
<BR>
closer.  And a pretty good argument can be made that without
<BR>
concentrations of wealth in private hands their is no energy/resources
<BR>
to enable many types of innovation.  Of course there are also
<BR>
innovations dying in 9-5 jobs taken just to pay the rent that don't
<BR>
leave much room or energy for the passions and true interests of many
<BR>
workers.
<BR>
&nbsp;&nbsp;&nbsp;
<BR>
<EM>&gt; Otherwise, we need something new in the way of economic systems. When
</EM><BR>
<EM>&gt; nano-santa comes, if we are set up exactly as we are now, it's going to be a
</EM><BR>
<EM>&gt; bad christmas for a lot of people.
</EM><BR>
<EM>&gt;
</EM><BR>
<P>It will be worse than bad if most of the energy goes into endless
<BR>
competition for more material wealth when material wealth is no longer
<BR>
that difficult or central.  It will also likely be bad if
<BR>
people/groups/nations are bent on destroying or  exploiting one another
<BR>
with those kinds of abilities in their kit.  
<BR>
&nbsp;
<BR>
<EM>&gt; &gt;
</EM><BR>
<EM>&gt; &gt; I worry about another problem.  Technology is still marching forward.  I
</EM><BR>
<EM>&gt; &gt; support this 101% of course.  But, as it advances it automates more and
</EM><BR>
<EM>&gt; &gt; more job levels.  I predict that within 5-10 years it will automate most
</EM><BR>
<EM>&gt; &gt; of what is called programming today.  This is only one example.  As we
</EM><BR>
<EM>&gt; &gt; get more powerful computers at lower cost with more AIish abilities more
</EM><BR>
<EM>&gt; &gt; and more jobs will fall to them.  We had best be thinking really hard
</EM><BR>
<EM>&gt; &gt; right now about how we plan to have people have a decent life without a
</EM><BR>
<EM>&gt; &gt; regular for pay job.  Despite the current rather slanted rosy
</EM><BR>
<EM>&gt; &gt; unemployment statistics in the US, the problem is real and it will
</EM><BR>
<EM>&gt; &gt; eventually hit even many of us.
</EM><BR>
<EM>&gt; 
</EM><BR>
<EM>&gt; Hee hee, the old &quot;programmers will be redundant in 5-10 years&quot; line. Haven't
</EM><BR>
<EM>&gt; heard that for a while; supposedly it's been kicking around since at least
</EM><BR>
<EM>&gt; the 70s. It's no truer today than it has ever been.
</EM><BR>
<EM>&gt;
</EM><BR>
<P>Don't bet on it.  What changes between then and now is the raw power of
<BR>
the hardware.  As it becomes more powerful it becomes more tractable to
<BR>
automate large segments of the work programmers currently do.  Of
<BR>
course, the demand for programming is so huge that it will take a while
<BR>
before the automation cuts into the need for programmers too much.  But
<BR>
the level of programmer needed will continue to rise also, stranding
<BR>
many who are now in that profession.  Don't believe me?  Wait and see.
<BR>
<P>&nbsp;
<BR>
<EM>&gt; It is true that we continue to automate things which used to be done
</EM><BR>
<EM>&gt; manually. So why aren't all the coders on the dole queue? It's because, as
</EM><BR>
<EM>&gt; something is automated, it becomes qualitatively different (easier) to build
</EM><BR>
<EM>&gt; systems based on that something. In terms of possible systems, entirely new
</EM><BR>
<EM>&gt; vistas open up, which although reliant on the newly automated something, are
</EM><BR>
<EM>&gt; not themselves automated, and require lots of people to build them.
</EM><BR>
<EM>&gt;
</EM><BR>
<P>Actually, having been in the software world myself for 20 years, I
<BR>
suspect the truth is a bit dimmer than that.  Many of the tools I use
<BR>
haven't evolved hardly at all in all of that time.  C lead to C++ but
<BR>
the tools used to graft C++ have not exactly gone through any major
<BR>
revolution.  C++ itself is quite primitive in many ways.  Java? 
<BR>
Interesting things have been done to exploit some of its features but
<BR>
the language itself is not that powerful and not sufficient for many
<BR>
types of problems.  Any interpreted or semi-interpreted language with
<BR>
equal or more reflection could be used in most of the contexts that Java
<BR>
is used.  Some of these languages, such as Lisp and Smalltalk, are or
<BR>
have been much more powerful and advanced in capability, usage, or
<BR>
development environment than Java, C++, VB and so on are today.  Most of
<BR>
the central abilities in languages were first invented and explored in
<BR>
Lisp. 
<BR>
<P>We are beginning to address problems of programming in the large but
<BR>
frankly many of the solutions are giant kludges that are severely
<BR>
over-hyped and over-sold.  I have gotten quite disgruntled with this
<BR>
industry.  We spend more time trying to lock up &quot;intellectual property&quot;
<BR>
and out-hype the competition than we do actually designing and building
<BR>
good systems.  And fixing our development tools themselves takes a
<BR>
backseat to even that.  I designed and built things in the 80s ( and I
<BR>
am not unique in this at all) that are as or more advanced than some
<BR>
parts of the current highly-hyped baseline.  
<BR>
<P>Sorry.  Most of that is an aside and off-topic.  I needed to rant. But
<BR>
personally I don't think software development will get significantly
<BR>
better until something like Open Source (better add Open Design) and
<BR>
changes in the basis of software business occur.  I don't see how the
<BR>
current model has room to get out of its own way.  
<BR>
<P><EM>&gt; Once upon a time, to write software, you had to write your own OS. Then OSes
</EM><BR>
<EM>&gt; started to appear, and provided basic functionality (loading a program into
</EM><BR>
<EM>&gt; memory, talking to disks, basic screen handling, and all kinds of other
</EM><BR>
<EM>&gt; stuff). Later, programmers spent a lot of time writing (console based) user
</EM><BR>
<EM>&gt; interface code, reading and writing from primitive disk files, all those
</EM><BR>
<EM>&gt; good things. Then databases started to become common, and GUIs became
</EM><BR>
<EM>&gt; common, and other things became the programmer's task. Now people wanted
</EM><BR>
<EM>&gt; nicer printouts, programs that interoperated, pretty gui front ends, and,
</EM><BR>
<EM>&gt; urm, networking! Programmers wrote lots and lots of code by hand, performing
</EM><BR>
<EM>&gt; those tasks; evetually it was again subsumed into the OS. At some point
</EM><BR>
<EM>&gt; Microsoft invented VB, and programmers were redundant forever shortly
</EM><BR>
<EM>&gt; thereafter.
</EM><BR>
<EM>&gt;
</EM><BR>
<P>GAG!  VB is one of the worst blights exemplifying the very problems in
<BR>
the industry I spoke of above.  The very idea of inflicting on millions
<BR>
of programmers a language environment that has a badly scaled Basic at
<BR>
its core pretending to be object oriented (laugh) and which is not even
<BR>
powerful enough to handle full COM components and on top of this has the
<BR>
IDE, your program and the debugger in one process so any problems crash
<BR>
the entire mess - well, the whole thing is simply and utterly
<BR>
infuriating.  I can and have designed better programming environments in
<BR>
my sleep.  Microsoft should be shot for gross ineptitude and programmer
<BR>
abuse.  Of course they were never really about making the world better
<BR>
for software development  They are only in it to capture the market and
<BR>
eliminate the competition.  Or at least any good tendencies in its
<BR>
people are subsumed by that bottom line over and over again.
<BR>
<P>Putting various things in the OS is not a very bright idea.  The things
<BR>
in the OS should be the minimum that can be handled more efficiently and
<BR>
cleanly there.  A web browser is not an example of such.  
<BR>
&nbsp;
<BR>
<EM>&gt; Or that's the hype... oddly enough, there is such a thing as a VB
</EM><BR>
<EM>&gt; programmer, with possibly more positions available than any other
</EM><BR>
<EM>&gt; language/environment. Because the things it makes easy to do are easy to do,
</EM><BR>
<EM>&gt; sure. But now people can imagine even more complex systems, which they would
</EM><BR>
<EM>&gt; not have attempted before, which they can now just accomplish by writing
</EM><BR>
<EM>&gt; lots and lots of code. If they do these things in VB, it's often even
</EM><BR>
<EM>&gt; harder.
</EM><BR>
<EM>&gt;
</EM><BR>
<P>VB will not allow you to do most of these things.  Back when I (shameful
<BR>
to admit) hacked some VB I had to write anything interesting in C++/DCOM
<BR>
and then do the GUI in VB and have it call the C++ COM objects.   It
<BR>
works, but is totally proprietary to Microsloth.
<BR>
&nbsp;
<BR>
<EM>&gt; This continues. As far as I can see, the tools have improved incredibly
</EM><BR>
<EM>&gt; beyond what I was using 10 years ago when I started uni. So much more is
</EM><BR>
<EM>&gt; possible; it's astounding. And yet, paradoxically, it is harder than ever to
</EM><BR>
<EM>&gt; be a programmer. The job is getting more and more difficult. Why?
</EM><BR>
<EM>&gt;
</EM><BR>
<P>You must be in a very different world or you don't see beneath the
<BR>
wizards and the push-button IDE.  The underlying stuff has largely not
<BR>
improved at all except for the addition of binary components using CORBA
<BR>
and COM.  Even those two are not a great improvement over a
<BR>
distributed/persistent peer-peer object application environment I
<BR>
created in 1986-1987.  It was unfortunately ahead of its time and
<BR>
created under the auspices of a company that had no idea what to do with
<BR>
it.  
<BR>
<P><P>Our present underlying compiler and linker technology is not much better
<BR>
than it was then.  Linkers have changed almost not at all.  DLLs?  Came
<BR>
out in the mid 80s.  The productivity tools for programmers leave a lot
<BR>
to be desired.  In the Microsloth world to browse the call graphs of
<BR>
functions and objects the software entity must first be fully compiled
<BR>
with a bunch of special purpose flags set.  From one component you can't
<BR>
browse into such details of another one.  The information is not unified
<BR>
into some database you can query about various software artifacts and
<BR>
their interaction and inter-dependencies.  What data that is gathered is
<BR>
in a Microsoft proprietary format that you cannot use to develop
<BR>
something more intelligent.  Yet Lisp and Smalltalk environment have had
<BR>
such abilities for the last decade or even two.  I wrote such an
<BR>
information extractor myself for some &lt;gasp&gt; Cobol legacy stuff I got
<BR>
stuck with once in 1984.  
<BR>
<P>The reason it is getting more difficult is the systems needed are more
<BR>
sophisticated and the tools and infrastructure have not kept up with
<BR>
them.  It is difficult to pour energy into better programming tools when
<BR>
that kind of product doesn't pay off so well at the bank to make the VC
<BR>
happy.  It is difficult to build them in house without the sponsoring
<BR>
management looking like they don't have an eye on the bottom line.  So
<BR>
we race faster and faster armed with inadequate tools and every more
<BR>
pressing requirements, busily trying to automate everyone else's work
<BR>
except our own.
<BR>
<P>How does this tie-in to  extropian interests?  The future and the tech
<BR>
we all so crave is built largely on top of software.  Keep most software
<BR>
proprietary and don't invest in better software tools and the future
<BR>
will be much more stunted than it could/should be.
<BR>
<P><EM>&gt; Well, because people want to interoperate. Heterogeneous networks,
</EM><BR>
<EM>&gt; applications, software layers, layer upon layer like a crazy croissant,
</EM><BR>
<EM>&gt; building new, more ambitious, more interesting systems than ever before. The
</EM><BR>
<EM>&gt; new economy, with the 'net as the centerpiece, is a mish mash of components
</EM><BR>
<EM>&gt; and chunks and layers and stuff, all trying to talk to each other, all
</EM><BR>
<EM>&gt; idiosyncratic, brittle, cranky code stretched out like a net weaved of scrap
</EM><BR>
<EM>&gt; metal. Making this stuff hang together is a mad job, done at a frenetic
</EM><BR>
<EM>&gt; speed as old technologies die and new technologies are born. There's no
</EM><BR>
<EM>&gt; comfort zone. There's no pause for breath. There's certainly no sign of AI
</EM><BR>
<EM>&gt; taking over any time soon!
</EM><BR>
<EM>&gt; 
</EM><BR>
<P>It is more cranky and brittle than it needs to be in part because of the
<BR>
problems I mentioned.  There are also some real bearish problems in some
<BR>
of our currently dreamed up systems.  Things that will take real R&amp;D
<BR>
projects to solve and then under the current model would come out as a
<BR>
bunch of hacked up tools positioned to maximize profit instead of being
<BR>
shared across the entire industry that needs them so desparately.  
<BR>
<P><EM>&gt; People have been worried about the contrary point of view; that our systems
</EM><BR>
<EM>&gt; are getting so big, so unwieldy, that at some point we cross a failure
</EM><BR>
<EM>&gt; threshold, beyond which we cannot, as a bunch of humans, reliably maintain
</EM><BR>
<EM>&gt; the systems any more. Why would this be true?
</EM><BR>
<EM>&gt; 
</EM><BR>
<P>Without the proper tools and without more and better automation it is
<BR>
inevitable.  
<BR>
<P><EM>&gt; Well, much of the problem is that, even though basic OS features are
</EM><BR>
<EM>&gt; &quot;automated&quot;, even though the user interface (gui), persistent storage
</EM><BR>
<EM>&gt; (databases), communications (networks) are &quot;automated&quot;, they actually
</EM><BR>
<EM>&gt; aren't. These things work well now, but they are never quite perfect (some
</EM><BR>
<EM>&gt; people would say they are not even close!). Just ask UI programmers,
</EM><BR>
<EM>&gt; database programmers, OS coders, network engineers. All the hordes of
</EM><BR>
<EM>&gt; people, working to make/maintain the  &quot;automated&quot; systems, the stuff that is
</EM><BR>
<EM>&gt; already &quot;done&quot;.
</EM><BR>
<EM>&gt;
</EM><BR>
<P>My greatest expertise is in object persistence.  Persistence is far, far
<BR>
from &quot;automated&quot;.  Persistence cross-cuts applications and products but
<BR>
is often done as a series of hacks within a particular project
<BR>
life-cycle.  Or a product is bought that promises to take the worries
<BR>
all away but actually seriously perverts all application building
<BR>
thereafter because its needs have to be met for the application to work
<BR>
at all and its needs are to perturbing to everything else.  And the
<BR>
solution ties the product and the organization often to the solution
<BR>
provider firmly.  At the moment there is not a good persistent
<BR>
middleware out there that fully meets what is needed.  There are various
<BR>
attempts of greater/lesser goodness.  I plan to do large parts of that
<BR>
problem better and to eventually release a series of Open Source
<BR>
persistent middleware tools.  I am tired of seeing ugly solutions to
<BR>
this set of problems I know well. 
<BR>
<P>We have automated certain classes of GUIs but the GUI story is far from
<BR>
complete or adequate.  Many projects are now being seriously perverted
<BR>
to use only a Web Browser as their GUI!  It is as if we are stepping
<BR>
firmly into the past and putting more and more energy into centralized
<BR>
servers even though we have more power on our desktops than we dared
<BR>
dream of in the very recent past.  We need good massively distributed
<BR>
peer-peer systems.  Not a sleazy 21st century rework of time-sharing
<BR>
systems.
<BR>
&nbsp;
<BR>
<EM>&gt; Something really different will have to happen to change this picture. Super
</EM><BR>
<EM>&gt; intelligent AI could do it (so could the wish fairies). Genetic programming
</EM><BR>
<EM>&gt; advances might have a shot, but will still require humans to coordinate them
</EM><BR>
<EM>&gt; at some level, especially given that our ambitions will increase by orders
</EM><BR>
<EM>&gt; of magnitude as our abilities increase, to keep us focused on what is just
</EM><BR>
<EM>&gt; out of reach. The job of configuring such magical genetic programmed
</EM><BR>
<EM>&gt; automated systems to reach these new goals will look a lot like, well,
</EM><BR>
<EM>&gt; programming.
</EM><BR>
<EM>&gt; 
</EM><BR>
<P>Sure.  Although of a quite different sort.  What disturbs me is how
<BR>
often I am still doing the same tired old tasks in much the same tired
<BR>
way.  There is not often enough time to both meet the current
<BR>
over-inflated deadline for an underdesigned product and automate as much
<BR>
of my own process as would satisfy me. 
<BR>
<P><P><EM>&gt; Sure the techniques will change. Sure the skill set required will change.
</EM><BR>
<EM>&gt; But the basic programming job will remain, and grow wider in my opinion.
</EM><BR>
<EM>&gt; Lots of things will begin to look like programming in the future, which do
</EM><BR>
<EM>&gt; not now. Biotech might get to a point of &quot;automation&quot; where it starts using
</EM><BR>
<EM>&gt; programmers. Through nanotech, even the bricks &amp; mortar world will start to
</EM><BR>
<EM>&gt; become a programming concern.
</EM><BR>
<EM>&gt;
</EM><BR>
<P>We don't yet do enough with well-defined and trusted components and with
<BR>
good tools for finding the right components and simulating their
<BR>
interaction.  Much of our code base is still language and OS dependent
<BR>
and not componentized at all.  Most of code is still application
<BR>
stovepipes with little/no reuse or reuseability.  In short, almost no
<BR>
automation or next-level engineering applied to our own work.  It had
<BR>
better not continue like this.
<BR>
&nbsp;
<BR>
- samantha
<BR>
<P><!-- body="end" -->
<HR NOSHADE>
<UL>
<!-- next="start" -->
<LI><STRONG>Next message:</STRONG> <A HREF="4931.html">Samantha Atkins: "Re: how to change values"</A>
<LI><STRONG>Previous message:</STRONG> <A HREF="4929.html">Samantha Atkins: "Re: POLI: US Pres. was Re: GUNS: Why here?"</A>
<LI><STRONG>In reply to:</STRONG> <A HREF="4870.html">Emlyn O'Regan: "Re: Homeless"</A>
<!-- nextthread="start" -->
<LI><STRONG>Next in thread:</STRONG> <A HREF="4959.html">Emlyn O'Regan: "Jobs, Lots of stuff about Software world (was re: Homeless)"</A>
<LI><STRONG>Reply:</STRONG> <A HREF="4959.html">Emlyn O'Regan: "Jobs, Lots of stuff about Software world (was re: Homeless)"</A>
<LI><STRONG>Reply:</STRONG> <A HREF="5131.html">Eugene Leitl: "Re: Homeless, (+ Jobs, Lots of stuff about Software world)"</A>
<!-- reply="end" -->
<LI><STRONG>Messages sorted by:</STRONG> 
<A HREF="date.html#4930">[ date ]</A>
<A HREF="index.html#4930">[ thread ]</A>
<A HREF="subject.html#4930">[ subject ]</A>
<A HREF="author.html#4930">[ author ]</A>
</UL>
<!-- trailer="footer" -->
<HR NOSHADE>
<P>
<SMALL>
<EM>
This archive was generated by <A HREF="http://www.hypermail.org/">hypermail 2b29</A> 
: <EM>Mon Oct 02 2000 - 17:37:56 MDT</EM>
</EM>
</SMALL>
</BODY>
</HTML>
