<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
                      "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>
<HEAD>
<TITLE>extropians: Re: Mostly stuff about software (was Homeless + Job</TITLE>
<META NAME="Author" CONTENT="Samantha Atkins (samantha@objectent.com)">
<META NAME="Subject" CONTENT="Re: Mostly stuff about software (was Homeless + Jobs, Lots of stuff  about Software world)">
</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<H1>Re: Mostly stuff about software (was Homeless + Jobs, Lots of stuff  about Software world)</H1>
<!-- received="Sun Sep 24 18:35:59 2000" -->
<!-- isoreceived="20000925003559" -->
<!-- sent="Sun, 24 Sep 2000 17:37:52 -0700" -->
<!-- isosent="20000925003752" -->
<!-- name="Samantha Atkins" -->
<!-- email="samantha@objectent.com" -->
<!-- subject="Re: Mostly stuff about software (was Homeless + Jobs, Lots of stuff  about Software world)" -->
<!-- id="39CE9E60.B3517795@objectent.com" -->
<!-- inreplyto="00092408471800.00819@tachyon" -->
<STRONG>From:</STRONG> Samantha Atkins (<A HREF="mailto:samantha@objectent.com?Subject=Re:%20Mostly%20stuff%20about%20software%20(was%20Homeless%20%2B%20Jobs,%20Lots%20of%20stuff%20%20about%20Software%20world)&In-Reply-To=&lt;39CE9E60.B3517795@objectent.com&gt;"><EM>samantha@objectent.com</EM></A>)<BR>
<STRONG>Date:</STRONG> Sun Sep 24 2000 - 18:37:52 MDT
<P>
<!-- next="start" -->
<UL>
<LI><STRONG>Next message:</STRONG> <A HREF="5615.html">Samantha Atkins: "Re: Why would AI want to be friendly?"</A>
<LI><STRONG>Previous message:</STRONG> <A HREF="5613.html">Franklin Wayne Poley: "Re: Why would AI want to be friendly?"</A>
<LI><STRONG>In reply to:</STRONG> <A HREF="5610.html">James Rogers: "Mostly stuff about software (was Homeless + Jobs, Lots of stuff about Software world)"</A>
<!-- nextthread="start" -->
<LI><STRONG>Next in thread:</STRONG> <A HREF="5626.html">J. R. Molloy: "Re: Mostly stuff about software (was Homeless + Jobs, Lots of stuff  about Software world)"</A>
<LI><STRONG>Reply:</STRONG> <A HREF="5626.html">J. R. Molloy: "Re: Mostly stuff about software (was Homeless + Jobs, Lots of stuff  about Software world)"</A>
<LI><STRONG>Reply:</STRONG> <A HREF="5707.html">James Rogers: "Re: Mostly stuff about software (was Homeless + Jobs, Lots of stuff about Software world)"</A>
<!-- reply="end" -->
<LI><STRONG>Messages sorted by:</STRONG> 
<A HREF="date.html#5614">[ date ]</A>
<A HREF="index.html#5614">[ thread ]</A>
<A HREF="subject.html#5614">[ subject ]</A>
<A HREF="author.html#5614">[ author ]</A>
</UL>
<HR NOSHADE><P>
<!-- body="start" -->
<P>
James Rogers wrote:
<BR>
<EM>&gt; 
</EM><BR>
<EM>&gt; This is my biggest objection to oppressive taxation; it damages my ability
</EM><BR>
<EM>&gt; to invest time and money in necessary technological R&amp;D.  Of course,
</EM><BR>
<EM>&gt; the government that doesn't trust me with my money (ahem, Gore,
</EM><BR>
<EM>&gt; Nader, et al.), is the same government that I would hopefully obsolete
</EM><BR>
<EM>&gt; through the development of fundamentally important new technology.
</EM><BR>
<EM>&gt;
</EM><BR>
<P>I would be very curious how you would obsolete the attitudes and beliefs
<BR>
that that big government grows out of with only technology.  Maybe
<BR>
something that raises the general IQ across the board?
<BR>
&nbsp;
<BR>
<EM>&gt; &gt; A nominal 9-5 (or part time) job will pay for the rent, and leave time
</EM><BR>
<EM>&gt; &gt; for the hobbies. If I can't do truly interesting things in my job, I
</EM><BR>
<EM>&gt; &gt; could as well let the nominal day job pay for my rent, and do
</EM><BR>
<EM>&gt; &gt; interesting things in my spare time.
</EM><BR>
<EM>&gt; 
</EM><BR>
<EM>&gt; It depends on what your hobbies are, as some can be rather expensive.
</EM><BR>
<EM>&gt; Or maybe I just try to do too many things at once...
</EM><BR>
<EM>&gt;
</EM><BR>
<P>Also, I get too much of my things I love to do involved in my 9-5 and
<BR>
vice-versa.  I am not worth a salary high enough to support myself, my
<BR>
dependents and my hobbies if some of what I really love is not part of
<BR>
my 9-5.  Although much too much time/energy is wasted fighting the
<BR>
warpage of the things I really care about by most business
<BR>
environments.  Not many high-end software jobs today can be easily
<BR>
restricted to 9-5.
<BR>
<P>&nbsp;
<BR>
<EM>&gt; &gt;  &gt; Don't bet on it.  What changes between then and now is the raw power of
</EM><BR>
<EM>&gt; &gt;  &gt; the hardware.  As it becomes more powerful it becomes more tractable to
</EM><BR>
<EM>&gt; &gt;  &gt; automate large segments of the work programmers currently do.  Of
</EM><BR>
<EM>&gt; &gt;
</EM><BR>
<EM>&gt; &gt; Sure, now it's easier to make a GUI, by just painting it on the
</EM><BR>
<EM>&gt; &gt; screen. Program generators are not exactly new. Apart from wizards
</EM><BR>
<EM>&gt; &gt; like our very own James Rogers (and sci things like ATLAS,
</EM><BR>
<EM>&gt; &gt; automatically juggling source to optimize for a given architecture) we
</EM><BR>
<EM>&gt; &gt; don't see automatic programming hitting the streets any time soon. And
</EM><BR>
<EM>&gt; &gt; then people would still have to write specs in a formal language. Even
</EM><BR>
<EM>&gt; &gt; if you don't write a protocol stack explicitly, you still have to
</EM><BR>
<EM>&gt; &gt; codify it's behaviour.
</EM><BR>
<EM>&gt;
</EM><BR>
<P>Of course we are still in the early days of hardware improvement and of
<BR>
human/machine interaction.  I believe the day will come when you don't
<BR>
explain a complex design requirement to the machine at any deeper level
<BR>
than you would to a skilled human.  Getting there will require a lot of
<BR>
work across multiple disciplines.  
<BR>
&nbsp;
<BR>
<EM>&gt; I should mention that I am able to do what I did be cause the domain
</EM><BR>
<EM>&gt; is severely constrained. While I am working on the generalized
</EM><BR>
<EM>&gt; problem, it is useful to both validate design components in a
</EM><BR>
<EM>&gt; real-world environment and fund general development by selling limited
</EM><BR>
<EM>&gt; implementations of the general technology to solve hard problems that can
</EM><BR>
<EM>&gt; be effectively attacked with limited but relatively &quot;smart&quot; software. It is
</EM><BR>
<EM>&gt; also a rich space for coming across interesting problems that need to be
</EM><BR>
<EM>&gt; solved, which keeps me happy. :^)
</EM><BR>
<EM>&gt; 
</EM><BR>
<EM>&gt; For the application I mentioned previously, I don't need a formal spec
</EM><BR>
<EM>&gt; per se. Rather, I have a big goal (maximize profits) that doesn't
</EM><BR>
<EM>&gt; change, and a small set of sub goals created by suits that are subject
</EM><BR>
<EM>&gt; to occasional change.  The dataspace is large (typically around 25Gb),
</EM><BR>
<EM>&gt; quite complex, and subject to some rather sudden and dynamic changes
</EM><BR>
<EM>&gt; both in content and nature. Given basic code on how to navigate the
</EM><BR>
<EM>&gt; dataspace, I let the system figure out the best way to achieve the
</EM><BR>
<EM>&gt; stated goals and to take advantage of emerging patterns. In short, I
</EM><BR>
<EM>&gt; have limited the code generation to working with the business problem
</EM><BR>
<EM>&gt; dataspace rather than to the framework itself; it puts the flesh on
</EM><BR>
<EM>&gt; the skeleton. A set of algorithms that observe the system's runtime
</EM><BR>
<EM>&gt; behavior determine when code gets re-written. One could easily write a
</EM><BR>
<EM>&gt; book on this topic (though I certainly won't).  It really only deviates
</EM><BR>
<EM>&gt; significantly from the general problem of intelligent code generation in
</EM><BR>
<EM>&gt; one aspect, but the difference is an important one.
</EM><BR>
<EM>&gt; 
</EM><BR>
<EM>&gt; The biggest problem with runtime code generators is debugging the
</EM><BR>
<EM>&gt; resulting mess. However, it has allowed me to work on the some
</EM><BR>
<EM>&gt; of the many interesting problems of self-observation. Designing methods to
</EM><BR>
<EM>&gt; resolve issues such as detecting complex and non-procedural
</EM><BR>
<EM>&gt; infinite loops (e.g. infinite loops caused by how the data interacts with
</EM><BR>
<EM>&gt; the code at runtime, without compile-time knowledge of what the data can
</EM><BR>
<EM>&gt; look like) has been fun.
</EM><BR>
<EM>&gt;
</EM><BR>
<P>If the code-generator is well-designed / tested and builds in run-time
<BR>
checks there is not quite so onerous a problem with debugging is there? 
<BR>
Some of the things you mention sound like good fun indeed.
<BR>
&nbsp;
<BR>
<EM>&gt; &gt; Jeez. If you think C++ is an improvement upon C you really have a
</EM><BR>
<EM>&gt; &gt; strange mind.
</EM><BR>
<EM>&gt; 
</EM><BR>
<EM>&gt; To my mind, useable C++ looks a lot like well-organized C. The only
</EM><BR>
<EM>&gt; real improvement of C++ is that it formalized a syntax for things that
</EM><BR>
<EM>&gt; good C programmers had been doing for a long time.  For that reason,
</EM><BR>
<EM>&gt; very few applications actually justify using C++ over C, if your C
</EM><BR>
<EM>&gt; programmers are competent enough.  And if they aren't competent with
</EM><BR>
<EM>&gt; C, you certainly don't want them working in C++. :^)
</EM><BR>
<EM>&gt;
</EM><BR>
<P>Good C programmers do not generally encapsulate data structure and the
<BR>
functions for manipulating those data structures well or at least not in
<BR>
a way that enforces that encapsulation except by convention.  Good C
<BR>
programmers do not generally think through polymorphism/genericity.  And
<BR>
good C and C++ programmers generally believe a lot of mystical claptrap
<BR>
about their ability to manage memory without a formal GC.  And no, using
<BR>
reference counting and &quot;discipline&quot; is NOT an acceptable solution.
<BR>
&nbsp;
<BR>
<EM>&gt; &gt; I do not see anything new cropping up since
</EM><BR>
<EM>&gt; &gt; Lisp. Because I can't have Lisp machine in current technology (and am
</EM><BR>
<EM>&gt; &gt; too dumb/poor to afford a DSP cluster running Forth), I've settled on
</EM><BR>
<EM>&gt; &gt; Python/C in a OpenSource *nix environment (currently Linux).
</EM><BR>
<EM>&gt; 
</EM><BR>
<EM>&gt; C/Python/Java on Unix is my environment of choice, both because I am
</EM><BR>
<EM>&gt; extremely comfortable with them (C on Unix is like comfortable old
</EM><BR>
<EM>&gt; shoes), and because I can use one of them well in every design space I
</EM><BR>
<EM>&gt; am likely to come across.
</EM><BR>
<EM>&gt;
</EM><BR>
<P>I pick Python/C++ (for delimited tight things)/Java (mostly because of
<BR>
size of Java savvy population and prejudice although it has a few
<BR>
worthwhile features)/Lisp/Scheme/Smalltalk.  All else being equal I will
<BR>
reach for Python or Lisp first when attempting to model a problem with
<BR>
Smalltalk running a close second.  If I am coding some tight data
<BR>
structure I will go to C/C++ as a sort of universal assembler. 
<BR>
&nbsp;
<BR>
<EM>&gt; I have noticed that a lot of good programmers with broad platform
</EM><BR>
<EM>&gt; experience tend to settle on the same tools with time.  Despite coming
</EM><BR>
<EM>&gt; from wildly different backgrounds, most of the programmers I know who
</EM><BR>
<EM>&gt; have been working with computers for a long time seem to have very
</EM><BR>
<EM>&gt; similar notions of what &quot;optimal environments&quot; actually are.
</EM><BR>
<EM>&gt; Coincidence?  I doubt it.
</EM><BR>
<P><P>Most of the really good long-time programmers I know tend to bemoan that
<BR>
lisp and smalltalk aren't used more often and haven't penetrated the
<BR>
market more. :-)
<BR>
<P><P><EM>&gt; 
</EM><BR>
<EM>&gt; &gt;  &gt; We are beginning to address problems of programming in the large but
</EM><BR>
<EM>&gt; &gt;  &gt; frankly many of the solutions are giant kludges that are severely
</EM><BR>
<EM>&gt; &gt;  &gt; over-hyped and over-sold.  I have gotten quite disgruntled with this
</EM><BR>
<EM>&gt; &gt;  &gt; industry.  We spend more time trying to lock up &quot;intellectual property&quot;
</EM><BR>
<EM>&gt; &gt;
</EM><BR>
<EM>&gt; &gt; Amen, verily, etc. etc.
</EM><BR>
<EM>&gt; 
</EM><BR>
<EM>&gt; There is a lot of pressure (business and lawyerly) to turn
</EM><BR>
<EM>&gt; everything into an intellectual property action. There are a lot of
</EM><BR>
<EM>&gt; benefits, both material and immaterial, to doing so, *particularly*
</EM><BR>
<EM>&gt; if your organization is poorly funded.
</EM><BR>
<EM>&gt;
</EM><BR>
<P><P>How is that?  If you lock your software to &quot;your organization&quot; then that
<BR>
software's survival and useability is limited to the context of &quot;your
<BR>
organization&quot;.  But most organization can fire you for any reason
<BR>
whatsoever at amy time so the &quot;your&quot; is rather pointless.  And most
<BR>
organizations have many conflicting pressures that determine whether and
<BR>
to what extent a piece of local developed software will reach its
<BR>
technological maturity or see the light of day at all.  Those of us who
<BR>
work at the system level (or at a more generic/abstract level) commonly
<BR>
are working on things that crosscut any particular organization and its
<BR>
politics and are enabling of but orthogonal to the organization's line
<BR>
of business (unless it is a specialized software house).  Thus it is
<BR>
even more unpalatable and grossly inefficient for our work to be deemed
<BR>
the exclusive property of the organization.   
<BR>
<P><EM>&gt; I actually started the patent process for a few different thing
</EM><BR>
<EM>&gt; (largely software technologies of the type mentioned above), but
</EM><BR>
<EM>&gt; dropped it after deciding that I would probably have an easier time
</EM><BR>
<EM>&gt; keeping the technology out from under the thumb of big business by
</EM><BR>
<EM>&gt; *not* patenting the tech.  That and I object personally to the
</EM><BR>
<EM>&gt; software patent concept.  Makes it a little harder to get funding
</EM><BR>
<EM>&gt; though.
</EM><BR>
<EM>&gt; 
</EM><BR>
<P>Agreed and YAY!  Funding is an issue. 
<BR>
<P><EM>&gt; Of course, Yudkowskian technologies have an *enormous* first-to-market
</EM><BR>
<EM>&gt; advantage that is hard to ignore. :^)
</EM><BR>
<EM>&gt; 
</EM><BR>
<P><P><P><EM>&gt; To me, OO attempts to enforce &quot;organized&quot; coding practices in syntax.
</EM><BR>
<EM>&gt; Except for very limited cases, code re-use through inheritance is a
</EM><BR>
<EM>&gt; nearly worthless feature in practice, and many times the headaches it
</EM><BR>
<EM>&gt; can create offset any benefits. The biggest niceties of OO (IMO) are
</EM><BR>
<EM>&gt; the typing models and interfacing conventions.
</EM><BR>
<EM>&gt; 
</EM><BR>
<P>Code reuse through inheritance is the least important aspect of OO. 
<BR>
Encapsulation and polymorphism (genericity) are much more important.
<BR>
Modeling and coding closer to the actual problem space is more
<BR>
important. Grnated that many people using OO don't understand that.
<BR>
<P><EM>&gt; Again, if you write really good procedural code, you are not likely to
</EM><BR>
<EM>&gt; benefit much from OO. Perhaps it would be better just to teach people
</EM><BR>
<EM>&gt; good code design.
</EM><BR>
<EM>&gt; 
</EM><BR>
<EM>&gt; &gt;  &gt; We have automated certain classes of GUIs but the GUI story is far from
</EM><BR>
<EM>&gt; &gt;  &gt; complete or adequate.  Many projects are now being seriously perverted
</EM><BR>
<EM>&gt; &gt;  &gt; to use only a Web Browser as their GUI!  It is as if we are stepping
</EM><BR>
<EM>&gt; &gt;
</EM><BR>
<EM>&gt; &gt; Well, a web browser is an ubiquitous, easy way to control a system,
</EM><BR>
<EM>&gt; &gt; and you can put it within few 100 Bytes of assembly. A remote GUI is
</EM><BR>
<EM>&gt; &gt; not something too bad.
</EM><BR>
<EM>&gt; 
</EM><BR>
<EM>&gt; The web browser is great for ubiquity, but has too many limitations at
</EM><BR>
<EM>&gt; both the low- and high-level to make a good GUI.  Usable for simple
</EM><BR>
<EM>&gt; things (such as remote control), but very difficult to work with for
</EM><BR>
<EM>&gt; applications with complex interfaces (imagine running an application
</EM><BR>
<EM>&gt; like GIMP or Photoshop inside a web browser). However, there are a lot
</EM><BR>
<EM>&gt; of advantages to having a network aware UI, a capability where MS
</EM><BR>
<EM>&gt; Windows really blows goats.
</EM><BR>
<EM>&gt; 
</EM><BR>
<EM>&gt; I would really like to see the development of a capable, clean,
</EM><BR>
<EM>&gt; platform independent, network aware GUI system. Maybe something that
</EM><BR>
<EM>&gt; falls somewhere in between X (too big and crufty) and the Web.
</EM><BR>
<EM>&gt; Current widely available &quot;cross-platform&quot; GUI implementations such as
</EM><BR>
<EM>&gt; the Java AWT are an abomination -- all of the downside and none of
</EM><BR>
<EM>&gt; the upside IMHO.
</EM><BR>
<EM>&gt;
</EM><BR>
<P>I would like to see a &quot;cloud of objects&quot; world where it is not the
<BR>
programmers business that there is not one gigantic machine
<BR>
environment.  As long as we conflate programs and software architecture
<BR>
with network and OS topologies and vagaries we will imho be in the dark
<BR>
ages of computing.
<BR>
<P>&nbsp;
<BR>
<EM>&gt; &gt; We do have an interest in peer to peer information sharing (though not
</EM><BR>
<EM>&gt; &gt; yet collaboration) rising recently. Parallel applications (based on
</EM><BR>
<EM>&gt; &gt; PVM/MPI message passing libraries), including cluster file systems are
</EM><BR>
<EM>&gt; &gt; fairly widespread in science, and soon commerce. High-availability and
</EM><BR>
<EM>&gt; &gt; high-performance clusters for commerce are the hottest topics right
</EM><BR>
<EM>&gt; &gt; now. Things are not hopeless.
</EM><BR>
<EM>&gt; 
</EM><BR>
<EM>&gt; I think it will be five years or more or so before clusters become
</EM><BR>
<EM>&gt; really ubiquitous.  One of the biggest difficulties is that most
</EM><BR>
<EM>&gt; programmers have no clue how to develop &quot;cluster-aware&quot; software, and
</EM><BR>
<EM>&gt; aren't likely to get one any time soon.  When you consider that most
</EM><BR>
<EM>&gt; programmers still can't figure out how to design even moderately
</EM><BR>
<EM>&gt; complex locking schemes for multithreaded applications on a
</EM><BR>
<EM>&gt; single-processor system or to ensure something resembling
</EM><BR>
<EM>&gt; transactional integrity of complex shared data, both of which have
</EM><BR>
<EM>&gt; been around for years, I doubt that cluster-aware applications will be
</EM><BR>
<EM>&gt; quick to penetrate most market spaces. It is easier just to throw
</EM><BR>
<EM>&gt; bigger hardware at the problem.
</EM><BR>
<EM>&gt;
</EM><BR>
<P>Clusters are a tool for network topology and dependable service
<BR>
delivery.  Again, they should not be visible (except at the lowest
<BR>
levels) to the programming/application space.  If they are then
<BR>
something is very wrong.  
<BR>
<P>One of the things that make multi-threading and transactional integrity
<BR>
hard is that most language environments give only a few blunt tools for
<BR>
really addressing concurrency issues and most of the tools given have
<BR>
gross impedance mismatches with the language.  We do not to this day
<BR>
have good long-transaction models or tools.  
<BR>
<P>&nbsp;
<BR>
<EM>&gt; The people that &quot;get&quot; cluster design now because they find it
</EM><BR>
<EM>&gt; fascinating are going to be the majority of people who &quot;get&quot; cluster
</EM><BR>
<EM>&gt; design later. Most programmers will implement clustering badly,
</EM><BR>
<EM>&gt; which will essentially negate the benefits and slow adoption in many
</EM><BR>
<EM>&gt; organizations.
</EM><BR>
<EM>&gt;
</EM><BR>
<P>Again, most programmers should have no need to &quot;get&quot; cluster design.
<BR>
&nbsp;
<BR>
<EM>&gt; A majority of programmers quickly lose competence when they move past
</EM><BR>
<EM>&gt; the &quot;one user, one CPU, one process, one machine&quot; design space. In my
</EM><BR>
<EM>&gt; experience, as more of these variables become &gt;1, the greater
</EM><BR>
<EM>&gt; difficulty many programmers have producing efficient code. Only a
</EM><BR>
<EM>&gt; relative handful of working software engineers will produce efficient
</EM><BR>
<EM>&gt; code design when you have multi-user, multi-process, SMP, and
</EM><BR>
<EM>&gt; clustering as explicit design optimization considerations.  Too many
</EM><BR>
<EM>&gt; variables for some minds to wrap around I guess.
</EM><BR>
<EM>&gt;
</EM><BR>
<P>In a well designed system there is little need for most application
<BR>
programmers and even many system programmers to worry about all of these
<BR>
issues much of the time.  A large part of successful systems programming
<BR>
is keeping these issues out of the face of application programmers.  
<BR>
The human mind does in fact have limited ability to handle multiple
<BR>
concerns at once. Which is one reason it is good to restrict concerns to
<BR>
appropriate levels of a design/application/implementation space.
<BR>
<P>&nbsp;
<BR>
<EM>&gt; &gt;  &gt; good tools for finding the right components and simulating their
</EM><BR>
<EM>&gt; &gt;  &gt; interaction.  Much of our code base is still language and OS dependent
</EM><BR>
<EM>&gt; &gt;  &gt; and not componentized at all.  Most of code is still application
</EM><BR>
<EM>&gt; &gt;  &gt; stovepipes with little/no reuse or reuseability.  In short, almost no
</EM><BR>
<EM>&gt; &gt;  &gt; automation or next-level engineering applied to our own work.  It had
</EM><BR>
<EM>&gt; &gt;  &gt; better not continue like this.
</EM><BR>
<EM>&gt; 
</EM><BR>
<EM>&gt; Part of the problem with components is that the components as designed
</EM><BR>
<EM>&gt; today are only data aware in the grossest declarative sense.  As a
</EM><BR>
<EM>&gt; result, components are only useful for very narrowly defined problems
</EM><BR>
<EM>&gt; that rarely translate into something that can be re-used for all but
</EM><BR>
<EM>&gt; the most narrow domains. The brittleness and rigidity of current
</EM><BR>
<EM>&gt; component design methodologies is part of the reason that &quot;cut, paste,
</EM><BR>
<EM>&gt; and modify&quot; is a viable software development methodology.
</EM><BR>
<EM>&gt;
</EM><BR>
<P>Cut,paste, modify sucks big-time and produces krap systems.  Components
<BR>
are more difficult to write and can't be written well in broken toy
<BR>
languages.  Doing components well also requires some advances in our
<BR>
ability to model some aspects of the semantics that we cannot model well
<BR>
today.  I do not understand your comment about data awareness re
<BR>
components.  From outside the component its data awareness is irrelevant
<BR>
to the user as it gives a message/capability/functional interface only. 
<BR>
Would you want more than that?  
<BR>
&nbsp;
<BR>
<EM>&gt; But components don't really matter; I have strong doubts as to
</EM><BR>
<EM>&gt; whether components are a correct solution in the long-term anyway.
</EM><BR>
<EM>&gt; Components exist more to solve a human weakness in software
</EM><BR>
<EM>&gt; implementation than to solve any particular weakness intrinsic
</EM><BR>
<EM>&gt; to software design itself. I can't imagine why a smart machine would
</EM><BR>
<EM>&gt; use components to write software.
</EM><BR>
<EM>&gt;
</EM><BR>
<P>That is like saying that standardized reuseable parts in hardware exist
<BR>
only to solve particular weaknesses intrinsic to hardware design.  A
<BR>
smart machine would use components in order to not reinvent/reimplement
<BR>
the wheel every time it is needed, much as reasonably intelligent human
<BR>
software designers also attempt to do. It is not possible to
<BR>
think/design at increasingly more complex levels without reusing levels
<BR>
of parts (components) already sufficiently mastered, generalized and
<BR>
packaged.  
<BR>
<P>- samantha
<BR>
<P>&nbsp;
<BR>
<EM>&gt; -James Rogers
</EM><BR>
<EM>&gt;  <A HREF="mailto:jamesr@best.com?Subject=Re:%20Mostly%20stuff%20about%20software%20(was%20Homeless%20%2B%20Jobs,%20Lots%20of%20stuff%20%20about%20Software%20world)&In-Reply-To=&lt;39CE9E60.B3517795@objectent.com&gt;">jamesr@best.com</A>
</EM><BR>
<P><!-- body="end" -->
<HR NOSHADE>
<UL>
<!-- next="start" -->
<LI><STRONG>Next message:</STRONG> <A HREF="5615.html">Samantha Atkins: "Re: Why would AI want to be friendly?"</A>
<LI><STRONG>Previous message:</STRONG> <A HREF="5613.html">Franklin Wayne Poley: "Re: Why would AI want to be friendly?"</A>
<LI><STRONG>In reply to:</STRONG> <A HREF="5610.html">James Rogers: "Mostly stuff about software (was Homeless + Jobs, Lots of stuff about Software world)"</A>
<!-- nextthread="start" -->
<LI><STRONG>Next in thread:</STRONG> <A HREF="5626.html">J. R. Molloy: "Re: Mostly stuff about software (was Homeless + Jobs, Lots of stuff  about Software world)"</A>
<LI><STRONG>Reply:</STRONG> <A HREF="5626.html">J. R. Molloy: "Re: Mostly stuff about software (was Homeless + Jobs, Lots of stuff  about Software world)"</A>
<LI><STRONG>Reply:</STRONG> <A HREF="5707.html">James Rogers: "Re: Mostly stuff about software (was Homeless + Jobs, Lots of stuff about Software world)"</A>
<!-- reply="end" -->
<LI><STRONG>Messages sorted by:</STRONG> 
<A HREF="date.html#5614">[ date ]</A>
<A HREF="index.html#5614">[ thread ]</A>
<A HREF="subject.html#5614">[ subject ]</A>
<A HREF="author.html#5614">[ author ]</A>
</UL>
<!-- trailer="footer" -->
<HR NOSHADE>
<P>
<SMALL>
<EM>
This archive was generated by <A HREF="http://www.hypermail.org/">hypermail 2b29</A> 
: <EM>Mon Oct 02 2000 - 17:38:49 MDT</EM>
</EM>
</SMALL>
</BODY>
</HTML>
