<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
                      "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>
<HEAD>
<TITLE>extropians: Re: Homeless, (+ Jobs, Lots of stuff about Software</TITLE>
<META NAME="Author" CONTENT="Eugene Leitl (eugene.leitl@lrz.uni-muenchen.de)">
<META NAME="Subject" CONTENT="Re: Homeless, (+ Jobs, Lots of stuff about Software world)">
</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<H1>Re: Homeless, (+ Jobs, Lots of stuff about Software world)</H1>
<!-- received="Sun Sep 17 05:02:31 2000" -->
<!-- isoreceived="20000917110231" -->
<!-- sent="Sun, 17 Sep 2000 01:38:39 -0700 (PDT)" -->
<!-- isosent="20000917083839" -->
<!-- name="Eugene Leitl" -->
<!-- email="eugene.leitl@lrz.uni-muenchen.de" -->
<!-- subject="Re: Homeless, (+ Jobs, Lots of stuff about Software world)" -->
<!-- id="14788.33551.428768.650557@lrz.uni-muenchen.de" -->
<!-- inreplyto="39C07846.87F63FF7@objectent.com" -->
<STRONG>From:</STRONG> Eugene Leitl (<A HREF="mailto:eugene.leitl@lrz.uni-muenchen.de?Subject=Re:%20Homeless,%20(%2B%20Jobs,%20Lots%20of%20stuff%20about%20Software%20world)&In-Reply-To=&lt;14788.33551.428768.650557@lrz.uni-muenchen.de&gt;"><EM>eugene.leitl@lrz.uni-muenchen.de</EM></A>)<BR>
<STRONG>Date:</STRONG> Sun Sep 17 2000 - 02:38:39 MDT
<P>
<!-- next="start" -->
<UL>
<LI><STRONG>Next message:</STRONG> <A HREF="5132.html">Technotranscendence: "Re: Where's genetic programming at?"</A>
<LI><STRONG>Previous message:</STRONG> <A HREF="5130.html">Spudboy100@aol.com: "Re: self-extracting zipware AI 'casting"</A>
<LI><STRONG>In reply to:</STRONG> <A HREF="4930.html">Samantha Atkins: "Re: Homeless, (+ Jobs, Lots of stuff about Software world)"</A>
<!-- nextthread="start" -->
<LI><STRONG>Next in thread:</STRONG> <A HREF="5610.html">James Rogers: "Mostly stuff about software (was Homeless + Jobs, Lots of stuff about Software world)"</A>
<LI><STRONG>Reply:</STRONG> <A HREF="5610.html">James Rogers: "Mostly stuff about software (was Homeless + Jobs, Lots of stuff about Software world)"</A>
<!-- reply="end" -->
<LI><STRONG>Messages sorted by:</STRONG> 
<A HREF="date.html#5131">[ date ]</A>
<A HREF="index.html#5131">[ thread ]</A>
<A HREF="subject.html#5131">[ subject ]</A>
<A HREF="author.html#5131">[ author ]</A>
</UL>
<HR NOSHADE><P>
<!-- body="start" -->
<P>
Samantha Atkins writes:
<BR>
<P><EM> &gt; I doubt the &quot;we create more jobs one level up&quot; idea or that it
</EM><BR>
<EM> &gt; ameliorates the problem much.  I doubt we created more programmer jobs
</EM><BR>
<EM> &gt; than the total number of factory workers, secretaries, typists, human
</EM><BR>
<EM> &gt; number twiddlers and so on displaced by automation.  Even if we did
</EM><BR>
<P>People are displaced to find new jobs. In places with good economy,
<BR>
there are not enough construction workers or people who can use a
<BR>
metal lathe (what is the unemployment figure in California right now?
<BR>
5%, less?). There are postindustrial patches of the world with 15%
<BR>
unemployment, but you'll notice that there no one is hungry, either
<BR>
(with the possible exception of unemployed single mothers -- rather
<BR>
dumb, as raising an uneducated child is a net loss to the
<BR>
society. Smart people is a country's greatest resource).
<BR>
<P><EM> &gt; these next level jobs are reguiring progressive higher skills and higher
</EM><BR>
<EM> &gt; intelligence.  Looking at the bell-shaped curve for human IQ leads me to
</EM><BR>
<EM> &gt; the conclusion that a lot of people are not going to qualify for these
</EM><BR>
<EM> &gt; next-level jobs.  What should happen to them?
</EM><BR>
&nbsp;
<BR>
It's less IQ then attitude (and age). People who won't or can't learn
<BR>
should retire early, to not stand in the way of, say, bright educated
<BR>
immigrants. We're supposed to be rich, right? Why can't we retire
<BR>
people early, in more or less style?
<BR>
&nbsp;
<BR>
<EM> &gt; You are seeing them in Europe more than in the US.  In the US people on
</EM><BR>
<EM> &gt; welfare, and the chronically unemployed and a few other categories are
</EM><BR>
<EM> &gt; not counted.  So the statistics are a bit misleading.  Also, I wonder
</EM><BR>
<EM> &gt; how many jobs in the US are there simply to keep people employed and
</EM><BR>
<P>A person employed is one less person on the dole. If the state doesn't
<BR>
do it, private companies should do it. Many people define their
<BR>
identities from employment, and quickly die if fired, even if able to
<BR>
afford a modestly wealthy retirement.
<BR>
<P><EM> &gt; really are pretty pointless today.  From what I've seen as a consultant
</EM><BR>
<EM> &gt; in large corporations, the number of such is not small.  
</EM><BR>
&nbsp;
<BR>
Do you have and q&amp;d solution to the problem? I sure as hell don't.
<BR>
<P><EM> &gt; We are in agreement on the problem.  I am not sure what to do about it. 
</EM><BR>
<EM> &gt; We are at an interesting place.  There is not quite enough wealth to
</EM><BR>
<EM> &gt; both give everyone a good guaranteed income and let them decide what if
</EM><BR>
<EM> &gt; anything to do with their time including working for more money if they
</EM><BR>
<EM> &gt; have the skills needed.  we're arguably not quite there yet.  But
</EM><BR>
<P>I would doubt it. Trouble is, a guaranteed minimal income will reduce
<BR>
productivity. Right now quite a few people in Germany will not bother
<BR>
to work, because they would not earn noticeably more than being on the 
<BR>
dole.
<BR>
<P><EM> &gt; closer.  And a pretty good argument can be made that without
</EM><BR>
<EM> &gt; concentrations of wealth in private hands their is no energy/resources
</EM><BR>
<EM> &gt; to enable many types of innovation.  Of course there are also
</EM><BR>
<P>Good point. Robbing the rich to feed the poor makes us collectively
<BR>
poorer. We'll never make it into space if there's not enough loose
<BR>
cash in the pockets of wealthy geeks. I think there *is* a window of
<BR>
opportunity, and we already let a lot of know-how (there is a reason
<BR>
it's called &quot;rocket science&quot;) trapped in people's and group of
<BR>
people's heads drift to /dev/null.
<BR>
<P><EM> &gt; innovations dying in 9-5 jobs taken just to pay the rent that don't
</EM><BR>
<EM> &gt; leave much room or energy for the passions and true interests of many
</EM><BR>
<EM> &gt; workers.
</EM><BR>
<P>A nominal 9-5 (or part time) job will pay for the rent, and leave time
<BR>
for the hobbies. If I can't do truly interesting things in my job, I
<BR>
could as well let the nominal day job pay for my rent, and do
<BR>
interesting things in my spare time.
<BR>
<P><EM> &gt; It will be worse than bad if most of the energy goes into endless
</EM><BR>
<EM> &gt; competition for more material wealth when material wealth is no longer
</EM><BR>
<EM> &gt; that difficult or central.  It will also likely be bad if
</EM><BR>
<P>What motivates 95% of the people is money, and the material wealth
<BR>
they can buy for this money which will eclipse of what other people
<BR>
have. This is your set of boundary conditions you have to work
<BR>
with. If this means we have to paint McDonalds ads on rockets or send
<BR>
rich tourists to LEO, so be it. Millions of people playing games and
<BR>
running bloatware apps pushes supercomputer clusters forward. Don't
<BR>
diss the unwashed, they drive progress, albeit in their inefficient,
<BR>
circumspect way.
<BR>
<P><EM> &gt; people/groups/nations are bent on destroying or  exploiting one another
</EM><BR>
<EM> &gt; with those kinds of abilities in their kit.  
</EM><BR>
&nbsp;
<BR>
Coevolutionary artefacted competition brought you the goodies, so you
<BR>
have to tolerate a little rat race. Corporations fight with lawyers
<BR>
and on the market, not with cluster bombs, fuel-air explosives and
<BR>
biological weapons. Rather let corporations fight than nations.
<BR>
&nbsp;
<BR>
<EM> &gt; Don't bet on it.  What changes between then and now is the raw power of
</EM><BR>
<EM> &gt; the hardware.  As it becomes more powerful it becomes more tractable to
</EM><BR>
<EM> &gt; automate large segments of the work programmers currently do.  Of
</EM><BR>
<P>Sure, now it's easier to make a GUI, by just painting it on the
<BR>
screen. Program generators are not exactly new. Apart from wizards
<BR>
like our very own James Rogers (and sci things like ATLAS,
<BR>
automatically juggling source to optimize for a given architecture) we
<BR>
don't see automatic programming hitting the streets any time soon. And
<BR>
then people would still have to write specs in a formal language. Even
<BR>
if you don't write a protocol stack explicitly, you still have to
<BR>
codify it's behaviour.
<BR>
<P><EM> &gt; course, the demand for programming is so huge that it will take a while
</EM><BR>
<EM> &gt; before the automation cuts into the need for programmers too much.  But
</EM><BR>
<EM> &gt; the level of programmer needed will continue to rise also, stranding
</EM><BR>
<EM> &gt; many who are now in that profession.  Don't believe me?  Wait and see.
</EM><BR>
&nbsp;
<BR>
Sure as hell you'll find easier employment if you know Javur and XML,
<BR>
the whole web monkey business seems to just disintegrate in fractal
<BR>
bricabrac. Know many 40-year olds who can pick up Linux/Perl/Zope, or
<BR>
learn Python in a weekend? Even if they do, how many interviewers will
<BR>
believe them? Of course, a *real* C programmer in a Unix environment
<BR>
is still a force to be reckoned with, but I haven't seen a lot of job
<BR>
ads asking for these.
<BR>
<P><EM> &gt; Actually, having been in the software world myself for 20 years, I
</EM><BR>
<EM> &gt; suspect the truth is a bit dimmer than that.  Many of the tools I use
</EM><BR>
<EM> &gt; haven't evolved hardly at all in all of that time.  C lead to C++ but
</EM><BR>
<EM> &gt; the tools used to graft C++ have not exactly gone through any major
</EM><BR>
<EM> &gt; revolution.  C++ itself is quite primitive in many ways.  Java? 
</EM><BR>
<P>Jeez. If you think C++ is an improvement upon C you really have a
<BR>
strange mind. I do not see anything new cropping up since
<BR>
Lisp. Because I can't have Lisp machine in current technology (and am
<BR>
too dumb/poor to afford a DSP cluster running Forth), I've settled on
<BR>
Python/C in a OpenSource *nix environment (currently Linux).
<BR>
<P><EM> &gt; Interesting things have been done to exploit some of its features but
</EM><BR>
<EM> &gt; the language itself is not that powerful and not sufficient for many
</EM><BR>
<EM> &gt; types of problems.  Any interpreted or semi-interpreted language with
</EM><BR>
<P>What else did you expect of object-oriented C? Ok, it's got a garbage
<BR>
collection, around the turn of the millenium, holy Alonzo.
<BR>
<P><EM> &gt; equal or more reflection could be used in most of the contexts that Java
</EM><BR>
<EM> &gt; is used.  Some of these languages, such as Lisp and Smalltalk, are or
</EM><BR>
<EM> &gt; have been much more powerful and advanced in capability, usage, or
</EM><BR>
<EM> &gt; development environment than Java, C++, VB and so on are today.  Most of
</EM><BR>
<EM> &gt; the central abilities in languages were first invented and explored in
</EM><BR>
<EM> &gt; Lisp. 
</EM><BR>
&nbsp;
<BR>
Absolutely, but you're not exactly employable if you tout Lisp as your
<BR>
primary development language. Smalltalk is hardly better, though it is
<BR>
still being used in niches.
<BR>
&nbsp;
<BR>
<EM> &gt; We are beginning to address problems of programming in the large but
</EM><BR>
<EM> &gt; frankly many of the solutions are giant kludges that are severely
</EM><BR>
<EM> &gt; over-hyped and over-sold.  I have gotten quite disgruntled with this
</EM><BR>
<EM> &gt; industry.  We spend more time trying to lock up &quot;intellectual property&quot;
</EM><BR>
<P>Amen, verily, etc. etc.
<BR>
<P><EM> &gt; and out-hype the competition than we do actually designing and building
</EM><BR>
<EM> &gt; good systems.  And fixing our development tools themselves takes a
</EM><BR>
<EM> &gt; backseat to even that.  I designed and built things in the 80s ( and I
</EM><BR>
<EM> &gt; am not unique in this at all) that are as or more advanced than some
</EM><BR>
<EM> &gt; parts of the current highly-hyped baseline.  
</EM><BR>
&nbsp;
<BR>
I've seen some nifty packet-driven realtime stuff on an
<BR>
embedded. However, as people keep the nifty stuff closed-source as a
<BR>
competitive advantage, the field as a whole won't go anywhere.
<BR>
&nbsp;
<BR>
<EM> &gt; Sorry.  Most of that is an aside and off-topic.  I needed to rant. But
</EM><BR>
<EM> &gt; personally I don't think software development will get significantly
</EM><BR>
<EM> &gt; better until something like Open Source (better add Open Design) and
</EM><BR>
<EM> &gt; changes in the basis of software business occur.  I don't see how the
</EM><BR>
<EM> &gt; current model has room to get out of its own way.  
</EM><BR>
&nbsp;
<BR>
Luckily, you can make a (probably relatively meager by your standards)
<BR>
living doing OpenSource support and development already, though I have
<BR>
not checked that in person (but Ars Digita &amp; Co seem to be doing
<BR>
nicely).
<BR>
<P><EM> &gt; [anti VB rant, amen]
</EM><BR>
<EM> &gt; Putting various things in the OS is not a very bright idea.  The things
</EM><BR>
<EM> &gt; in the OS should be the minimum that can be handled more efficiently and
</EM><BR>
<EM> &gt; cleanly there.  A web browser is not an example of such.  
</EM><BR>
&nbsp;
<BR>
Unfortunately, even the relatively clueful Linux people do not
<BR>
understand the importance of having a (10-15 kByte) asynchronous OO
<BR>
message passing nanokernel at the core of Linux. Things like embedded
<BR>
and PDAs, and supercomputer clusters, especially those with embedded
<BR>
memories (forthcoming) are niches, but they'll be closed to Linux if
<BR>
it will go further towards Bloatland.
<BR>
&nbsp;&nbsp;
<BR>
<EM> &gt; VB will not allow you to do most of these things.  Back when I (shameful
</EM><BR>
<EM> &gt; to admit) hacked some VB I had to write anything interesting in C++/DCOM
</EM><BR>
<EM> &gt; and then do the GUI in VB and have it call the C++ COM objects.   It
</EM><BR>
<EM> &gt; works, but is totally proprietary to Microsloth.
</EM><BR>
&nbsp;
<BR>
I don't touch proprietary systems, period.
<BR>
&nbsp;&nbsp;
<BR>
<EM> &gt; You must be in a very different world or you don't see beneath the
</EM><BR>
<EM> &gt; wizards and the push-button IDE.  The underlying stuff has largely not
</EM><BR>
<P>God, we have Unix since three decades. We've had the Lisp machine,
<BR>
USCD-p on CP/M, Forth, Smalltalk boxes, we've had the Apple ][, the
<BR>
Lisa and the first Mac, and Amiga, and NeXT, and several others, and a
<BR>
lot of this happened before 1990. Apart from the raw performance
<BR>
(granted by the economies of scale since accepted as industry
<BR>
standard), Wintel as an architecture is a joke.
<BR>
<P><EM> &gt; improved at all except for the addition of binary components using CORBA
</EM><BR>
<EM> &gt; and COM.  Even those two are not a great improvement over a
</EM><BR>
<EM> &gt; distributed/persistent peer-peer object application environment I
</EM><BR>
<EM> &gt; created in 1986-1987.  It was unfortunately ahead of its time and
</EM><BR>
<EM> &gt; created under the auspices of a company that had no idea what to do with
</EM><BR>
<EM> &gt; it.  
</EM><BR>
&nbsp;
<BR>
If it's mainstream, it can't be any good.
<BR>
&nbsp;
<BR>
<EM> &gt; Our present underlying compiler and linker technology is not much better
</EM><BR>
<EM> &gt; than it was then.  Linkers have changed almost not at all.  DLLs?  Came
</EM><BR>
<P>You've lost already when you talk about compilers and linkers. I much
<BR>
prefer intactive incremental &quot;compilers&quot;, especially Forth on
<BR>
dedicated hardware (you can implement a feisty Forth CPU in ~12
<BR>
kTransistors, and implement a complete OS with IDE in ~10 kBytes,
<BR>
though much more advanced systems can take up ~100 kBytes, or
<BR>
so. Inclusive GUI, of course).
<BR>
<P><EM> &gt; out in the mid 80s.  The productivity tools for programmers leave a lot
</EM><BR>
<EM> &gt; to be desired.  In the Microsloth world to browse the call graphs of
</EM><BR>
<EM> &gt; functions and objects the software entity must first be fully compiled
</EM><BR>
<EM> &gt; with a bunch of special purpose flags set.  From one component you can't
</EM><BR>
<EM> &gt; browse into such details of another one.  The information is not unified
</EM><BR>
<EM> &gt; into some database you can query about various software artifacts and
</EM><BR>
<EM> &gt; their interaction and inter-dependencies.  What data that is gathered is
</EM><BR>
<EM> &gt; in a Microsoft proprietary format that you cannot use to develop
</EM><BR>
<EM> &gt; something more intelligent.  Yet Lisp and Smalltalk environment have had
</EM><BR>
<EM> &gt; such abilities for the last decade or even two.  I wrote such an
</EM><BR>
<EM> &gt; information extractor myself for some &lt;gasp&gt; Cobol legacy stuff I got
</EM><BR>
<EM> &gt; stuck with once in 1984.  
</EM><BR>
&nbsp;
<BR>
You see, those people don't even understand the words coming out of
<BR>
your mouth. We live in a world where Bill Gates has invented
<BR>
computing, software, and the Internet, singlehandedly. Saying anything
<BR>
else will only convince them that you're 1) crazy 2) lying, or both.
<BR>
<P><EM> &gt; The reason it is getting more difficult is the systems needed are more
</EM><BR>
<EM> &gt; sophisticated and the tools and infrastructure have not kept up with
</EM><BR>
<EM> &gt; them.  It is difficult to pour energy into better programming tools when
</EM><BR>
<EM> &gt; that kind of product doesn't pay off so well at the bank to make the VC
</EM><BR>
<EM> &gt; happy.  It is difficult to build them in house without the sponsoring
</EM><BR>
<EM> &gt; management looking like they don't have an eye on the bottom line.  So
</EM><BR>
<EM> &gt; we race faster and faster armed with inadequate tools and every more
</EM><BR>
<EM> &gt; pressing requirements, busily trying to automate everyone else's work
</EM><BR>
<EM> &gt; except our own.
</EM><BR>
&nbsp;
<BR>
Good programming resembles bonsai care. Not many people are keeping
<BR>
bonsai today.
<BR>
&nbsp;
<BR>
<EM> &gt; How does this tie-in to  extropian interests?  The future and the tech
</EM><BR>
<EM> &gt; we all so crave is built largely on top of software.  Keep most software
</EM><BR>
<EM> &gt; proprietary and don't invest in better software tools and the future
</EM><BR>
<EM> &gt; will be much more stunted than it could/should be.
</EM><BR>
<P>Not to mention system securety.
<BR>
<P><EM> &gt; It is more cranky and brittle than it needs to be in part because of the
</EM><BR>
<EM> &gt; problems I mentioned.  There are also some real bearish problems in some
</EM><BR>
<EM> &gt; of our currently dreamed up systems.  Things that will take real R&amp;D
</EM><BR>
<P>Parallelism, especially debugging massive parallelism in tiny grains
<BR>
is certainly a formidable problem. It might be even too formidable for 
<BR>
a human mind.
<BR>
<P><EM> &gt; projects to solve and then under the current model would come out as a
</EM><BR>
<EM> &gt; bunch of hacked up tools positioned to maximize profit instead of being
</EM><BR>
<EM> &gt; shared across the entire industry that needs them so desparately.  
</EM><BR>
&nbsp;
<BR>
OpenSource is moving, albeit slowly. No need to despair yet.
<BR>
<P><EM> &gt; &gt; People have been worried about the contrary point of view; that our systems
</EM><BR>
<EM> &gt; &gt; are getting so big, so unwieldy, that at some point we cross a failure
</EM><BR>
<EM> &gt; &gt; threshold, beyond which we cannot, as a bunch of humans, reliably maintain
</EM><BR>
<EM> &gt; &gt; the systems any more. Why would this be true?
</EM><BR>
<EM> &gt; 
</EM><BR>
<EM> &gt; Without the proper tools and without more and better automation it is
</EM><BR>
<EM> &gt; inevitable.  
</EM><BR>
&nbsp;
<BR>
I find it strange that a person in the software industry will find it
<BR>
strange that there is no limit to complexity to what a team of humans
<BR>
can do. There is overwhelming evidence that this is the case.
<BR>
<P><EM> &gt; My greatest expertise is in object persistence.  Persistence is far, far
</EM><BR>
<EM> &gt; from &quot;automated&quot;.  Persistence cross-cuts applications and products but
</EM><BR>
<EM> &gt; is often done as a series of hacks within a particular project
</EM><BR>
<EM> &gt; life-cycle.  Or a product is bought that promises to take the worries
</EM><BR>
<P>OO is far from being the silver bullet, i.e. code reuse by inheritance 
<BR>
from former projects does not seem to scale.
<BR>
<P><EM> &gt; all away but actually seriously perverts all application building
</EM><BR>
<EM> &gt; thereafter because its needs have to be met for the application to work
</EM><BR>
<EM> &gt; at all and its needs are to perturbing to everything else.  And the
</EM><BR>
<EM> &gt; solution ties the product and the organization often to the solution
</EM><BR>
<EM> &gt; provider firmly.  At the moment there is not a good persistent
</EM><BR>
<EM> &gt; middleware out there that fully meets what is needed.  There are various
</EM><BR>
<EM> &gt; attempts of greater/lesser goodness.  I plan to do large parts of that
</EM><BR>
<EM> &gt; problem better and to eventually release a series of Open Source
</EM><BR>
<EM> &gt; persistent middleware tools.  I am tired of seeing ugly solutions to
</EM><BR>
<EM> &gt; this set of problems I know well. 
</EM><BR>
&nbsp;
<BR>
I'm interested on your opinion of <A HREF="http://www.python.org">http://www.python.org</A>
<BR>
<P><EM> &gt; We have automated certain classes of GUIs but the GUI story is far from
</EM><BR>
<EM> &gt; complete or adequate.  Many projects are now being seriously perverted
</EM><BR>
<EM> &gt; to use only a Web Browser as their GUI!  It is as if we are stepping
</EM><BR>
<P>Well, a web browser is an ubiquitous, easy way to control a system,
<BR>
and you can put it within few 100 Bytes of assembly. A remote GUI is
<BR>
not something too bad.
<BR>
<P><EM> &gt; firmly into the past and putting more and more energy into centralized
</EM><BR>
<EM> &gt; servers even though we have more power on our desktops than we dared
</EM><BR>
<EM> &gt; dream of in the very recent past.  We need good massively distributed
</EM><BR>
<EM> &gt; peer-peer systems.  Not a sleazy 21st century rework of time-sharing
</EM><BR>
<EM> &gt; systems.
</EM><BR>
&nbsp;
<BR>
We do have an interest in peer to peer information sharing (though not
<BR>
yet collaboration) rising recently. Parallel applications (based on
<BR>
PVM/MPI message passing libraries), including cluster file systems are 
<BR>
fairly widespread in science, and soon commerce. High-availability and 
<BR>
high-performance clusters for commerce are the hottest topics right
<BR>
now. Things are not hopeless.
<BR>
&nbsp;
<BR>
<EM> &gt; Sure.  Although of a quite different sort.  What disturbs me is how
</EM><BR>
<EM> &gt; often I am still doing the same tired old tasks in much the same tired
</EM><BR>
<EM> &gt; way.  There is not often enough time to both meet the current
</EM><BR>
<EM> &gt; over-inflated deadline for an underdesigned product and automate as much
</EM><BR>
<EM> &gt; of my own process as would satisfy me. 
</EM><BR>
<P>Thanks for reminding me why I decided not to become an IT whore.
<BR>
&nbsp;
<BR>
<EM> &gt; &gt; Sure the techniques will change. Sure the skill set required will change.
</EM><BR>
<EM> &gt; &gt; But the basic programming job will remain, and grow wider in my opinion.
</EM><BR>
<EM> &gt; &gt; Lots of things will begin to look like programming in the future, which do
</EM><BR>
<EM> &gt; &gt; not now. Biotech might get to a point of &quot;automation&quot; where it starts using
</EM><BR>
<EM> &gt; &gt; programmers. Through nanotech, even the bricks &amp; mortar world will start to
</EM><BR>
<P>Molecular nanotechnology and molecular biology does not require
<BR>
programmers, or at least a very special brand of programmers. You need
<BR>
to cover 2-3 fields, and not be a narrow specialist, or collaborate
<BR>
tightly with other specialists, which will necessarily lack certain
<BR>
synergies.
<BR>
<P><EM> &gt; &gt; become a programming concern.
</EM><BR>
<EM> &gt; 
</EM><BR>
<EM> &gt; We don't yet do enough with well-defined and trusted components and with
</EM><BR>
<P>You sure as hell can't trust proprietary components, that's for sure.
<BR>
<P><EM> &gt; good tools for finding the right components and simulating their
</EM><BR>
<EM> &gt; interaction.  Much of our code base is still language and OS dependent
</EM><BR>
<EM> &gt; and not componentized at all.  Most of code is still application
</EM><BR>
<EM> &gt; stovepipes with little/no reuse or reuseability.  In short, almost no
</EM><BR>
<EM> &gt; automation or next-level engineering applied to our own work.  It had
</EM><BR>
<EM> &gt; better not continue like this.
</EM><BR>
&nbsp;
<BR>
I don't see happening much in the evolutionary vein, we will probably
<BR>
only see progress when evolutionary algorithms become productive,
<BR>
which right now is utterly unpredictable.
<BR>
<P><!-- body="end" -->
<HR NOSHADE>
<UL>
<!-- next="start" -->
<LI><STRONG>Next message:</STRONG> <A HREF="5132.html">Technotranscendence: "Re: Where's genetic programming at?"</A>
<LI><STRONG>Previous message:</STRONG> <A HREF="5130.html">Spudboy100@aol.com: "Re: self-extracting zipware AI 'casting"</A>
<LI><STRONG>In reply to:</STRONG> <A HREF="4930.html">Samantha Atkins: "Re: Homeless, (+ Jobs, Lots of stuff about Software world)"</A>
<!-- nextthread="start" -->
<LI><STRONG>Next in thread:</STRONG> <A HREF="5610.html">James Rogers: "Mostly stuff about software (was Homeless + Jobs, Lots of stuff about Software world)"</A>
<LI><STRONG>Reply:</STRONG> <A HREF="5610.html">James Rogers: "Mostly stuff about software (was Homeless + Jobs, Lots of stuff about Software world)"</A>
<!-- reply="end" -->
<LI><STRONG>Messages sorted by:</STRONG> 
<A HREF="date.html#5131">[ date ]</A>
<A HREF="index.html#5131">[ thread ]</A>
<A HREF="subject.html#5131">[ subject ]</A>
<A HREF="author.html#5131">[ author ]</A>
</UL>
<!-- trailer="footer" -->
<HR NOSHADE>
<P>
<SMALL>
<EM>
This archive was generated by <A HREF="http://www.hypermail.org/">hypermail 2b29</A> 
: <EM>Mon Oct 02 2000 - 17:38:17 MDT</EM>
</EM>
</SMALL>
</BODY>
</HTML>
