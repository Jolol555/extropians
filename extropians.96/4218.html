<!-- received="Tue Dec 17 19:10:12 1996 MST" -->
<!-- sent="Tue, 17 Dec 1996 17:52:27 -0800 (PST)" -->
<!-- name="John K Clark" -->
<!-- email="johnkc@well.com" -->
<!-- subject="Singularity Worship" -->
<!-- id="199612180152.RAA01175@well.com" -->
<!-- inreplyto="" -->
<title>extropians: Singularity Worship</title>
<h1>Singularity Worship</h1>
John K Clark (<i>johnkc@well.com</i>)<br>
<i>Tue, 17 Dec 1996 17:52:27 -0800 (PST)</i>
<p>
<ul>
<li> <b>Messages sorted by:</b> <a href="date.html#4218">[ date ]</a><a href="index.html#4218">[ thread ]</a><a href="subject.html#4218">[ subject ]</a><a href="author.html#4218">[ author ]</a>
<!-- next="start" -->
<li> <b>Next message:</b> <a href="4219.html">John K Clark: "Faster than light?"</a>
<li> <b>Previous message:</b> <a href="4217.html">Michael Butler: "Re: James Rogers's Minor Digression (aka Moods of Mind)"</a>
<!-- nextthread="start" -->
<!-- reply="end" -->
</ul>
<hr>
<!-- body="start" -->
-----BEGIN PGP SIGNED MESSAGE-----<br>
<p>
On Tue, 17 Dec 1996  James Rogers &lt;jamesr@best.com&gt; Wrote:<br>
                   <br>
                <br>
<i>                &gt;I could calculate 5203^127, albeit pretty slowly.                  </i><br>
<p>
And find the prime factors? You wouldn't have the time, The Big Crunch, <br>
The heat death of the Universe or Tipler's Omega Point would happen first.<br>
                 <br>
<p>
<i>                &gt;for every single bitwise operation, I could show you                 </i><br>
<i>                &gt;exactly what process is going on in the ALU at a transistor                 </i><br>
<i>                &gt;by transistor level.  </i><br>
<p>
<p>
For any single bitwise operation you could, for every single bitwise  <br>
operation you could not.<br>
                   <br>
<p>
<i>                 &gt;Actually, I think that arithmetic computation is a really                 </i><br>
<i>                 &gt;poor example of something that we don't (can't) understand.                  </i><br>
<i>                 &gt;It is a simple, deterministic process. There are no unknown                </i><br>
<i>                 &gt;variables.                                   </i><br>
                        <br>
<p>
Even humble Arithmetic is full of mystery and weirdness. For example,  I'll <br>
bet it would take you less than 5 minutes to write a computer program that <br>
would search for the smallest even number greater that 4 that is not the sum <br>
of two primes (ignoring 1 and 2) and then stop. <br>
<p>
Question: Would your computer program ever stop?  <br>
Answer: Nobody knows.  <br>
<p>
Question: If the program never stops can we be sure there is some way to know  <br>
this, so we can give up and don't keep wasting computer time?  <br>
Answer: No, Turing proved this is impossible.<br>
<p>
Computers have already looked for this number, if it exists it must be <br>
greater  than a trillion or so, but checking all even numbers one by one <br>
would take an infinite number of steps, to test it in a finite number of <br>
steps we need a proof, but I don't have one, nobody does. From Godel's work <br>
we know that it's possible that such a number does not exist, but a proof, <br>
a way to show it doesn't exist in a finite number of steps, does not exist <br>
either. If this is the case then computers will always keep tying one number <br>
after another and will keep finding nothing and mathematicians will keep <br>
trying to prove that there is no such number, and keep failing to do so.                   <br>
<p>
                        <br>
<i>                &gt;I would submit that everything we don't understand or can't                 </i><br>
<i>                &gt;predict is based entirely on we 1) can't measure something,                 </i><br>
<i>                &gt;2) can't find something, or 3) computational complexity is                </i><br>
<i>                &gt;too high. Using this as a metric, I can't think of a single    </i><br>
<i>                &gt;thing we don't understand that doesn't fall under  one or                 </i><br>
<i>                &gt;more of these categories.               </i><br>
  <br>
<p>
How about trying to understand if a photon polarized at 90 degrees will pass <br>
through a polarizer set at 45 degrees? Measure anything you want, look <br>
anywhere you want, compute anything you want, and it's  still a crap shoot, <br>
the odds  are 50 50. According to Quantum Physics the reason we don't <br>
understand some things is that there is nothing to understand, no reason, <br>
no cause, it's truly random.<br>
                   <br>
<p>
<i>                &gt;James:                </i><br>
<i>                &gt;You can duplicate the binary computational sequence by                </i><br>
<i>                &gt;arranging and moving pebbles.  </i><br>
<p>
<i>                &gt;John:                </i><br>
<i>                &gt;Certainly true, and then nobody would understand pebbles.                                </i><br>
                <br>
<i>                &gt;James                </i><br>
<i>                &gt;Pebbles are irrelevant to the computational structure.               </i><br>
<i>                &gt;No one needs to understand the pebbles to perform the              </i><br>
<i>                &gt;computation.  </i><br>
<p>
<p>
You need to understand the rules that govern how the pebbles behave, how they <br>
move and under what conditions. Otherwise you couldn't know what pattern they  <br>
will be in next.<br>
<p>
<p>
<i>                &gt;You could be using bananas and the results would be the same.  </i><br>
<p>
<p>
Yes, then nobody would understand bananas.<br>
                 <br>
<p>
<i>                &gt;You could build an entire computer as a set of equations </i><br>
<p>
<p>
I agree.<br>
<p>
<i>                &gt;and predict every outcome from the computer for every set of                 </i><br>
<i>                &gt;conditions.  </i><br>
                 <br>
<p>
I don't agree. Turing proved in 1935 that a computer program can not predict <br>
it's own behavior and neither can we. He proved that there are some numbers  <br>
no computer can ever deal with. He proved that if the Halting problem could  <br>
be solved then that would lead to a paradox, so the halting problem can not <br>
have a solution. This is how he did it.<br>
<p>
First make a list of all possible binary computer programs (Pn). Yes I know, <br>
there are an infinite number of them. If the programs don't have an endless <br>
loop in them they will eventually spit out a digital output, we will treat <br>
this output as a number so that program Pn produces the binary number <br>
bn1 bn2 bn3 ...  Sometimes the output will be infinitely long, like Pi, <br>
that's  OK, write it all down. Yes, this is going to be a very big list. <br>
<p>
Sometimes the program will have no output at all because it's caught in an <br>
endless loop, in that case just put a blank line in the list.  This is the <br>
list, well part of it anyway, the entire list is a little on the long side. <br>
                 <br>
Program P1 outputs bits  b11 b12 b13 b14 b15   etc   <br>
Program P2 outputs bits  b21 b22 b23 b24 b25   etc   <br>
Program P3 outputs bits  b31 b32 b33 b34 b35   etc   <br>
Program P4 outputs bits  d41 d42 d43 d44 d45   etc  <br>
Program P5 outputs bits  <br>
Program P6 outputs bits  b61 b62 b63 b64 b65   etc              <br>
etc        <br>
                 <br>
Now we can come up with our non computable number. We use Cantor's diagonal <br>
method and the "not" (~) operator. The following number is non computable.  <br>
~b11 ~b22 ~b33 ~b44 ...  Program P1 will not produce bit ~b11 , program P2 <br>
will not produce bit ~b22 ,  Program P3 will not produce bit ~b33 etc. No<br>
computer program will ever  produce this number, not even in an infinite <br>
amount of time.  <br>
<p>
At this point you should be starting to smell a paradox. What I've said looks <br>
pretty mechanical, so why couldn't a computer program produce it? To find the <br>
n'th bit of our non computable number all you need to do is run the Pn <br>
computer program  until it produces the  n'th bit and then "not" it.  At this <br>
point we have a computer program producing a number that no computer program  <br>
can produce. Something is not right.<br>
<p>
The only solution to the paradox is that in general the Halting Problem must <br>
not have a solution. This means you can't know for sure if the program will <br>
ever produce the n'th bit. It might go into an endless loop, it might not. <br>
It might produce the n'th bit in 5 seconds, it might produce it in 5 billion <br>
years,  it might never produce it. There is no general algorithm to decide.<br>
Thus there are some numbers that an apparently deterministic process like <br>
mathematics or a computer program can never find. More to the point in <br>
question, we can not predict what a computer program will do, if we want to <br>
know we'll just have to run it and see.<br>
<p>
<p>
                                          John K Clark        johnkc@well.com<br>
<p>
-----BEGIN PGP SIGNATURE-----<br>
Version: 2.6.i<br>
<p>
iQCzAgUBMrdTfX03wfSpid95AQGfWQTwwVqGVZ4U5gqMQpsPD0KVDilaKbZDJCzD<br>
pGby9lBjECRrnsuA+sW2PBY01LXdNHwgSUxAzjyW7gshfu4qtonT1y8uTKjhvnAX<br>
clKSTfYml3v3ML2aMyAzzFTw+p2CSaHTsgyJEbHUWoYXxNMXZdB5N+mkrQJVgTtq<br>
mb0PHFXY2TJs6ru+TMPtTAR1kVkNPvfH+7p8UE1ab4aKNFG3a+o=<br>
=vt/x<br>
-----END PGP SIGNATURE-----<br>
<!-- body="end" -->
<hr>
<p>
<ul>
<!-- next="start" -->
<li> <b>Next message:</b> <a href="4219.html">John K Clark: "Faster than light?"</a>
<li> <b>Previous message:</b> <a href="4217.html">Michael Butler: "Re: James Rogers's Minor Digression (aka Moods of Mind)"</a>
<!-- nextthread="start" -->
<!-- reply="end" -->
</ul>
