<!-- received="Wed Dec 18 14:41:19 1996 MST" -->
<!-- sent="Wed, 18 Dec 1996 12:57:48 -0800" -->
<!-- name="James Rogers" -->
<!-- email="jamesr@best.com" -->
<!-- subject="Re: Singularity Worship" -->
<!-- id="1.5.4.32.19961218205748.0034a770@best.com" -->
<!-- inreplyto="Singularity Worship" -->
<title>extropians: Re: Singularity Worship</title>
<h1>Re: Singularity Worship</h1>
James Rogers (<i>jamesr@best.com</i>)<br>
<i>Wed, 18 Dec 1996 12:57:48 -0800</i>
<p>
<ul>
<li> <b>Messages sorted by:</b> <a href="date.html#4267">[ date ]</a><a href="index.html#4267">[ thread ]</a><a href="subject.html#4267">[ subject ]</a><a href="author.html#4267">[ author ]</a>
<!-- next="start" -->
<li> <b>Next message:</b> <a href="4268.html">James Rogers: "Re: Brin on Privacy"</a>
<li> <b>Previous message:</b> <a href="4266.html">T0Morrow@aol.com: "Re: Can we develop a better definition of extropy?"</a>
<li> <b>Maybe in reply to:</b> <a href="4511.html">John K Clark: "Singularity Worship"</a>
<!-- nextthread="start" -->
<li> <b>Next in thread:</b> <a href="4435.html">Sean Hastings: "Re: Singularity Worship"</a>
<!-- reply="end" -->
</ul>
<hr>
<!-- body="start" -->
<i>&gt;                 &gt;Actually, I think that arithmetic computation is a really</i><br>
<p>
<i>&gt;                 &gt;poor example of something that we don't (can't)</i><br>
understand.                  <br>
<i>&gt;                 &gt;It is a simple, deterministic process. There are no</i><br>
unknown                <br>
<i>&gt;                 &gt;variables.                                   </i><br>
<i>&gt;                        </i><br>
<i>&gt;</i><br>
<i>&gt;Even humble Arithmetic is full of mystery and weirdness. For example,  I'll </i><br>
<i>&gt;bet it would take you less than 5 minutes to write a computer program that </i><br>
<i>&gt;would search for the smallest even number greater that 4 that is not the sum </i><br>
<i>&gt;of two primes (ignoring 1 and 2) and then stop. </i><br>
<i>&gt;</i><br>
<i>&gt;Question: Would your computer program ever stop?  </i><br>
<i>&gt;Answer: Nobody knows.  </i><br>
<i>&gt;</i><br>
<i>&gt;Question: If the program never stops can we be sure there is some way to know  </i><br>
<i>&gt;this, so we can give up and don't keep wasting computer time?  </i><br>
<i>&gt;Answer: No, Turing proved this is impossible.</i><br>
<p>
*Now* I understand what you are talking about.  You are correct, but in the<br>
sense that any theorem derived from a false premise is.  The computer is a<br>
tool designed to do deterministic computation.  If you are foolhardy enough<br>
to try to do a non-deterministic computation on a computer, you do so at<br>
your own risk.  <br>
In fact, I would submit that computers are *consciously designed* in such a<br>
way as to be unable to solve non-deterministic problems (or more correctly,<br>
we don't know of a way to design them so they can).  So in this sense, every<br>
outcome is *still* predictable, even for non-deterministic processes.  Every<br>
determinstic process has a predictable outcome, and every non-deterministic<br>
process has a predictable outcome( or more precisely, a universal lack of<br>
outcome at all).<br>
<p>
I still maintain that we understand arithmetic computation.  Not being able<br>
to solve a non-deterministic problem is by no means contrary to this.  <br>
<p>
<i>&gt;Computers have already looked for this number, if it exists it must be </i><br>
<i>&gt;greater  than a trillion or so, but checking all even numbers one by one </i><br>
<i>&gt;would take an infinite number of steps, to test it in a finite number of </i><br>
<i>&gt;steps we need a proof, but I don't have one, nobody does. From Godel's work </i><br>
<i>&gt;we know that it's possible that such a number does not exist, but a proof, </i><br>
<i>&gt;a way to show it doesn't exist in a finite number of steps, does not exist </i><br>
<i>&gt;either. If this is the case then computers will always keep tying one number </i><br>
<i>&gt;after another and will keep finding nothing and mathematicians will keep </i><br>
<i>&gt;trying to prove that there is no such number, and keep failing to do so.</i><br>
<p>
<p>
This is fine.  If it is a deterministic process, a result will be found in a<br>
predictable fashion assuming the computational complexity isn't too great.<br>
If it is a non-deterministic process, then we can predict that there will<br>
never be an outcome.  The real limitation is really in there ability to<br>
prove whether or not a process is deterministic.  If a process is<br>
non-deterministic, then a computer is the wrong tool.<br>
                <br>
<i>&gt;                &gt;I would submit that everything we don't understand or</i><br>
can't                 <br>
<i>&gt;                &gt;predict is based entirely on we 1) can't measure</i><br>
something,                 <br>
<i>&gt;                &gt;2) can't find something, or 3) computational complexity is</i><br>
<p>
<i>&gt;                &gt;too high. Using this as a metric, I can't think of a</i><br>
single    <br>
<i>&gt;                &gt;thing we don't understand that doesn't fall under  one or</i><br>
<p>
<i>&gt;                &gt;more of these categories.               </i><br>
<i>&gt;  </i><br>
<i>&gt;</i><br>
<i>&gt;How about trying to understand if a photon polarized at 90 degrees will pass </i><br>
<i>&gt;through a polarizer set at 45 degrees? Measure anything you want, look </i><br>
<i>&gt;anywhere you want, compute anything you want, and it's  still a crap shoot, </i><br>
<i>&gt;the odds  are 50 50. According to Quantum Physics the reason we don't </i><br>
<i>&gt;understand some things is that there is nothing to understand, no reason, </i><br>
<i>&gt;no cause, it's truly random.</i><br>
<p>
This a measurement issue.  Its a crap shoot because we can't measure the<br>
exact state of the photon just prior to it entering the polarizer.  We can<br>
only measure the outcome.<br>
<p>
<i>&gt;                &gt;James:                </i><br>
<i>&gt;                &gt;You can duplicate the binary computational sequence by</i><br>
<p>
<i>&gt;                &gt;arranging and moving pebbles.  </i><br>
<i>&gt;</i><br>
<i>&gt;                &gt;John:                </i><br>
<i>&gt;                &gt;Certainly true, and then nobody would understand pebbles.</i><br>
<p>
<i>&gt;                </i><br>
<i>&gt;                &gt;James                </i><br>
<i>&gt;                &gt;Pebbles are irrelevant to the computational structure.</i><br>
<p>
<i>&gt;                &gt;No one needs to understand the pebbles to perform the</i><br>
<p>
<i>&gt;                &gt;computation.  </i><br>
<i>&gt;</i><br>
<i>&gt;</i><br>
<i>&gt;You need to understand the rules that govern how the pebbles behave, how they </i><br>
<i>&gt;move and under what conditions. Otherwise you couldn't know what pattern they  </i><br>
<i>&gt;will be in next.</i><br>
<p>
If the rules are defined, then we understand the computation.  We aren't<br>
trying to understand pebbles.<br>
<p>
<p>
<i>&gt;                &gt;You could build an entire computer as a set of equations </i><br>
<i>&gt;</i><br>
<i>&gt;</i><br>
<i>&gt;I agree.</i><br>
<i>&gt;</i><br>
<i>&gt;                &gt;and predict every outcome from the computer for every set</i><br>
of                 <br>
<i>&gt;                &gt;conditions.  </i><br>
<i>&gt;                 </i><br>
<i>&gt;</i><br>
<i>&gt;I don't agree. Turing proved in 1935 that a computer program can not predict </i><br>
<i>&gt;it's own behavior and neither can we. He proved that there are some numbers  </i><br>
<i>&gt;no computer can ever deal with. He proved that if the Halting problem could  </i><br>
<i>&gt;be solved then that would lead to a paradox, so the halting problem can not </i><br>
<i>&gt;have a solution. This is how he did it.</i><br>
<p>
Again, the issue of determinism versus non-determinism.  In this case, we<br>
have infinite recursion.  Doesn't sound very deterministic to me.<br>
<p>
<i>&gt;First make a list of all possible binary computer programs (Pn). Yes I know, </i><br>
<i>&gt;there are an infinite number of them. If the programs don't have an endless </i><br>
<i>&gt;loop in them they will eventually spit out a digital output, we will treat </i><br>
<i>&gt;this output as a number so that program Pn produces the binary number </i><br>
<i>&gt;bn1 bn2 bn3 ...  Sometimes the output will be infinitely long, like Pi, </i><br>
<i>&gt;that's  OK, write it all down. Yes, this is going to be a very big list. </i><br>
<i>&gt;</i><br>
<i>&gt;Sometimes the program will have no output at all because it's caught in an </i><br>
<i>&gt;endless loop, in that case just put a blank line in the list.  This is the </i><br>
<i>&gt;list, well part of it anyway, the entire list is a little on the long side. </i><br>
<i>&gt;                 </i><br>
<i>&gt;Program P1 outputs bits  b11 b12 b13 b14 b15   etc   </i><br>
<i>&gt;Program P2 outputs bits  b21 b22 b23 b24 b25   etc   </i><br>
<i>&gt;Program P3 outputs bits  b31 b32 b33 b34 b35   etc   </i><br>
<i>&gt;Program P4 outputs bits  d41 d42 d43 d44 d45   etc  </i><br>
<i>&gt;Program P5 outputs bits  </i><br>
<i>&gt;Program P6 outputs bits  b61 b62 b63 b64 b65   etc              </i><br>
<i>&gt;etc        </i><br>
<i>&gt;                 </i><br>
<i>&gt;Now we can come up with our non computable number. We use Cantor's diagonal </i><br>
<i>&gt;method and the "not" (~) operator. The following number is non computable.  </i><br>
<i>&gt;~b11 ~b22 ~b33 ~b44 ...  Program P1 will not produce bit ~b11 , program P2 </i><br>
<i>&gt;will not produce bit ~b22 ,  Program P3 will not produce bit ~b33 etc. No</i><br>
<i>&gt;computer program will ever  produce this number, not even in an infinite </i><br>
<i>&gt;amount of time.  </i><br>
<i>&gt;</i><br>
<i>&gt;At this point you should be starting to smell a paradox. What I've said looks </i><br>
<i>&gt;pretty mechanical, so why couldn't a computer program produce it? To find the </i><br>
<i>&gt;n'th bit of our non computable number all you need to do is run the Pn </i><br>
<i>&gt;computer program  until it produces the  n'th bit and then "not" it.  At this </i><br>
<i>&gt;point we have a computer program producing a number that no computer program  </i><br>
<i>&gt;can produce. Something is not right.</i><br>
<i>&gt;</i><br>
<i>&gt;The only solution to the paradox is that in general the Halting Problem must </i><br>
<i>&gt;not have a solution. This means you can't know for sure if the program will </i><br>
<i>&gt;ever produce the n'th bit. It might go into an endless loop, it might not. </i><br>
<i>&gt;It might produce the n'th bit in 5 seconds, it might produce it in 5 billion </i><br>
<i>&gt;years,  it might never produce it. There is no general algorithm to decide.</i><br>
<i>&gt;Thus there are some numbers that an apparently deterministic process like </i><br>
<i>&gt;mathematics or a computer program can never find. More to the point in </i><br>
<i>&gt;question, we can not predict what a computer program will do, if we want to </i><br>
<i>&gt;know we'll just have to run it and see.</i><br>
<p>
This is only true for algorithms that we don't know to be deterministic.<br>
The atomic computations are always deterministic, but the algorithms don't<br>
have to be.  The software I write is always deterministic (unless I screw<br>
up) and I always can predict the outcome.  Computers are designed<br>
specifically for deterministic algorithms, and only *really poor* software<br>
engineers are writing non-deterministic software.<br>
<p>
<p>
<p>
-James Rogers<br>
 jamesr@best.com<br>
<!-- body="end" -->
<hr>
<p>
<ul>
<!-- next="start" -->
<li> <b>Next message:</b> <a href="4268.html">James Rogers: "Re: Brin on Privacy"</a>
<li> <b>Previous message:</b> <a href="4266.html">T0Morrow@aol.com: "Re: Can we develop a better definition of extropy?"</a>
<li> <b>Maybe in reply to:</b> <a href="4511.html">John K Clark: "Singularity Worship"</a>
<!-- nextthread="start" -->
<li> <b>Next in thread:</b> <a href="4435.html">Sean Hastings: "Re: Singularity Worship"</a>
<!-- reply="end" -->
</ul>
