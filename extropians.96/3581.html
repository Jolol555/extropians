<!-- received="Mon Dec  2 19:48:15 1996 MST" -->
<!-- sent="Mon, 02 Dec 1996 18:33:18 -0800" -->
<!-- name="James Rogers" -->
<!-- email="jamesr@best.com" -->
<!-- subject="Re: We need better tools to make better tools." -->
<!-- id="1.5.4.32.19961203023318.0032d964@best.com" -->
<!-- inreplyto="We need better tools to make better tools." -->
<title>extropians: Re: We need better tools to make better tools.</title>
<h1>Re: We need better tools to make better tools.</h1>
James Rogers (<i>jamesr@best.com</i>)<br>
<i>Mon, 02 Dec 1996 18:33:18 -0800</i>
<p>
<ul>
<li> <b>Messages sorted by:</b> <a href="date.html#3581">[ date ]</a><a href="index.html#3581">[ thread ]</a><a href="subject.html#3581">[ subject ]</a><a href="author.html#3581">[ author ]</a>
<!-- next="start" -->
<li> <b>Next message:</b> <a href="3582.html">E. Shaun Russell: "Re: Singularity-worship"</a>
<li> <b>Previous message:</b> <a href="3580.html">Chris Hind: "Re: ALL LISTMEMBERS READ THIS NOW!"</a>
<li> <b>Maybe in reply to:</b> <a href="3516.html">Max M: "We need better tools to make better tools."</a>
<!-- nextthread="start" -->
<li> <b>Next in thread:</b> <a href="3606.html">Max M: "Re: We need better tools to make better tools."</a>
<!-- reply="end" -->
</ul>
<hr>
<!-- body="start" -->
At 12:44 AM 12/3/96 +0100, you wrote:<br>
<p>
<i>&gt;&gt; Developing a</i><br>
<i>&gt;&gt; tool/language as you have described it is in some ways the Holy Grail of</i><br>
<i>&gt;&gt; software development.   Almost by definition, having detailed control</i><br>
<i>&gt;over</i><br>
<i>&gt;&gt; the operation and features of a piece of software will add complexity to</i><br>
<i>&gt;the</i><br>
<i>&gt;&gt; source code and development.</i><br>
<i>&gt;</i><br>
<i>&gt;Yes thats right. But in some obscure way the purpose of a high level</i><br>
<i>&gt;language is not to make us able to do more. It is to make us able to do</i><br>
<i>&gt;less, but do it more efficiently.</i><br>
<i>&gt;</i><br>
<i>&gt;Hardware - Binary code - Assembler language - c-code - multimedia tool</i><br>
<i>&gt;</i><br>
<i>&gt;As a software pro you certainly know about the different program levels.</i><br>
<i>&gt;What i say is that it should be possible in some way to make a tool that</i><br>
<i>&gt;will improve our tools for making tools. I could easily imagine languages</i><br>
<i>&gt;like c++ or Java redone with a completely graphical interface that you</i><br>
<i>&gt;could learn to use by using it. Done right it should speed up the software</i><br>
<i>&gt;creation process. Perhaps it could even be so simple that artists and</i><br>
<i>&gt;psychologist could use it to improve its own interface with. If this could</i><br>
<i>&gt;be done recursively we could have a really strong tool in the end.</i><br>
<i>&gt;Perhaps the tool could be so powerfull that it would be easy to make</i><br>
<i>&gt;updates all the way back to the assmbly level.</i><br>
<i>&gt;</i><br>
<p>
This is sort of true, but not entirely.  Assembly code, for example, was a<br>
true improvement.  There is nothing that you can do binary code that you<br>
can't do in assembler.  The improvement was that assembler more closely<br>
matched the way humans thought when writing code.  C on the other hand, was<br>
only an improvement in development cycle efficiency, in exchange for a<br>
decrease in run-time efficiency.  Tailored development systems are both good<br>
and bad, depending on the context.  In the context of a specific<br>
application, such as a multimedia tool, it can be very advantageous to have<br>
a language that is specifically tailored to that application.  On the other<br>
hand, if you are required to program many different applications, it can be<br>
a significant burden having to learn a new specialty language for every<br>
application you are trying to develop.  This is the strength of the C family<br>
of languages.  Although C is not specifically optimized for any particular<br>
application, its versatility is well-suited for almost any type of<br>
application.  And with C++, the language can be customized to be well suited<br>
for specific applications.<br>
<p>
<i>&gt;</i><br>
<i>&gt;&gt; At the same time, to have true freedom in application development, you</i><br>
<i>&gt;must</i><br>
<i>&gt;&gt; be able to write the low-level code yourself and develop your own objects</i><br>
<i>&gt;&gt; from scratch.  </i><br>
<i>&gt;</i><br>
<i>&gt;Yes but it doesn't have to look like gibberish.</i><br>
<i>&gt;</i><br>
<p>
Whether or not it looks like gibberish depends on the programmer.  If you<br>
want to program at the assembly level, the code will *always* have to use<br>
the very explicit and terse structure of assembly code, no matter how it is<br>
represented.  Programming at any level is restricted by the limits and<br>
definitions of that level.  By definition, if you are going to program at a<br>
low level, it *will* look like low-level code.  The level of a language you<br>
work with is really dependant on how much of the true nature of the machine<br>
you want to see and work with.  High-level languages hide the true nature of<br>
the machine at the expense of not being able to manipulate the details of<br>
this nature.  It is unavoidable.<br>
<p>
<i>&gt;&gt; Consider the mTropolis tool you described above Although, I have never</i><br>
<i>&gt;used it, I </i><br>
<i>&gt;&gt; guarantee that it doesn't have all the features and options you would</i><br>
<i>&gt;have if you coded &gt; the same application yourself using C++.  </i><br>
<i>&gt;</i><br>
<i>&gt;Thats right. and it isn't supposed to. It was just an example. But still</i><br>
<i>&gt;it's a pretty amazing example of how good an interface for a programming</i><br>
<i>&gt;language can be. if you have acces to a Mac try and download the trial</i><br>
<i>&gt;version and you will se what i mean.</i><br>
<p>
As for mTropolis, yes, it may be a good interface to a programming language<br>
IF you are interested in developing multimedia software.  But what if you<br>
are developing another type of application?  I personally develop a broad<br>
range of applications ranging from databases to network applications to DSP<br>
software.  No one tool as you have described will give me the ease of use<br>
you describe AND be ideally suited for developing all these applications.<br>
And what about large applications that have many different aspects?  Without<br>
a single, common underlying language, how would you integrate all the<br>
components of that piece of software?  I need a single tool that will allow<br>
me to develop all my applications.  Sure, this may require a certain level<br>
of abstraction, but at least I don't have to learn a new language every time<br>
I need to do a new type of application.<br>
<p>
Admittedly, C/C++ is a intricate and complex language to learn.  But the<br>
plus side is that once you learn a couple languages and start developing,<br>
you will find that these languages can be nearly as efficient and always<br>
more flexible than the highly abstracted ones.  And after you learn a couple<br>
of the "difficult" languages, new (even difficult) languages will come very<br>
quickly. <br>
<p>
<i>&gt;&gt; The difficulty in software development isn't in the coding.  It is in</i><br>
<i>&gt;&gt; defining the features you want, the properties of these features, and how</i><br>
<i>&gt;&gt; the features interact with each other.  This engenders a level of</i><br>
<i>&gt;complexity</i><br>
<i>&gt;&gt; that cannot be avoided.</i><br>
<i>&gt;</i><br>
<i>&gt;This is exactly what i mean. What i don't like about the traditional</i><br>
<i>&gt;languages is that the interface between the tool and the user is so weak.</i><br>
<i>&gt;The user has to know to much to use the tool. Its very nonintuitive.</i><br>
<p>
You are confusing knowing how to use the tool and knowing how to use the<br>
computer.  The design of tools like C and C++ reflect the nature of the<br>
computer.  This is important because the tools are specifically for the<br>
purpose of controlling the nature of the computer.  If it is nonintuitive,<br>
it is because you don't yet know enough about the way a computer works to<br>
program it.<br>
<p>
<i>&gt;As far as i know no one has still to try to make a graphic programming tool</i><br>
<i>&gt;that can be used for serious system development, and i don't mean something</i><br>
<i>&gt;like Visual c++ or any of those kind of interfaces they are just a hack.</i><br>
<i>&gt;</i><br>
<p>
This is because every time you abstract the language from the machine, the<br>
language becomes less useful as a general programming tool.  You cannot do<br>
serious system development if you don't understand how the system works.<br>
And understanding how the system works requires the knowledge that makes the<br>
usefulness of languages such as C and C++ apparent.  Those languages make<br>
more sense than the really high-level ones if you understand what is<br>
actually going on.<br>
  <br>
For some uses, I can understand what you are saying.  Some things, like<br>
multimedia, don't have a very large custom code component, and are therefore<br>
easily abstracted.  Other applications, such as database or systems<br>
development, require very thorough knowledge of data structures, algorithms,<br>
and fundamental constructs of computer science, no matter which way you<br>
slice it.  You cannot effectively develop some applications without having<br>
the detailed knowledge you seek to avoid via highly abstracted tools.<br>
<p>
<i>&gt;&gt; The limitation, therefore, isn't in the tools themselves, but in the</i><br>
<i>&gt;ability</i><br>
<i>&gt;&gt; of humans to express exactly what they want the tools to do.</i><br>
<i>&gt;</i><br>
<i>&gt;I want the tools to help the humans express what they want. I want the tool</i><br>
<i>&gt;to be something that you learn to use by using it.</i><br>
<p>
Somehow, this statement doesn't make sense to me. You always have to have a<br>
minimum base of knowledge before you can attempt to use any tool.<br>
<p>
<i>&gt;Everybody (almost) agrees that the GUI is a better way to comunicate with a</i><br>
<i>&gt;computer than a command language. Everybody except system developers. Eh...</i><br>
<i>&gt;things that makes you go hmmm...</i><br>
<p>
Actually, a lot of CAD types prefer keyboard control to mouse control<br>
because it requires less work, even though they work in a graphic<br>
environment.  GUIs are the anti-christ of ergonomic efficiency.<br>
<p>
As most programmers will tell you, *IF* you know what you are doing, a<br>
command language is always more powerful and efficient than a GUI.  So for<br>
system developers, a command language *is* a better way of communicating.  A<br>
keyboard is always faster than a mouse and a command interface contains far<br>
less extraneous information than a graphical one.  I almost always get more<br>
development work done with a good text editor than with a fancy graphical<br>
environment.<br>
<p>
-James Rogers<br>
 jamesr@best.com<br>
<!-- body="end" -->
<hr>
<p>
<ul>
<!-- next="start" -->
<li> <b>Next message:</b> <a href="3582.html">E. Shaun Russell: "Re: Singularity-worship"</a>
<li> <b>Previous message:</b> <a href="3580.html">Chris Hind: "Re: ALL LISTMEMBERS READ THIS NOW!"</a>
<li> <b>Maybe in reply to:</b> <a href="3516.html">Max M: "We need better tools to make better tools."</a>
<!-- nextthread="start" -->
<li> <b>Next in thread:</b> <a href="3606.html">Max M: "Re: We need better tools to make better tools."</a>
<!-- reply="end" -->
</ul>
