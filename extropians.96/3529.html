<!-- received="Sun Dec  1 21:01:21 1996 MST" -->
<!-- sent="Sun, 01 Dec 1996 19:52:04 -0800" -->
<!-- name="James Rogers" -->
<!-- email="jamesr@best.com" -->
<!-- subject="Re: We need better tools to make better tools." -->
<!-- id="1.5.4.32.19961202035204.00347268@best.com" -->
<!-- inreplyto="We need better tools to make better tools." -->
<title>extropians: Re: We need better tools to make better tools.</title>
<h1>Re: We need better tools to make better tools.</h1>
James Rogers (<i>jamesr@best.com</i>)<br>
<i>Sun, 01 Dec 1996 19:52:04 -0800</i>
<p>
<ul>
<li> <b>Messages sorted by:</b> <a href="date.html#3529">[ date ]</a><a href="index.html#3529">[ thread ]</a><a href="subject.html#3529">[ subject ]</a><a href="author.html#3529">[ author ]</a>
<!-- next="start" -->
<li> <b>Next message:</b> <a href="3530.html">QueeneMUSE@aol.com: "Re: Nanotechnology: Just the beginning"</a>
<li> <b>Previous message:</b> <a href="3528.html">James Rogers: "Re: Plan in Advance"</a>
<li> <b>Maybe in reply to:</b> <a href="3516.html">Max M: "We need better tools to make better tools."</a>
<!-- nextthread="start" -->
<li> <b>Next in thread:</b> <a href="3543.html">Walter Wlodarski: "Re: We need better tools to make better tools."</a>
<!-- reply="end" -->
</ul>
<hr>
<!-- body="start" -->
<i>&gt;I have programmed a bit in c++ and i hated every moment of it. That</i><br>
<i>&gt;language is very powerfull but the interface is really really bad.</i><br>
<i>&gt;</i><br>
<i>&gt;There's a new multimedia tool out now that builds on the object oriented</i><br>
<i>&gt;principle as well that is called mTropolis. <a href="http://www.mfactory.com">http://www.mfactory.com</a> It is</i><br>
<i>&gt;really powerfull but won't quite fit as a tool to make tools. It is a</i><br>
<i>&gt;multimedia development tool and very efficient as such. It has a graphic</i><br>
<i>&gt;metaphor that makes true object oriented programming seem very simple.</i><br>
<i>&gt;(Learned in a day or less.)</i><br>
<i>&gt;</i><br>
<i>&gt;What we need is a development tool with the power of something like c++ or</i><br>
<i>&gt;Java combined with the ease of use of something like mTropolis. The tool</i><br>
<i>&gt;should have an emphasis on being extensible in a way that would make it</i><br>
<i>&gt;easy to use it to make new and improved tools with.</i><br>
<i>&gt;</i><br>
<i>&gt;When we have that we will develop new tools to develop new tools with.</i><br>
<i>&gt;</i><br>
<i>&gt;Something like c++ really doesn't make it a lot easier to make new</i><br>
<i>&gt;languages with. It doesn't know enough about computers, Computer-languages</i><br>
<i>&gt;and operating systems. It is implicit in the language that the programmer</i><br>
<i>&gt;must know it all to use for making next gen tools.</i><br>
<i>&gt;</i><br>
<i>&gt;That is what i think is an original idea here. That the software should</i><br>
<i>&gt;"know" something about what it's supposed to be used for in the next</i><br>
<i>&gt;generations. It must be designed to be a tool to make tools with.</i><br>
<p>
The problem with your idea is in the implementation.  Developing a<br>
tool/language as you have described it is in some ways the Holy Grail of<br>
software development.   Almost by definition, having detailed control over<br>
the operation and features of a piece of software will add complexity to the<br>
source code and development.  C++, although complicated, allows a high level<br>
of abstraction from the code development.  Object-oriented languages<br>
encourage "black box" objects that can be extended and reused without<br>
knowing the details of the code involved.  You could build a very complex<br>
application by gluing together pre-made objects and writing very little<br>
source code, without the slightest concept of what was actually contained<br>
inside the objects.  This is the power of the paradigm.<br>
<p>
At the same time, to have true freedom in application development, you must<br>
be able to write the low-level code yourself and develop your own objects<br>
from scratch.  Otherwise you would be forced to use the objects and tools<br>
available, limiting the freedom and range of applications and features you<br>
could develop.  Consider the mTropolis tool you described above.  It has<br>
been abstracted to the point that it is very easy to learn and develop<br>
applications in.  Although, I have never used it, I guarantee that it<br>
doesn't have all the features and options you would have if you coded the<br>
same application yourself using C++.  <br>
<p>
Suppose you built a programming tool for building software at a very<br>
abstracted level.  If you told it "Build me a wordprocessor", it would pop<br>
out a wordprocessor.  But how would you control the features?  So you tell<br>
it explicitly what features you want in this word processor.  But then you<br>
would be faced with the problem of controlling the features of each<br>
particular feature, properties of each feature, the interface of each<br>
feature, the limits of feature complexity, etc.  By the time you defined<br>
every aspect of every property of this piece of software, actually coding it<br>
would take very little time by an experienced programmer.  In fact, a<br>
properly thought out and designed C++ program that takes advantage of<br>
existing objects doesn't take much more time to actually write than an<br>
identical program written in highly abstracted object-oriented languages.<br>
<p>
The difficulty in software development isn't in the coding.  It is in<br>
defining the features you want, the properties of these features, and how<br>
the features interact with each other.  This engenders a level of complexity<br>
that cannot be avoided.<br>
<p>
And, in fact, there are graphical tools that allow you to develop detailed,<br>
complex applications in C++ based entirely on a graphical design interface,<br>
with essentially no code writing.  But using these tools requires that you<br>
have a very good understanding of the capabilities and features of the<br>
software that you want it to write.  The problem is, most people don't<br>
*want* to think about the software they want.  They just want software to be<br>
magically generated, that magically knows exactly how you wanted it to<br>
operate in exactly the way you wanted.<br>
<p>
The limitation, therefore, isn't in the tools themselves, but in the ability<br>
of humans to express exactly what they want the tools to do.<br>
<p>
<p>
-James Rogers<br>
 jamesr@best.com<br>
<!-- body="end" -->
<hr>
<p>
<ul>
<!-- next="start" -->
<li> <b>Next message:</b> <a href="3530.html">QueeneMUSE@aol.com: "Re: Nanotechnology: Just the beginning"</a>
<li> <b>Previous message:</b> <a href="3528.html">James Rogers: "Re: Plan in Advance"</a>
<li> <b>Maybe in reply to:</b> <a href="3516.html">Max M: "We need better tools to make better tools."</a>
<!-- nextthread="start" -->
<li> <b>Next in thread:</b> <a href="3543.html">Walter Wlodarski: "Re: We need better tools to make better tools."</a>
<!-- reply="end" -->
</ul>
