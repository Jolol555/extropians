<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
                      "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
<title>extropians: RE: TECH: Database independence</title>
<meta name="Author" content="Emlyn O'regan (oregan.emlyn@healthsolve.com.au)">
<meta name="Subject" content="RE: TECH: Database independence">
</head>
<body bgcolor="#FFFFFF" text="#000000">
<h1>RE: TECH: Database independence</h1>
<!-- received="Wed Oct 10 04:51:17 2001" -->
<!-- isoreceived="20011010105117" -->
<!-- sent="Wed, 10 Oct 2001 20:03:58 +0930" -->
<!-- isosent="20011010103358" -->
<!-- name="Emlyn O'regan" -->
<!-- email="oregan.emlyn@healthsolve.com.au" -->
<!-- subject="RE: TECH: Database independence" -->
<!-- id="7A2B25F8EB070940996FA543A70A217B03CA9F@ADLEXSV02" -->
<!-- inreplyto="TECH: Database independence" -->
<strong>From:</strong> Emlyn O'regan (<a href="mailto:oregan.emlyn@healthsolve.com.au?Subject=RE:%20TECH:%20Database%20independence&In-Reply-To=&lt;7A2B25F8EB070940996FA543A70A217B03CA9F@ADLEXSV02&gt;"><em>oregan.emlyn@healthsolve.com.au</em></a>)<br>
<strong>Date:</strong> Wed Oct 10 2001 - 04:33:58 MDT
<p>
<!-- next="start" -->
<ul>
<li><strong>Next message:</strong> <a href="0660.html">Joe Dees: "RE: The Path (was: This War Is Not About Terror...)"</a>
<li><strong>Previous message:</strong> <a href="0658.html">Anders Sandberg: "Re: TECH: Quantum Head Job"</a>
<li><strong>Maybe in reply to:</strong> <a href="0587.html">Emlyn O'regan: "TECH: Database independence"</a>
<!-- nextthread="start" -->
<!-- reply="end" -->
<li><strong>Messages sorted by:</strong> 
<a href="date.html#659">[ date ]</a>
<a href="index.html#659">[ thread ]</a>
<a href="subject.html#659">[ subject ]</a>
<a href="author.html#659">[ author ]</a>
</ul>
<hr noshade><p>
<!-- body="start" -->
<p>
James Rogers wrote:
<br>
<em>&gt; 
</em><br>
<em>&gt; 
</em><br>
<em>&gt; On 10/8/01 8:17 PM, &quot;Emlyn O'regan&quot; 
</em><br>
<em>&gt; &lt;<a href="mailto:oregan.emlyn@healthsolve.com.au?Subject=RE:%20TECH:%20Database%20independence&In-Reply-To=&lt;7A2B25F8EB070940996FA543A70A217B03CA9F@ADLEXSV02&gt;">oregan.emlyn@healthsolve.com.au</a>&gt; wrote:
</em><br>
<em>&gt; &gt; 
</em><br>
<em>&gt; &gt; I'm doing YADA work at the moment (Yet Another Database 
</em><br>
<em>&gt; App), and I've run
</em><br>
<em>&gt; &gt; into an old problem for which there never seems to be a really good
</em><br>
<em>&gt; &gt; solution. This particular app is targetted at RDBMS Brand X 
</em><br>
<em>&gt; (actually it's
</em><br>
<em>&gt; &gt; Sybase), and now there is a need to retarget it to another 
</em><br>
<em>&gt; RDBMS. I am
</em><br>
<em>&gt; &gt; positive that more databases will creep into the story over 
</em><br>
<em>&gt; time, so this is
</em><br>
<em>&gt; &gt; the old database-independent-app problem.
</em><br>
<em>&gt; 
</em><br>
<em>&gt; 
</em><br>
<em>&gt; This is a standard problem.  I've actually constructed fairly thorough
</em><br>
<em>&gt; database abstraction layers (ANSI SQL only gets you so much), 
</em><br>
<em>&gt; and there are
</em><br>
<em>&gt; actually two primary problems in my experience:  SQL 
</em><br>
<em>&gt; migration and schema
</em><br>
<em>&gt; migration.
</em><br>
<em>&gt; 
</em><br>
<em>&gt; The schema migration is the worse part, since you may find 
</em><br>
<em>&gt; that there is no
</em><br>
<em>&gt; equivalent form for your schema on a different database.  This is
</em><br>
<em>&gt; particularly true if you start from relatively unrestricted 
</em><br>
<em>&gt; databases (e.g.
</em><br>
<em>&gt; DB2, Oracle) and move to a database that has dozens of 
</em><br>
<em>&gt; seemingly innocuous
</em><br>
<em>&gt; restrictions and limits (e.g. SQL Server 7) that are violated 
</em><br>
<em>&gt; all over the
</em><br>
<em>&gt; place with the original schema.
</em><br>
<em>&gt; 
</em><br>
<p>Yes, I agree with all of this.
<br>
<p>Let me backtrack a little, and say that I come from the perspective of a
<br>
short term contractor working on many small to medium systems. This is a big
<br>
(!) part of the IT industry, and has a few properties which are relevant:
<br>
<p>1 - Very tight timeframes and budgets. This usually means a relatively small
<br>
allotment of effort toward infrastructural concerns. In terms of
<br>
infrastructure (eg: middleware frameworks), if it's not off the shelf, it's
<br>
unlikely to be done well at all. Yes, it's short term thinking - think of
<br>
all those software companies with lots of little products each using their
<br>
own crappy infrastructure, with no attempt to look at the bigger picture and
<br>
solve common problems once and well. But it is.
<br>
<p>2 - Tendency to set a bunch of unrealistic restrictions at the start of a
<br>
project, which bite hard later. The relevant such restriction is &quot;We will
<br>
only ever target brand X database&quot;. 
<br>
<p>3 - The need for very low admin overhead, either in the development team, or
<br>
onsite, or both. This usually leads to choosing a db like SQL Server over
<br>
something like Oracle, for obvious reasons (see also &quot;tight budgets&quot;). 
<br>
<p>Thus, I'm looking at this problem from the perspective of projects where the
<br>
one-database mistake will usually be made up front, where that database will
<br>
be of the feature-restricted type, like SQL Server, and where retrofitting
<br>
an object persistence framework is _not_ going to happen _ever_, due to all
<br>
parts of the app, most notably the client, being implicitly built around a
<br>
relational db model, even if it doesn't talk directly to the database (for
<br>
example, look at the Midas middleware provided by Borland; a damned nice low
<br>
admin overhead middleware framework for small-medium apps, but its best
<br>
features lock you into a record-based result-set kind of model, rather than
<br>
object collections). 
<br>
<p><em>&gt;  
</em><br>
<em>&gt; &gt; The big drama with retargetting the app is the mighty 
</em><br>
<em>&gt; mountain of SQL which
</em><br>
<em>&gt; &gt; is database specific. RDBMSs are supposed to follow 
</em><br>
<em>&gt; standards with their SQL
</em><br>
<em>&gt; &gt; - yeah, right. While they do look superficially similar, 
</em><br>
<em>&gt; SQL dialects differ
</em><br>
<em>&gt; &gt; in fundamental join syntax, in built in functions, in the 
</em><br>
<em>&gt; kinds of primitive
</em><br>
<em>&gt; &gt; data types they provide operators for, etc. This can be a 
</em><br>
<em>&gt; really big hassle,
</em><br>
<em>&gt; &gt; and from an ongoing maintenance point of view it is big 
</em><br>
<em>&gt; enough to be a
</em><br>
<em>&gt; &gt; project killer, especially if it forces a codebase to be 
</em><br>
<em>&gt; forked into one
</em><br>
<em>&gt; &gt; copy for each database to be targetted.
</em><br>
<em>&gt; 
</em><br>
<em>&gt; 
</em><br>
<em>&gt; There isn't really a nice way to do this.  The last time I 
</em><br>
<em>&gt; had to do this
</em><br>
<em>&gt; (build an abstraction layer with support for every major 
</em><br>
<em>&gt; RDBMS under the
</em><br>
<em>&gt; sun), I built a Java abstraction framework for all database 
</em><br>
<em>&gt; functionality
</em><br>
<em>&gt; that was likely to be used by the application.  This was 
</em><br>
<em>&gt; supported by a
</em><br>
<em>&gt; plug-in cartridges that handled differences between our 
</em><br>
<em>&gt; reference SQL (we
</em><br>
<em>&gt; chose ANSI SQL99) and the individual database dialects.  The 
</em><br>
<em>&gt; SQL conversion
</em><br>
<em>&gt; was then done inside the API from SQL99 to the local dialect 
</em><br>
<em>&gt; of the plug-in
</em><br>
<em>&gt; cartridge.  This way, all the application code could be 
</em><br>
<em>&gt; written to a single
</em><br>
<em>&gt; ANSI SQL target.  Adding new plug-in cartridges turned out to 
</em><br>
<em>&gt; be pretty
</em><br>
<em>&gt; trivial once the first couple ones had been done, and this 
</em><br>
<em>&gt; system worked
</em><br>
<em>&gt; pretty nicely.  The APIs had support for many things beyond 
</em><br>
<em>&gt; simple database
</em><br>
<em>&gt; abstraction as well, such as caching and persistence, so it 
</em><br>
<em>&gt; turned out to be
</em><br>
<em>&gt; a good way to get all the  company applications off a 
</em><br>
<em>&gt; particular database
</em><br>
<em>&gt; and is used for just about everything these days.
</em><br>
<em>&gt; 
</em><br>
<p>Where do you work, and are they hiring? ;-)
<br>
<p>Seriously, that sounds like the best possible solution, but not really
<br>
doable for the kinds of jobs I work on. What I am intrigued by in the
<br>
description above, however, is the implication that your framwork accepted a
<br>
standard SQL dialect, and then translated automatically via the plugins into
<br>
the target SQL dialect. I am interested because I think something which does
<br>
this job, without the abstraction framework, is going to be a massive boon
<br>
to smaller projects, especially those which have already been built, and
<br>
need to retrofit database independence. With an all singing all dancing
<br>
translator, all that needs to be done to the app is to go through in one
<br>
pass once and hand modify all SQL to the reference SQL from whatever
<br>
proprietary muck is being used, and add a mechanism for passing it through
<br>
the translator. After that, a system can use the reference SQL, and be
<br>
maintained as if it were only talking to one dependable db platform; magic!
<br>
<p>What I'm thinking of building is a translator, probably from a reference SQL
<br>
to any target SQL via plugin db specific modules for generating SQL strings
<br>
from the internal SQL representation. If I get cocky, I might look at a
<br>
plugin mechanism for input too, to parse specific SQL dialects into the
<br>
internal representation; but you would understand the extra trouble this
<br>
causes. 
<br>
<p>What I'd eventually like to build is a pseudo database; it looks like a db,
<br>
lives on it's own server, handles transactions, network communication, etc,
<br>
takes a standard SQL dialect, even has it's own &quot;stored procs&quot;. However, it
<br>
would really only be a layer on top of other databases, and would be using
<br>
other dbs to do the work. You'd set this connectivity up at the pseudo db
<br>
server, thus rendering the real databases completely invisible to the higher
<br>
app layers. It might even provide quite complex functionality in it's SQL
<br>
that the underlying database can't do, and handle it by turning it into
<br>
multiple steps requiring temporary tables and other goodies, managing
<br>
transactions so that it still behaved like one atomic statement.
<br>
<p>Of course, that's a pretty major chunk to bite off. What I'd likely start
<br>
with is a bunch of components for something like Delphi, which do the
<br>
translation internally in that programming language. I might then package
<br>
them into an &quot;ActiveX&quot; of some kind (probably in-process com object), so
<br>
that most programs could get to them. Also, a website based around this
<br>
object would be pretty nice, allowing anyone to come in and write statements
<br>
in the reference SQL, and get out the equivalent statements for the db of
<br>
their choice! 
<br>
<p>Next step would be to build an ADO driver that is either built out of the
<br>
components or uses the ActiveX object, and can be configured to use other
<br>
ADO drivers to do the real work; so, you would install this translator ADO
<br>
driver, and set it up to point at, say, an Oracle ADO driver (or whatever DB
<br>
you are using); your app would just send reference SQL to the translator ADO
<br>
driver, which would translate and send the correct platform specific SQL to
<br>
the platform specific ADO driver, and handle ferrying other communication
<br>
backward and forward transparently as required. After doing that, maybe I
<br>
might think about a full blown server implementation :-O
<br>
<p>I know that this translation can be done, because I've built a basic version
<br>
of this concept before in a work for hire situation, which translated a
<br>
restricted subset of SQL Server sql to Oracle sql. I think the concept of
<br>
doing the translation of SQL from one dialect to another automatically would
<br>
be really useful to a lot of people.
<br>
<p><em>&gt; As I said, the biggest problem was migrating existing schema. 
</em><br>
<em>&gt;  We started
</em><br>
<em>&gt; with an Oracle 8i schema, which turned out to be a major problem when
</em><br>
<em>&gt; migrating to feature restricted databases such as SQL Server 
</em><br>
<em>&gt; 7.  In this
</em><br>
<em>&gt; case there is no choice but to re-engineer the schema to the 
</em><br>
<em>&gt; lowest common
</em><br>
<em>&gt; denominator and/or move some database capabilities (e.g. sequence
</em><br>
<em>&gt; generation) out of the DBMS into middleware.  We did the 
</em><br>
<em>&gt; latter in some
</em><br>
<em>&gt; cases and the former in others, depending on what the feature was that
</em><br>
<em>&gt; wasn't portable.
</em><br>
<em>&gt; 
</em><br>
<em>&gt; Good luck,
</em><br>
<em>&gt; 
</em><br>
<em>&gt; -James Rogers
</em><br>
<em>&gt;  <a href="mailto:jamesr@best.com?Subject=RE:%20TECH:%20Database%20independence&In-Reply-To=&lt;7A2B25F8EB070940996FA543A70A217B03CA9F@ADLEXSV02&gt;">jamesr@best.com</a>
</em><br>
<em>&gt; 
</em><br>
<em>&gt; 
</em><br>
<p>As I've said above, I'm mostly dealing with apps which start on a feature
<br>
poor platform, which is actually a boon; I start with a restricted set of
<br>
schema implementation features, which tends to be fairly trivial to port.
<br>
With an app which has been written to target Oracle, by developers who
<br>
really understand oracle; well, there's a whole world of pain, of course!
<br>
<p>Emlyn
<br>
<p><p>***************************************************************************
<br>
Confidentiality: The contents of this email are confidential and are
<br>
intended only for the named recipient. If the reader of this e-mail is not
<br>
the intended recipient you are hereby notified that any use, reproduction,
<br>
disclosure or distribution of the information contained in the e-mail is
<br>
prohibited. If you have received this e-mail in error, please reply to us
<br>
immediately and delete the document.
<br>
Viruses: Any loss/damage incurred by using this material is not the sender's
<br>
responsibility. Our entire liability will be limited to resupplying the
<br>
material. No warranty is made that this material is free from computer virus
<br>
or other defect.
<br>
<p><!-- body="end" -->
<hr noshade>
<ul>
<!-- next="start" -->
<li><strong>Next message:</strong> <a href="0660.html">Joe Dees: "RE: The Path (was: This War Is Not About Terror...)"</a>
<li><strong>Previous message:</strong> <a href="0658.html">Anders Sandberg: "Re: TECH: Quantum Head Job"</a>
<li><strong>Maybe in reply to:</strong> <a href="0587.html">Emlyn O'regan: "TECH: Database independence"</a>
<!-- nextthread="start" -->
<!-- reply="end" -->
<li><strong>Messages sorted by:</strong> 
<a href="date.html#659">[ date ]</a>
<a href="index.html#659">[ thread ]</a>
<a href="subject.html#659">[ subject ]</a>
<a href="author.html#659">[ author ]</a>
</ul>
<!-- trailer="footer" -->
<hr noshade>
<p>
<small>
<em>
This archive was generated by <a href="http://www.hypermail.org/">hypermail 2b30</a> 
: <em>Sat May 11 2002 - 17:44:13 MDT</em>
</em>
</small>
</body>
</html>
