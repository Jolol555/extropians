<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
                      "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
<title>extropians: Re: Programming project required</title>
<meta name="Author" content="Emlyn (emlyn@one.net.au)">
<meta name="Subject" content="Re: Programming project required">
</head>
<body bgcolor="#FFFFFF" text="#000000">
<h1>Re: Programming project required</h1>
<!-- received="Sun Jan 21 17:48:19 2001" -->
<!-- isoreceived="20010122004819" -->
<!-- sent="Mon, 22 Jan 2001 11:17:10 +0930" -->
<!-- isosent="20010122014710" -->
<!-- name="Emlyn" -->
<!-- email="emlyn@one.net.au" -->
<!-- subject="Re: Programming project required" -->
<!-- id="018201c08415$40dc1a40$320120c2@squashy2000" -->
<!-- inreplyto="01012114280402.00679@tachyon" -->
<strong>From:</strong> Emlyn (<a href="mailto:emlyn@one.net.au?Subject=Re:%20Programming%20project%20required&In-Reply-To=&lt;018201c08415$40dc1a40$320120c2@squashy2000&gt;"><em>emlyn@one.net.au</em></a>)<br>
<strong>Date:</strong> Sun Jan 21 2001 - 18:47:10 MST
<p>
<!-- next="start" -->
<ul>
<li><strong>Next message:</strong> <a href="1998.html">Samantha Atkins: "Re: Cyborgia"</a>
<li><strong>Previous message:</strong> <a href="1996.html">Emlyn: "Re: Extro IT Techies list?"</a>
<li><strong>In reply to:</strong> <a href="1974.html">James Rogers: "Re: Programming project required"</a>
<!-- nextthread="start" -->
<li><strong>Next in thread:</strong> <a href="2006.html">James Rogers: "Re: Programming project required"</a>
<li><strong>Reply:</strong> <a href="2006.html">James Rogers: "Re: Programming project required"</a>
<!-- reply="end" -->
<li><strong>Messages sorted by:</strong> 
<a href="date.html#1997">[ date ]</a>
<a href="index.html#1997">[ thread ]</a>
<a href="subject.html#1997">[ subject ]</a>
<a href="author.html#1997">[ author ]</a>
</ul>
<hr noshade><p>
<!-- body="start" -->
<p>
James Rogers wrote:
<br>
<em>&gt; On Sun, 21 Jan 2001, Emlyn wrote:
</em><br>
<em>&gt; &gt; &gt; Surely not compared to Windows which to this
</em><br>
<em>&gt; &gt; &gt; day cannot even deal with multiple users correctly.
</em><br>
<em>&gt; &gt;
</em><br>
<em>&gt; &gt; ??? Are you talking about NT5, or Win3.1?
</em><br>
<em>&gt;
</em><br>
<em>&gt;
</em><br>
<em>&gt; Any version, take your pick.  Windows in all its incarnations has never
</em><br>
<em>&gt; been a multiuser environment.  Take a look at the odd and ugly hack that
</em><br>
is
<br>
<em>&gt; Citrix Winframe, trying to (badly) get the same multiuser capability out
</em><br>
of
<br>
<em>&gt; Windows that has been a basic feature of Unix for ages (e.g. X).
</em><br>
<em>&gt;
</em><br>
<p>I think I know what you mean here... the way that, for instance, it is
<br>
damned difficult to get one NT Server to have multiple users simultaneously,
<br>
in a Unix terminal-based style.
<br>
<p>I'd criticize it for that too. However, one thing with Windows (nowadays) is
<br>
that it is designed for a different architecture to the old
<br>
Mainframe+Terminals style. Instead of one expensive box and lots of cheapy
<br>
terminals, they go for many (relatively) cheap servers, and many relatively
<br>
cheap workstations, which are computers in their own right. So instead of
<br>
say, a couple of huge workhorse servers and tons of terminals or
<br>
workstations, you might run 20 NT server boxes and fat pcs on every desk.
<br>
<p>I realise this has drawbacks, and that people are moving back to the
<br>
big-server mode in many cases. I also know that the basic task of running an
<br>
arbitrary program on a remote machine is a lot harder to do on Windows than
<br>
under Unix.
<br>
<p><em>&gt;
</em><br>
<em>&gt; &gt; However, SQL Server I do love; version 7 is fabulous. I don't know what
</em><br>
DBAs
<br>
<em>&gt; &gt; think of it; I know it requires you to replace the Oracle style
</em><br>
architecture
<br>
<em>&gt; &gt; of a couple of beasty servers with a cluster of zillions of little,
</em><br>
<em>&gt; &gt; cantankerous machines.But from a developer's point of view, it's pretty
</em><br>
<em>&gt; &gt; damned good. The tools are sweet, too.
</em><br>
<em>&gt;
</em><br>
<em>&gt;
</em><br>
<em>&gt; Oracle has a great core engine surrounded by tools and development toys
</em><br>
<em>&gt; that are totally ass.
</em><br>
<p>You mean shitty here, yes? Having a slight cultural problem interpreting
<br>
&quot;ass&quot;.
<br>
<p>Why is it that Oracle's tools are so damned lame? Drives me crazy (I have to
<br>
work with them at the moment).
<br>
<p>For instance, to run arbitrary SQL against Oracle using a simple query tool
<br>
turned out to be hopeless using their basic tools. Admittedly, a lot of this
<br>
SQL was generated, and was really long; the oracle tools kept truncating it
<br>
(not good). I wrote my own tools to run this stuff, against any ADO
<br>
datasource, with some really nice features, in about 6 hours.
<br>
<p>Surely Oracle can spare 6 developer hours (make it 12, give 'em time for
<br>
testing) to write a halfway decent query tool to go with their products...
<br>
<p><em>&gt; Hence why there is a thriving market for
</em><br>
<em>&gt; third-party Oracle development tools, many of which are as good as you
</em><br>
<em>&gt; will find on any database platform.  SQL Server has the reverse situation,
</em><br>
<em>&gt; with lots of reasonably decent development tools surrounding a core engine
</em><br>
<em>&gt; that is still pretty lame (though v7 is quantum improvement over v6.5).
</em><br>
<em>&gt; Since a business runs on the core engine, not on the development tools,
</em><br>
<em>&gt; Oracle is still widely preferred by most management teams.  After all,
</em><br>
<em>&gt; good tools can be purchased for Oracle as well (just not from Oracle).
</em><br>
<em>&gt; Also from a management standpoint, Oracle is extraordinarily portable and
</em><br>
<em>&gt; can be migrated with minimal effort to *really big* systems -- no code
</em><br>
<em>&gt; rewrites to change platforms.
</em><br>
<em>&gt;
</em><br>
<p>Funnily enough, the core engine isn't as important as all that, I find,
<br>
except for really big, mission critical stuff (which is less common than
<br>
you'd think).
<br>
<p>For example, I used to work in the network operations for an electricity
<br>
utility. I was building a call-center app which needed to do all sorts of
<br>
lovely realtime things, integrate with other corporate systems, and
<br>
eventually allow clients in the field over wireless connections, and
<br>
remotely over modems, as well as locally. It usually had very low traffic,
<br>
unless there were storms, in which case you could have a lot of users
<br>
bashing it repeatedly.
<br>
<p>We used SQL Server 6.5, and it did the job admirably. We were very careful
<br>
with application of stored procedures, we indexed things properly,
<br>
denormalised where necessary, and ended up with a very efficient
<br>
application, running on very cheap servers, costing very little to
<br>
administrate and maintain.
<br>
<p>As a comparison, in the next room was the network control center; a bunch of
<br>
old blokes working round the clock shifts with various stress-related
<br>
problems, controlling the grid in the companies' control area. Very
<br>
sensitive work. They were running a Unix-based scada system, with triple
<br>
redundant hundred-thousand dollar plus oracle servers doing the work; this
<br>
system used telemetry to actually directly control the network. Now there is
<br>
an application for which I would never even think about SQL Server. Horses
<br>
for courses, of course. However, you can imagine how expensive this system
<br>
was to maintain, how hard it was to administrate.
<br>
<p><em>&gt; I should also point out that while simple database development can be
</em><br>
<em>&gt; accomplished using GUI tools, there are many things in the database world
</em><br>
<em>&gt; for which there is no substitute for dropping to a rich CLI shell to run
</em><br>
<em>&gt; complicated scripts.  Like Oracle SQL*Plus on a Unix character terminal.
</em><br>
<em>&gt;
</em><br>
<p>SQL*Plus... urk. Hideous! There's no substitute, because that's what Oracle
<br>
ships, and that's that. It's a damned awful tool, though, a disgusting
<br>
kludge. Look at the way you have to generate scripts that generate scripts
<br>
which do the work; how hard would it be to provide real programming language
<br>
contructs like loops and conditionals and stuff (yes, I've seen people
<br>
simulate these with bizzarre application of comments and environment
<br>
variables in code generation)?
<br>
<p>I bet there are great tools, of course, to substitute for this crud, offered
<br>
by third parties. Must find myself one, preferably with a gui.
<br>
<p><em>&gt; From the standpoint of a DBA/SA on really large database systems, I would
</em><br>
<em>&gt; take Oracle over SQL Server any day.  Oracle has been doing these types of
</em><br>
<em>&gt; systems far longer than Microsoft, and ultimately, managing giant complex
</em><br>
<em>&gt; systems from any Windows system is painful.
</em><br>
<p>It's not easy from Oracle, either; you need in depth arcane knowledge of all
<br>
these 70's style crypto command line tools, which keeps skilled dbas on the
<br>
gravy train. Sorry, that's not fair, but I am a developer... I'm expected to
<br>
undervalue a DBA's role, it's a professional obligation :-)
<br>
<p><em>&gt;
</em><br>
<em>&gt; Of course, there is more than just Oracle and SQL Server.  DB2 for
</em><br>
<em>&gt; instance.
</em><br>
<em>&gt;
</em><br>
<p>How 'bout Informix. I've heard good things...
<br>
<p>Anyone know Interbase? Borland pushes it, but I'm skeptical. Anyone?
<br>
<p><em>&gt; &gt; Borland Delphi is sweet, beautiful, GUI based and proud.
</em><br>
<em>&gt;
</em><br>
<em>&gt;
</em><br>
<em>&gt; This really is a superior product for GUI application development.  I am
</em><br>
<em>&gt; looking forward to the Unix versions I've heard are coming out.
</em><br>
<em>&gt;
</em><br>
<p>Now you're talking! I find that delphi is so good, that it's quicker for me
<br>
to throw together a nice gui app to do something against Oracle, for
<br>
instance, than it is to try to write cryptic SQL*Plus scripts.
<br>
<p><em>&gt;
</em><br>
<em>&gt; &gt; Nowadays I'm writing ASP to talk directly to a database. We're not using
</em><br>
a
<br>
<em>&gt; &gt; middle tier :-(, but jscript, as the scripting language, is turning out
</em><br>
to
<br>
<em>&gt; &gt; be incredibly efficient (compared to how I expected it to perform); I
</em><br>
wrote
<br>
<em>&gt; &gt; a SQL Server -&gt; Oracle sql translator so that we could support multiple
</em><br>
dbs
<br>
<em>&gt; &gt; more easily, and I never notice any performance hit, which is surprising
</em><br>
<em>&gt; &gt; because I never designed for speed, and I'm pretty sure the thing is
</em><br>
<em>&gt; &gt; computationally intensive.
</em><br>
<em>&gt;
</em><br>
<em>&gt;
</em><br>
<em>&gt; Perhaps the fact that you are using ASP puts the SQL translation below the
</em><br>
<em>&gt; performance noise floor. :^)
</em><br>
<em>&gt;
</em><br>
<p>Fair call.. hee hee.
<br>
<p><em>&gt;
</em><br>
<em>&gt; &gt; I'm really happy with the current state of the Microsoft OSes, although
</em><br>
I
<br>
<em>&gt; &gt; wish they could finally drop the 9x kernel. They're good to program on.
</em><br>
They
<br>
<em>&gt; &gt; do lots of great stuff for you.
</em><br>
<em>&gt;
</em><br>
<em>&gt;
</em><br>
<em>&gt; This really depends on what kind of programming you are doing.  Some of
</em><br>
<em>&gt; the low-level stuff in those OSes are really pretty awful.  The APIs are
</em><br>
<em>&gt; far too rich (and broken in some fashion a third of the time), and there
</em><br>
<em>&gt; are way too many odd and complicated side effects.   Look at the thread
</em><br>
<em>&gt; APIs/model on NT if you want an example of a diseased design and
</em><br>
<em>&gt; implementation.  I've done parallel development on Windows NT and Unix; I
</em><br>
<em>&gt; spent far more time fscking with the Windows specific code than the Unix
</em><br>
<em>&gt; specific code because there were a lot more things that could go wrong.
</em><br>
<em>&gt; The beauty of Unix is that it *doesn't* try and do a lot of great stuff
</em><br>
<em>&gt; for you.
</em><br>
<p>Yep, I think writing low level stuff on Windows can be painful.
<br>
<p>But, to be fair, there's a lot more of the high level stuff. For instance,
<br>
I've had to do some pretty tight multithreading work myself lately, writing
<br>
free threaded COM objects. Fire up Delphi, yet again, and use the
<br>
TMultiReadExclusiveWrite object; it's stupidly simple to take care of the
<br>
most common cases, without doing something dumb like using a mutex. Leaves
<br>
you free to spend time debugging the really evil stuff.
<br>
<p>The basic windows threading stuff is pretty weird though.
<br>
<p>Emlyn
<br>
<p><!-- body="end" -->
<hr noshade>
<ul>
<!-- next="start" -->
<li><strong>Next message:</strong> <a href="1998.html">Samantha Atkins: "Re: Cyborgia"</a>
<li><strong>Previous message:</strong> <a href="1996.html">Emlyn: "Re: Extro IT Techies list?"</a>
<li><strong>In reply to:</strong> <a href="1974.html">James Rogers: "Re: Programming project required"</a>
<!-- nextthread="start" -->
<li><strong>Next in thread:</strong> <a href="2006.html">James Rogers: "Re: Programming project required"</a>
<li><strong>Reply:</strong> <a href="2006.html">James Rogers: "Re: Programming project required"</a>
<!-- reply="end" -->
<li><strong>Messages sorted by:</strong> 
<a href="date.html#1997">[ date ]</a>
<a href="index.html#1997">[ thread ]</a>
<a href="subject.html#1997">[ subject ]</a>
<a href="author.html#1997">[ author ]</a>
</ul>
<!-- trailer="footer" -->
<hr noshade>
<p>
<small>
<em>
This archive was generated by <a href="http://www.hypermail.org/">hypermail 2b30</a> 
: <em>Mon May 28 2001 - 09:56:21 MDT</em>
</em>
</small>
</body>
</html>
