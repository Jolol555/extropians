<!-- received="Thu Jun 10 15:38:34 1999 MDT" -->
<!-- sent="Thu, 10 Jun 1999 14:35:25 -0700 (PDT)" -->
<!-- name="Eugene Leitl" -->
<!-- email="eugene.leitl@lrz.uni-muenchen.de" -->
<!-- subject="Re: COMP: Moore's Law" -->
<!-- id="14176.9133.880923.735797@lrz.de" -->
<!-- inreplyto="929017556.8146.193.133.230.33@unicorn.com" -->
<!-- version=1.10, linesinbody=119 -->
<html><head><title>extropians: Re: COMP: Moore's Law</title>
<meta name=author content="Eugene Leitl">
<link rel=author rev=made href="mailto:eugene.leitl@lrz.uni-muenchen.de" title ="Eugene Leitl">
</head><body>
<h1>Re: COMP: Moore's Law</h1>
Eugene Leitl (<i>eugene.leitl@lrz.uni-muenchen.de</i>)<br>
<i>Thu, 10 Jun 1999 14:35:25 -0700 (PDT)</i>
<p>
<ul>
<li> <b>Messages sorted by:</b> <a href="date.html#3586">[ date ]</a><a href="index.html#3586">[ thread ]</a><a href="subject.html#3586">[ subject ]</a><a href="author.html#3586">[ author ]</a>
<!-- next="start" -->
<li><a href="3587.html">[ Next ]</a><a href="3585.html">[ Previous ]</a>
<b>In reply to:</b> <a href="3512.html">mark@unicorn.com</a>
<!-- nextthread="start" -->
</ul>
<!-- body="start" -->

<p>
mark@unicorn.com writes:

<p>
<a href="3512.html#3586qlink1"> &gt; &gt;physics itself. Let's shift the complexity load to the software, </a><br>
<i> &gt; &gt;where it belongs.</i><br>
<i> &gt; </i><br>
<i> &gt; Even with a factor of ten slowdown compared to hardware?</i><br>

<p>
<a name="3648qlink1"><a name="3613qlink1">Mapping an algorithm into reecofigurable hardware is *faster* than
doing it all-purpose hardware, unless you can have a silicon 
foundry within your computer which can churn out new dedicated
ASICs at a MHz rate.</a> With reconfigurable architectures, you swap 
out virtual circuitry, not code.<a name="3648qlink2"> In fact reconfigurable hardware 
allows the creation of very dynamic, hyperactive machines
with unified data/code, the most efficient things theoretically
possible.</a> These things are very new, so even academia doesn't 
quite know how to tackle them yet. You certainly can't go Darwin 
in machina (the next thing after OOP) without them.</a>
 
<p>
<a href="3512.html#3586qlink2"> &gt; No, I was pointing out that Intel have been able to keep putting out new,</a><br>
<i> &gt; faster CPUs at a tremendous rate by reusing as much of their old design</i><br>
<i> &gt; as possible, rather than trying to come up with brand-new architectures;</i><br>
<i> &gt; when they try that -- with Merced, for example -- they fail. Whether the</i><br>
<i> &gt; chips themselves are any good is a completely different matter.</i><br>
 
<p>
Merced is a yet another 64 bit CPU. It is not particularly innovative, 
and it has been mostly designed by HP, not Intel.
 
<p>
<a href="3512.html#3586qlink3"> &gt; That's precisely my point; new technologies tend to take longer to build</a><br>
<i> &gt; and cost more... and that's getting worse.</i><br>
 
<p>
What makes it worse: a widespread low-risk attutude, gaining
ground. Of course it is these global technology stalls, which allow
dramatic revolutionary bursts.<a name="3648qlink3"> Essentially, we haven't seen a single 
revolution in computing yet since 1940s.</a>

<p>
<a href="3512.html#3586qlink4"> &gt; &gt;Oh, but there is. These gate delays add up after a while. One needs to </a><br>
<i> &gt; &gt;streamline/radically simplify the architecture to go to higher clock</i><br>
<i> &gt; &gt;rates. Structure shrink alone can't do it forever, you know.</i><br>
<i> &gt; </i><br>
<i> &gt; Yes, but there's still plenty of room in the 80x86 architecture, and they</i><br>

<p>
The 80x86 architecture gets mostly emulated, these days. I'm really
looking forward to what Transmeta is going to produce.

<p>
<a href="3512.html#3586qlink5"> &gt; could bolt on a 64-bit kludge just like the prior 32-bit kludge. The main</a><br>
<i> &gt; aim of Merced and the Camino chip seems to be locking people into a</i><br>
<i> &gt; proprietary Intel architecture so they can eliminate competition and boost</i><br>
<i> &gt; profits, not any essential technical improvements.</i><br>
 
<p>
<a name="3648qlink4">Of course. The essence of Wintel's success. What I don't understand is 
why after all these years people are still buying it, hook and sinker.</a>

<p>
<a href="3512.html#3586qlink6"> &gt; &gt;There is no need to go dedicated. If there are hundreds or thousands</a><br>
<i> &gt; &gt;identical CPUs in each desktop there is sufficient horsepower to do </i><br>
<i> &gt; &gt;anything in software.</i><br>
<i> &gt; </i><br>
<i> &gt; Why pay for hundreds of expensive CPUs if you can do the same job with one</i><br>
<i> &gt; CPU and nine dedicated support chips?</i><br>
 
<p>
<a name="3648qlink5">Why paying for one expensive, legacy-ballast CPU and invest in nine 
others hideously complex designs (possibly more complex than the CPU 
itself), each requiring individual resources on the fab if you 
could churn out ~500-1000 CPUs for roughly $500 production costs?</a>

<p>
<a href="3512.html#3586qlink7"> &gt; &gt;God, we can do embedded RAM now. </a><br>
<i> &gt; </i><br>
<i> &gt; But it's very hard to do anything useful with embedded RAM because any</i><br>
<i> &gt; reasonable amount bloats the die size so much. My graphics card has 32MB</i><br>

<p>
That's perhaps because people have a strange notion of what is a reasonable
amount.<a name="3648qlink6"> You can implement a pretty frisky 32 bit CPU core plus networking 
in ~30 kTransistors, and I guess have semiquantitive die yield assuming 
1 MBit grains.</a> Since you can fit a nanokernel OS in 4..12 kBytes,
especially if using threaded code (which requires a bi-stack
architecture -- since the shallow stacks are part of the CPU there is
context switch overhead). Of course few people are comfortable with a
type of coding where subroutine calls contribute to &gt;&gt;20% of all
instructions. Now assume programming in an asychronous message-passing 
OOP model with average object size of a few hundred bytes and hard
memory grains of about a MBit, and see why seasoned programmers are
having a problem with that.

<p>
I have no idea how that CPU architecture scales to 1 kBit bus, but I
strongly guess it does it roughly linearly.

<p>
<a href="3512.html#3586qlink8"> &gt; of RAM; you're not going to fit that into a single chip with a graphics</a><br>
<i> &gt; controller that already has close to ten million transistors and get any</i><br>
<i> &gt; kind of affordable yield.  Plus, of course, once you've built your chip</i><br>
<i> &gt; with 32MB of RAM you can't then expand it without replacing the entire</i><br>
<i> &gt; chip.</i><br>
 
<p>
That's another reason people don't do it: because they operate in the
context of unvoiced assumptions. Sony's design uses 4 MByte grains, 
which is hard at the edge of feasibility, imo. If I was going to build 
a rendering engine, I'd distribute it either by bitplanes or do a display
mosaic.<a name="3648qlink7"> Engines look very differently if you simultaneously operate on 
an entire screen line, or do things the voxel way.</a>

<p>
<a href="3512.html#3586qlink9"> &gt; &gt;There is a lot of silicon</a><br>
<i> &gt; &gt;real estate out there on these 300 mm wafers. And quantitive yield can </i><br>
<i> &gt; &gt;do wonders to prices.</i><br>
<i> &gt; </i><br>
<i> &gt; You should really talk to the people who've tried WSI before making claims</i><br>
<i> &gt; as to how wonderful it's going to be. The only company I know of who ever</i><br>
<i> &gt; did it are Anamartic, and they had a hell of a time making it work; do they</i><br>
<i> &gt; even exist anymore?</i><br>

<p>
The processes allowing RAM/logic integration are brand new, and thus
currently accessible only to major players. There is no way how a
small company could go WSI and succeed, also consider that you
couldn't sell such architectures. You could do emulate a legacy system 
on them, but it would be no faster or slower due to the intrinsically
sequential nature of legacy systems.

<p>
<a name="3648qlink8">The reason's why we don't have WSI yet are mostly not technical. It is 
because people don't want to learn.
</a>
 
<p>
<i> &gt;     Mark</i><br>
<!-- body="end" -->
<p>
<ul>
<!-- next="start" -->
<li><a href="3587.html">[ Next ]</a><a href="3585.html">[ Previous ]</a>
<b>In reply to:</b> <a href="3512.html">mark@unicorn.com</a>
<!-- nextthread="start" -->
</ul>
</body></html>
