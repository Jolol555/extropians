<!-- received="Thu Aug 14 12:50:20 1997 MDT" -->
<!-- sent="Thu, 14 Aug 1997 13:44:51 -0400 (EDT)" -->
<!-- name="YakWaxx@aol.com" -->
<!-- email="YakWaxx@aol.com" -->
<!-- subject="COMP: Software and Operating Systems [user-centricity]" -->
<!-- id="9707148715.AA871588141@ccmgate.platinum.com" -->
<!-- inreplyto="" -->
<title>extropians: COMP: Software and Operating Systems [user-centricity]</title>
<h1>COMP: Software and Operating Systems [user-centricity]</h1>
<i>YakWaxx@aol.com</i><br>
<i>Thu, 14 Aug 1997 13:44:51 -0400 (EDT)</i>
<p>
<ul>
<li> <b>Messages sorted by:</b> <a href="date.html#1912">[ date ]</a><a href="index.html#1912">[ thread ]</a><a href="subject.html#1912">[ subject ]</a><a href="author.html#1912">[ author ]</a>
<!-- next="start" -->
<li> <b>Next message:</b> <a href="1913.html">E. Shaun Russell: "Re: self-transformation"</a>
<li> <b>Previous message:</b> <a href="1911.html">YakWaxx@aol.com: "Re: Everett"</a>
<!-- nextthread="start" -->
<!-- reply="end" -->
</ul>
<hr>
<!-- body="start" -->
My original 'rant' about _making the ability to create software an intrinsic<br>
part of any operating system_ failed to get my point across, so in my usual<br>
persistent manner. Here I go again:<br>
<p>
We've had network-centricity, document-centricity, web-centricity, now it's<br>
time for some user-centric computing.  Some people use the term user-centric<br>
for describing there attempts at user interface design, but it goes much<br>
further than that.  User-centric computing, in short, means that the user<br>
creates everything on the computer.  They don't create it in the traditional<br>
hard-coding sense; they create it in a multitude of ways.  Whenever a user<br>
interacts with a computer they are no longer using an application; they are<br>
creating objects, documents and agents.<br>
<p>
All this creating happens inside the 'software environment'.  The software<br>
environment contains everything needed to establish network connections, send<br>
and receive information, create object interactions, display multimedia and<br>
search for information.  When a user creates objects (which essentially make<br>
up tools, documents and agents) they are doing so through direct<br>
manipulation.  Direct manipulation use to mean having to understand the core<br>
computer components, but just as you don't have to understand quantum physics<br>
to move a teacup, you don't have to program C++ to create objects and object<br>
interactions.  What this means is - when you write a letter, you are no<br>
longer typing in a word-processor, you are adding letter objects (or ink) to<br>
a page object (or paper).  This has advantages, not only does it model real<br>
life, it also means I can add paint to my page, or hyperlink, or anything<br>
else.  No one programmed this in the traditional sense; it's just a fact of<br>
life that inks stay on paper!<br>
<p>
With this model come distinct advantages in I/O independence, media<br>
independence and artificial intelligence.  I/O independence is helped because<br>
it doesn't matter whether you're using a pen, keyboard or voice, they'll all<br>
write on any document object (necessary pen and keyboard interface<br>
information will be kept in the pen or keyboard).  It also allows for<br>
switching between media types and the creation of multimedia interfaces using<br>
intelligent media (media that programs itself for different situations,<br>
creating user/situation-specific interfaces).  Most importantly, this high<br>
level abstract programming environment helps AI as well as the user - it<br>
allows the artificial intelligence to work with objects that have meaning to<br>
both it and the user.<br>
<p>
An early (and failed) attempt at some user-centricity was the original<br>
version of HTML.  Older HTML commands are &lt;quote&gt; and &lt;small&gt;.  This is<br>
because font sizes and colours were to be defined by the user.  This approach<br>
failed because the web browser was not advanced enough to create a good<br>
multimedia interface and because publishers wanted more control.  It is not<br>
yet possible to create a truly user-centric computer, but we can start moving<br>
in the right direction.  Making the ability to program applications as<br>
in-built as the ability run them will open up many possibilities<br>
(particularly in the business sector).  The advent of Aspect Oriented<br>
Programming (AOP), component software and real-time aspect weavers will also<br>
improve user-centricity.<br>
<p>
I'm in the process of designing a user-centric software environment for rapid<br>
application design, prototyping and real-world interactions (making objects<br>
that co-exist in the real world and the software environment).  Eventually<br>
I'll make a home version and crush Bills mighty empire, but that's for<br>
another day…<br>
<p>
--Wax<br>
<p>
P.S. I just realised that if I succeed in creating my OS.  I'll not only<br>
destroy Microsoft, but *every* software company!  How's that for a monopoly!<br>
<!-- body="end" -->
<hr>
<p>
<ul>
<!-- next="start" -->
<li> <b>Next message:</b> <a href="1913.html">E. Shaun Russell: "Re: self-transformation"</a>
<li> <b>Previous message:</b> <a href="1911.html">YakWaxx@aol.com: "Re: Everett"</a>
<!-- nextthread="start" -->
<!-- reply="end" -->
</ul>
