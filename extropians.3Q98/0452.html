<!-- received="Wed Jul  8 20:44:41 1998 MDT" -->
<!-- sent="Wed, 08 Jul 1998 22:43:38 -0400" -->
<!-- name="Dan Clemmensen" -->
<!-- email="Dan@Clemmensen.ShireNet.com" -->
<!-- subject="Re: Moore's law" -->
<!-- id="35A42E5A.C92C5272@clemmensen.shirenet.com" -->
<!-- inreplyto="Moore's law" -->
<!-- version=1.10, linesinbody=87 -->
<html><head><title>extropians: Re: Moore's law</title>
<meta name=author content="Dan Clemmensen">
<link rel=author rev=made href="mailto:Dan@Clemmensen.ShireNet.com" title ="Dan Clemmensen">
</head><body>
<h1>Re: Moore's law</h1>
Dan Clemmensen (<i>Dan@Clemmensen.ShireNet.com</i>)<br>
<i>Wed, 08 Jul 1998 22:43:38 -0400</i>
<p>
<ul>
<li> <b>Messages sorted by:</b> <a href="date.html#452">[ date ]</a><a href="index.html#452">[ thread ]</a><a href="subject.html#452">[ subject ]</a><a href="author.html#452">[ author ]</a>
<!-- next="start" -->
<li><a href="0453.html">[ Next ]</a><a href="0451.html">[ Previous ]</a>
<b>In reply to:</b> <a href="0414.html">Michael Nielsen</a>
<!-- nextthread="start" -->
<b>Next in thread:</b> <a href="0642.html">Michael Nielsen</a>
</ul>
<!-- body="start" -->

<p>
<a name="0642qlink1">Michael Nielsen wrote:
<br>
<i>&gt; </i><br>
<i>&gt; </i><br>
<a href="0414.html#0452qlink1">&gt; I may as well state one of my main interests in this: whether we'll ever</a><br>
<i>&gt; have enough computational power to set up a good "breeding ground"</i><br>
<i>&gt; for AIs -- an artificial environment optimized to produce artifical</i><br>
<i>&gt; intelligence by means of selective pressure.  Using proctonumerology, I'd</i><br>
<i>&gt; guess a figure of about 10^40 operations ought to be enough.</i><br>
<i>&gt; </i><br>
I haven't a clue. What does Moravic say, and should we believe him? Are
these operations per second?</a>

<p>
<a href="0414.html#0452qlink2">&gt; &gt; &gt; On Fri, 26 Jun 1998, Dan Clemmensen wrote:</a><br>
<i>&gt; &gt; Addressing in a nanomechanical system occurs only as part of a read or write</i><br>
<i>&gt; &gt; operation. When no I/O is occurring, no energy is dissipated. Dissipation per</i><br>
<i>&gt; &gt; access depends on the size of the memory, O(logN) for random access,</i><br>
<i>&gt; &gt; which is negligible and is mitigated further by caching.</i><br>
<i>&gt; </i><br>
<a name="0642qlink2"><i>&gt; I don't know how the proposed nanomechanical schemes work. In</i><br>
<i>&gt; commonly used electronic schemes, I believe that the depth is O(log N) for</i><br>
<i>&gt; random access, but the number of operations is O(N log N), at least in the</i><br>
<i>&gt; schemes I'm familiar with.  Are you absolutely sure that the number of</i><br>
<i>&gt; operations in a nanomechanical addressing systems is O(log N)?</i><br>

<p>
Nope, I made it up as I went along, mentally designing the system on the
fly and probably messing it up severely. I now strongly suspect that between
the two of us we are thinking about three different things: depth with O(log N)
complexity, number of gates needed with O(N), and energy dissipation, which will
depend strongly implementation, with 0(N) required for a minimized depth (i.e.,
depth of 2, fastest algorithm) and O(log N) required for a slow but energy-efficient
approach with one address bit per clock.
<br>
<i>&gt;  </i><br>
<a href="0414.html#0452qlink3">&gt; Okay.  I am, I suppose, trying to see how far we can push the 3d</a><br>
<i>&gt; architecture idea at this point.  We already do it to some extent -- I am</i><br>
<i>&gt; told that 20 layers is not that uncommon in a chip -- but I would like to</i><br>
</a>
<i>&gt; know how much further we can go; can we drop the 2020 date?</i><br>
<i>&gt; </i><br>
Sure, It's more fun. 
<br>
 &gt; 
<br>
<a name="0642qlink3"><a href="0414.html#0452qlink4">&gt; &gt; By contrast, you raise the issue of error correction.</a><br>
<i>&gt; &gt; However, even very powerful ECC schemes require less than doubling the amount</i><br>
<i>&gt; &gt; of volume needed to store a word.</i><br>
<i>&gt; </i><br>
<i>&gt; That's not really true.  To do fault-tolerant computation the best known</i><br>
<i>&gt; overhead, so far as I know, goes polylogarithmically in the size of the</i><br>
<i>&gt; computation, with some (fairly large) constant factor in front of the</i><br>
<i>&gt; first term in the polylog factor.</i><br>
<i>&gt; </i><br>
Here are are again shifting back and forth between ECC for storage and ECC for
</a>computation.<a name="0642qlink4"> I was addressing storage, wherein we are not using reversable
logic. For storage, as I recall the Hamming distance goes up rapidly with a modest
increase in ECC bits. In conjunction with cashing, the bulk memory words
subject to ECC will be long. The nuber of ECC bits goes up O(log N) with
word length and linearly (?) with the number of errored bits that can be corrected.</a>

<p>
<a href="0414.html#0452qlink5">&gt; The error correction schemes you are talking about will buy you a little,</a><br>
<i>&gt; but ultimately, fixing one bit errors goes only a tiny way to fixing the</i><br>
<i>&gt; error problem.  Much more powerful error correction techniques are</i><br>
<i>&gt; needed to really solve the error problem, unless, as in today's</i><br>
<i>&gt; computers, you have an incredibly low fundamental error rate.  Even</i><br>
<i>&gt; then, there's a real question of how many operations you want to do.  If</i><br>
<i>&gt; you "only" want to do 10^{17} operations, then error rates of about</i><br>
<i>&gt; 10^{-17} are fine -- which is why today's computers don't use error</i><br>
<i>&gt; correctyion.  Presumably, for AI we would like to do far more operations</i><br>
<i>&gt; than that -- on the order of 10^{30} does not seem unreasonable.</i><br>
<i>&gt; </i><br>
<i>&gt; Assuming a fundamental error rate of about 10^{-5} for reversible</i><br>
<i>&gt; computation, that implies a heavy error correction overhead.  Doing a</i><br>
<i>&gt; calculation of how much overhead for error correction would be required</i><br>
<i>&gt; would take quite a while, but it's safe to say that most of the work going</i><br>
<i>&gt; on in the computer would actually be error correction, not computation.</i><br>
<i>&gt; </i><br>
You are now discussing error correction during logic operations rather than
storage, and you are correct as far as I know. Brute-force correction for
logic has been done by "voting", where three identical circuits are implemented
together with comparison logic. If the comparison logic is about the same complexity
as the original circuit, the entire ECC scheme is four times as complex and this
ony defends against a one-bit error (sort of.) A five-way vote defends against
2 errors by roughly doubling the complexity again.

<p>
<a name="0642qlink5"><a href="0414.html#0452qlink6">&gt; If I can find the time, I'll try to look up some of the papers analyzing</a><br>
<i>&gt; errors in reversible computation.  As I recall, there were a few in the</i><br>
<i>&gt; early 80s, which I've never read.</i><br>
There was at east one paper delivered at the 1997 foresight conference:
<p>
      <a href="http://WWW.FORESIGHT.ORG/Conferences/MNT05/Abstracts/Frakabst.html">http://WWW.FORESIGHT.ORG/Conferences/MNT05/Abstracts/Frakabst.html</a>
That deals with reversible computation.
</a>
<!-- body="end" -->
<p>
<ul>
<!-- next="start" -->
<li><a href="0453.html">[ Next ]</a><a href="0451.html">[ Previous ]</a>
<b>In reply to:</b> <a href="0414.html">Michael Nielsen</a>
<!-- nextthread="start" -->
<b>Next in thread:</b> <a href="0642.html">Michael Nielsen</a>
</ul>
</body></html>
