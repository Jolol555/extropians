<!-- received="Sat Jul 10 22:18:41 1999 MDT" -->
<!-- sent="Sat, 10 Jul 1999 23:16:34 -0500" -->
<!-- name="Billy Brown" -->
<!-- email="ewbrownv@mindspring.com" -->
<!-- subject="RE: Human minds on Windows(?)" -->
<!-- id="NDBBLBGGEJLACCFCPNINCECMCBAA.ewbrownv@mindspring.com" -->
<!-- inreplyto="002a01becae6$21510800$825295c1@filth" -->
<!-- version=1.10, linesinbody=65 -->
<html><head><title>extropians: RE: Human minds on Windows(?)</title>
<meta name=author content="Billy Brown">
<link rel=author rev=made href="mailto:ewbrownv@mindspring.com" title ="Billy Brown">
</head><body>
<h1>RE: Human minds on Windows(?)</h1>
Billy Brown (<i>ewbrownv@mindspring.com</i>)<br>
<i>Sat, 10 Jul 1999 23:16:34 -0500</i>
<p>
<ul>
<li> <b>Messages sorted by:</b> <a href="date.html#511">[ date ]</a><a href="index.html#511">[ thread ]</a><a href="subject.html#511">[ subject ]</a><a href="author.html#511">[ author ]</a>
<!-- next="start" -->
<li><a href="0512.html">[ Next ]</a><a href="0510.html">[ Previous ]</a>
<b>In reply to:</b> <a href="0480.html">Bryan Moss</a>
<!-- nextthread="start" -->
</ul>
<!-- body="start" -->

<p>
Bryan Moss wrote:
<br>
<a href="0480.html#0511qlink1">&gt; The thing I don't understand is *when* you do this count.  Do the</a><br>
<i>&gt; programmers just keep a log of every mistake they make?  Do you count your</i><br>
<i>&gt; defects up after the product ships.  For instance, in this e-mail do I</i><br>
count
<br>
<a href="0480.html#0511qlink2">&gt; just the errors per line when I send it or while I'm typing (I just went</a><br>
to
<br>
<a href="0480.html#0511qlink3">&gt; type 'while' and started with an 'h' - 'started' just went through about</a><br>
<i>&gt; three different erroneous phases - 'phases' just came out as 'pahses' - I</i><br>
<i>&gt; just misspelled (correctly) the misspelling of 'phases'... and so on)?  In</i><br>
<i>&gt; short, when do you stop correcting and start counting?</i><br>

<p>
Think in terms of team development.  A programmer gets assigned a piece of
the project, writes code for it, does whatever personal testing he feels
necessary, then checks it into the central code repository (which is
presumeably some sort of version-control package).  Once he checks it in for
the first time, anything that anyone ever finds wrong with it counts as an
error.

<p>
<a href="0480.html#0511qlink4">&gt; The UI could handle any possibility but as I said the programmer would</a><br>
have
<br>
<a href="0480.html#0511qlink5">&gt; to be removed from the interface.  You would have to use a standardised</a><br>
<i>&gt; document object model so that, in the true spirit of Opendoc, components</i><br>
<i>&gt; acted on documents.  The UI would be a challenge for sure, but it's about</i><br>
<i>&gt; time someone did something in UI-design rather than just speculating about</i><br>
<i>&gt; the wonders of speech-recognition.  (Won't speech recognition interfaces</i><br>
<i>&gt; require this sort of component-based model anyway?)</i><br>

<p>
The easy approach to this has already been done (see the MS Office features
for imbedding ActiveX objects in a document, for example).  However, that
doesn't let the components modify each other's data.

<p>
For seamless integration you need to have a universal data format that all
possible components can read.  That's fine for features we've already
thought of, but the first truly innovative product that comes along will
need some kind of data that we didn't allow for in the spec.  So far, I
haven't heard of a solution to that problem.

<p>
<a href="0480.html#0511qlink6">&gt; This requires self-organising interfaces.  Self-organising interfaces</a><br>
<i>&gt; require semantics-rich documents.  Semantics-rich documents require</i><br>
<i>&gt; context-aware user environments.  Context-aware user environments require</i><br>
<i>&gt; self-organising interfaces.</i><br>
and
<br>
<a href="0480.html#0511qlink7">&gt; It's worth trying, I think.  What I'd like to see is a test-bed for this</a><br>
and
<br>
<a href="0480.html#0511qlink8">&gt; other ideas.  A semantics-rich context-aware self-organising user</a><br>
<i>&gt; environment with a hyperlinking file system.  I've got it all worked out,</i><br>
<i>&gt; now all I need is an army of programmers with too much time on</i><br>
<i>&gt; their hands.</i><br>

<p>
And you were concerned about code bloat in existing systems?  You haven't
seen anything yet!  Yes, this could probably be done with enough effort, but
the result would expend vast amounts of space on meta-data, adaptive code,
and low-order AI software.  Since it would need to be an OS function, that
means we get to add even more millions of lines of code to Windows (and it
will be really, really trouble-prone code, at that).

<p>
Even then it would never work very well.  We can make auto-generating user
interfaces, but we can't make an AI that knows how to make it useable.  Odds
are we would end up back in dialog box hell, or some close variant thereof.

<p>
Billy Brown, MCSE+I
<br>
ewbrownv@mindspring.com
<!-- body="end" -->
<p>
<ul>
<!-- next="start" -->
<li><a href="0512.html">[ Next ]</a><a href="0510.html">[ Previous ]</a>
<b>In reply to:</b> <a href="0480.html">Bryan Moss</a>
<!-- nextthread="start" -->
</ul>
</body></html>
