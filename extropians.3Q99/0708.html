<!-- received="Thu Jul 15 12:07:07 1999 MDT" -->
<!-- sent="Thu, 15 Jul 1999 13:07:14 -0500" -->
<!-- name="Billy Brown" -->
<!-- email="ewbrownv@mindspring.com" -->
<!-- subject="RE: COMP:WARS: RE: Software/Hardware Architectures" -->
<!-- id="01BECEC2.F76DAD50.ewbrownv@mindspring.com" -->
<!-- inreplyto="" -->
<!-- version=1.10, linesinbody=157 -->
<html><head><title>extropians: RE: COMP:WARS: RE: Software/Hardware Architectures</title>
<meta name=author content="Billy Brown">
<link rel=author rev=made href="mailto:ewbrownv@mindspring.com" title ="Billy Brown">
</head><body>
<h1>RE: COMP:WARS: RE: Software/Hardware Architectures</h1>
Billy Brown (<i>ewbrownv@mindspring.com</i>)<br>
<i>Thu, 15 Jul 1999 13:07:14 -0500</i>
<p>
<ul>
<li> <b>Messages sorted by:</b> <a href="date.html#708">[ date ]</a><a href="index.html#708">[ thread ]</a><a href="subject.html#708">[ subject ]</a><a href="author.html#708">[ author ]</a>
<!-- next="start" -->
<li><a href="0709.html">[ Next ]</a><a href="0707.html">[ Previous ]</a>
<b>In reply to:</b> <a href="0666.html">Billy Brown</a>
<!-- nextthread="start" -->
</ul>
<!-- body="start" -->

<p>
Eugene Leitl [SMTP:eugene.leitl@lrz.uni-muenchen.de] wrote:
<br>
<a href="0691.html#0708qlink1">&gt; I could go on for a long time but (I hope) my</a><br>
<i>&gt; point is nauseatingly clear: it's a big ball of yarn buried in</i><br>
<i>&gt; yonder tarpit, and requires a whole lotta muscle to haul it out.</i><br>

<p>
OK, you've convinced me to reserve judgement until someone actually builds 
one.  It still sounds like a lot of arm-waving to me, but I'll admit that 
designing parallel processing hardware isn't one of my areas of expertise.

<p>
<a href="0691.html#0708qlink2">&gt; It might be logical, yet there is plenty of reasons to blame</a><br>
<i>&gt; widespread "investment protection" attitude for it. Investment</i><br>
<i>&gt; protection is great for local optimization, but is deletorious</i><br>
<i>&gt; even on the middle run. And is really really desastrous on the</i><br>
<i>&gt; long run.</i><br>

<p>
What exactly is the alternative?  Write software optimized for something 
that doean't exist?  If you want to blame Intel and IBM for not innovating 
faster, feel free, but don't blame the software companies for not inventing 
new hardware.

<p>
<a href="0691.html#0708qlink3">&gt; Alas, woefully, free markets seem to fail here miserably. Technical</a><br>
<i>&gt; excellence has very little to do with market permeation. Deja vu deja</i><br>
<i>&gt; vu deja vu deja vu.</i><br>

<p>
Technical excellence according to who?  A superior product is one that has 
the combination of features, price and performance that the customers 
actually want.  A competing product that has a really elegant 
implementation, but lacks basic functionality that virtually all users 
want, is not superior in any meaningful sense.

<p>
Free markets efficiently produce products that people want to buy.  If the 
results don't fit your concept of what good software is, the first thing 
you should question is your own concept of what the goal should be. 
 Claiming that the market has missed some perfect opportunity that only you 
can see is a favored tactic of those whose ideas don't work in the real 
world.

<p>
<a href="0691.html#0708qlink4">&gt; There is really no fundamental difference between x86 family, PowerPC,</a><br>
<i>&gt; diverse MIPSen or Alpha. They all suck.</i><br>

<p>
My point was that big software vendors are willing to spend substantial 
amounts of money re-writing their products for a platform that is only 
marginally faster than the x86 family.  We should therefore expect that 
they would be even more eager if a machine 100 or 1,000 times faster came 
along.

<p>
<a href="0691.html#0708qlink5">&gt; As to Microsoft, I guess all the intelligence cream they've been</a><br>
<i>&gt; skimming off academia/industry for years &amp; all these expenses in R&amp;D</i><br>
<i>&gt; will eventually lead somewhere. Right now, what I see doesn't strike</i><br>
<i>&gt; me as especially innovative or even high-quality, no Sir. Particularly</i><br>
<i>&gt; regarding ROI in respect to all these research gigabucks pourin'</i><br>
<i>&gt; in. Administratory hydrocephalus begets administratory hydrocephalus.</i><br>

<p>
Do we really need to do the 'I hate Microsoft' thing here?  I suggest we 
call a truce on the issue, since experience shows that no one ever changes 
their mind about it as a result of argument.

<p>
<a href="0666.html#0708qlink6">&gt;  &gt; have been writing 100% object-oriented, multithreaded code for several </a><br>
years
<br>
<a href="0666.html#0708qlink7">&gt;  &gt; now.  They use asynchronous communication anywhere there is a chance </a><br>
that it
<br>
<i>&gt;</i><br>
<a href="0691.html#0708qlink8">&gt; I hear you. It is still difficult to belive.</a><br>

<p>
I've worked with the code.  Things have been moving pretty fast in this 
area lately.

<p>
<a href="0666.html#0708qlink9">&gt;  &gt; towards designing applications to run distributed across multiple </a><br>
machines
<br>
<a href="0666.html#0708qlink10">&gt;  &gt; on a network, and this seems likely to become the standard approach </a><br>
for
<br>
<a href="0691.html#0708qlink11">&gt;  &gt; high-performance software in the near future.</a><br>
<i>&gt;</i><br>
<i>&gt; I know clustering is going to be big, and is eventually going to find</i><br>
<i>&gt; its way into desktops. It's still a back-assed way of doing things,</i><br>
<i>&gt; maybe smart RAM will have its say yet. If only Playstation 2 would be</i><br>
<i>&gt; already available, oh well. Marketplace will sure look different a</i><br>
<i>&gt; year downstream. Difficult to do any planning when things are so in</i><br>
<i>&gt; flux.</i><br>

<p>
Distributed applications aren't the same thing as clustering.  The idea now 
is that you run different parts of your app on different machines, so that 
the load can be distributed across a network of arbitrary size.  You end up 
with an arbitrarily large number of different 'types' of server, each doing 
a different job, and each of which can be implemented across one or more 
clusters.

<p>
<a href="0666.html#0708qlink12">&gt;  &gt; Regarding the Applicability of Parallelism</a><br>
<i>&gt;  &gt; The processes on a normal computer span a vast continuum between the</i><br>
<i>&gt;  &gt; completely serial and the massively parallel, but most of them cluster </i><br>
near
<br>
<a href="0666.html#0708qlink13">&gt;  &gt; the serial end of the spectrum.  Yes, you have a few hundred process </a><br>
in
<br>
<i>&gt;</i><br>
<a href="0691.html#0708qlink14">&gt; Says who.</a><br>
<i>&gt;</i><br>
<i>&gt;  &gt; memory on your computer at any given time, but only a few of them are</i><br>
<i>&gt;  &gt; actually doing anything.  Once you've allocated two or three fast CPUs </i><br>
(or a
<br>
<i>&gt;</i><br>
<a href="0691.html#0708qlink15">&gt; How would you know? I gave you a list of straightforward jobs my</a><br>
<i>&gt; machine could be doing right now. Sounds all very parallel to</i><br>
<i>&gt; me. Remember, there is a reason why I need to build a Beowulf.</i><br>

<p>
Says me.  I've worked with the innards of OS software long enough to know 
what is and isn't going on in there.  But if you don't believe me, you 
might want to take note of the fact that the CPU on a modern machine is 
usually below 10% utilization when you're running normal apps.  Even with 
everything loaded onto one processor, the system spends almost all of its 
time sitting around waiting for something to do.

<p>
Yes, your simulations are highly parallel.  It would therefore make sense 
to run them on some sort of parallel hardware.  However, they are a big 
exception to the general rule.  About 99.9% of all users never run anything 
that has enough parallelism to be worth the bother of re-coding.  Even 
where parallelism exists (i.e. server apps), the complexity of the 
operations the software performs is too high for the kind of system you 
want to see (making the objects 100% independant of each other would 
require making each of them much too big to fit on the processor nodes 
you're talking about).

<p>
<a href="0666.html#0708qlink16">&gt;  &gt; 2) You also can't get away from context switching.  Any reasonably </a><br>
complex
<br>
<a href="0666.html#0708qlink17">&gt;  &gt; task is going to have to be broken down into procedures, and each </a><br>
processor
<br>
<a href="0666.html#0708qlink18">&gt;  &gt; will have to call a whole series of them in order to get any usefull </a><br>
work
<br>
<a href="0666.html#0708qlink19">&gt;  &gt; done.  This isn't just an artifact of the way we currently write </a><br>
software,
<br>
<i>&gt;</i><br>
<a href="0691.html#0708qlink20">&gt; Untrue. You almost never have to switch context if you have 1 kCPUs to</a><br>
<i>&gt; burn. You only have to do this if you run out of the allocable CPU</i><br>
<i>&gt; heap (when the number of your objects exceed the number of your CPUs).</i><br>

<p>
It sounds like you've written so much 'do a few complex operations on a 
huge body of data'-type code that you've forgotten that the rest of the 
world doesn't work that way.

<p>
Yes, you could run that genome analysis program this way.  You could do the 
same thing with image filters, simple rendering engines, and a lot of other 
problems.  But that encompasses only a tiny fraction of the programming 
world.

<p>
Most software applies vast amounts of code to relatively small amounts of 
data.  In this case you have whole systems of relatively large objects with 
lots of internal procedures, all of which must interact with each other to 
get anything done.  Instantiating the objects on different CPUs simply 
substitutes inter-node messaging for some of your context switching, and 
doesn't help matters at all.  Many big problems, like evolutionary design 
and AI reasoning, have these characteristics, and they demand a very 
different kind of architecture than what you are proposing.

<p>
Billy Brown, MCSE+I
<br>
ewbrownv@mindspring.com
<!-- body="end" -->
<p>
<ul>
<!-- next="start" -->
<li><a href="0709.html">[ Next ]</a><a href="0707.html">[ Previous ]</a>
<b>In reply to:</b> <a href="0666.html">Billy Brown</a>
<!-- nextthread="start" -->
</ul>
</body></html>
