<!-- received="Wed Jul  7 22:55:07 1999 MDT" -->
<!-- sent="Thu, 8 Jul 1999 14:55:03 +1000 " -->
<!-- name="O'Regan, Emlyn" -->
<!-- email="Emlyn.ORegan@actew.com.au" -->
<!-- subject="RE: Human minds on Windows(?) (was Re: Web site up! (GUI vs. CLI)" -->
<!-- id="65FD40142926D011AAB208002BE22D3201C97631@mailcivic1.actew.oz.au" -->
<!-- inreplyto="Human minds on Windows(?) (was Re: Web site up! (GUI vs. CLI)" -->
<!-- version=1.10, linesinbody=106 -->
<html><head><title>extropians: RE: Human minds on Windows(?) (was Re: Web site up! (GUI vs. CLI)</title>
<meta name=author content="O'Regan, Emlyn">
<link rel=author rev=made href="mailto:Emlyn.ORegan@actew.com.au" title ="O'Regan, Emlyn">
</head><body>
<h1>RE: Human minds on Windows(?) (was Re: Web site up! (GUI vs. CLI)</h1>
O'Regan, Emlyn (<i>Emlyn.ORegan@actew.com.au</i>)<br>
<i>Thu, 8 Jul 1999 14:55:03 +1000 </i>
<p>
<ul>
<li> <b>Messages sorted by:</b> <a href="date.html#338">[ date ]</a><a href="index.html#338">[ thread ]</a><a href="subject.html#338">[ subject ]</a><a href="author.html#338">[ author ]</a>
<!-- next="start" -->
<li><a href="0339.html">[ Next ]</a><a href="0337.html">[ Previous ]</a>
<b>In reply to:</b> <a href="0062.html">Harvey Newstrom</a>
<!-- nextthread="start" -->
</ul>
<!-- body="start" -->



<p>
<i>&gt; ----------</i><br>
<a name="0417qlink1"><i>&gt; From: 	Billy Brown[SMTP:ewbrownv@mindspring.com]</i><br>
<a name="2803qlink1"><a href="0062.html#0338qlink1">&gt; Reply To: 	extropians@extropy.com</a><br>
<i>&gt; Sent:</a> 	Thursday, 8 July 1999 13:24</i><br>
<i>&gt; To: 	extropians@extropy.com</i><br>
</a><i>&gt; Subject: 	RE: Human minds on Windows(?) (was Re: Web site up! (GUI vs.</i><br>
<i>&gt; CLI))</i><br>
<i>&gt; </i><br>
<i>&gt; </i><br>
<i>&gt; &gt; &gt; CountZero &lt;count_zero@bigfoot.com&gt; said</i><br>
<i>&gt; &gt;</i><br>
<i>&gt; &gt; &gt; ... Windows (tm) ...,</i><br>
<i>&gt; &gt; &gt; is a bloated mess, likely impossible for any single human to</i><br>
<i>&gt; understand,</i><br>
<i>&gt; &gt; &gt; _it works_, it gives me what I want at the moment and I'm more than</i><br>
<i>&gt; &gt; &gt; willing to throw hardware at it as long as the hardware is cheap since</i><br>
<i>&gt; &gt; &gt; the alternative is to wait (possibly for a long time) to get the same</i><br>
<i>&gt; &gt; &gt; capabilities in properly optimized code.</i><br>
<i>&gt; &gt; &gt;</i><br>
<i>&gt; &gt; This is a *very* *very* scary thought.  Since we can expect the</i><br>
<i>&gt; &gt; hardware to keep getting cheaper at least through 2012 (when they</i><br>
<i>&gt; &gt; hit the five atom gate thickness limit), then probably transition</i><br>
<i>&gt; &gt; over to nanotech (whence comes 1 cm^3 nanocomputers) -- the implication</i><br>
<i>&gt; &gt; is that we will have an extended period in which to develop increasingly</i><br>
<i>&gt; &gt; sloppy code.</i><br>
<i>&gt; </i><br>
<a name="0355qlink1"><i>&gt; Actually, Microsoft's defects-per-LOC figures (the only comparison of code</i><br>
<i>&gt; quality that really tells you anything) are in the upper 30% of the</i><br>
<i>&gt; software</i><br>
</a><i>&gt; industry.  The reasons why their products often seem porely written have</i><br>
<i>&gt; nothing to do with code quality - their problems lie in other areas (such</i><br>
<i>&gt; as</i><br>
<i>&gt; user interface design).</i><br>
<i>&gt; </i><br>
<i>&gt; However, you have definitely hit on the single biggest challenge facing</i><br>
<i>&gt; the</i><br>
<i>&gt; software industry today.  Simply put, it is not possible for humans to</i><br>
<i>&gt; write</i><br>
<i>&gt; 100% defect-free code.  Faster computers allow you to tackle more</i><br>
<i>&gt; complicated problems, but that leads to ever-bigger programs.  As the</i><br>
<i>&gt; programs get bigger, more and more of your development effort gets</i><br>
<i>&gt; diverted</i><br>
<i>&gt; into getting the number of defects down to an acceptable level.</i><br>
<i>&gt; Eventually</i><br>
<i>&gt; you reach the point where every time you fix one bug you create another,</i><br>
<i>&gt; and</i><br>
<i>&gt; it becomes impossible to add new features to your program without breaking</i><br>
<i>&gt; old ones.</i><br>
<i>&gt; </i><br>
<i>&gt; Judging from what data are currently available, this effect comes into</i><br>
<i>&gt; play</i><br>
<i>&gt; when the number of human-generated instructions gets into the 10^7 - 10^8</i><br>
<i>&gt; LOC region.  High-level languages should therefore make it possible to</i><br>
<i>&gt; write</i><br>
<i>&gt; bigger programs (because each human-entered instruction generates a lot</i><br>
<i>&gt; more</i><br>
<i>&gt; machine code), but the level of abstraction in these programs is not</i><br>
<i>&gt; increasing very quickly at all.  If we want to actually be able to exploit</i><br>
<i>&gt; the processing power we're going to have in 10-20 years, we need to get to</i><br>
<i>&gt; work on this problem *now*, instead of sitting around pretending it</i><br>
<i>&gt; doesn't</i><br>
<i>&gt; exist.</i><br>
<i>&gt; </i><br>
<i>&gt; Billy Brown, MCSE+I</i><br>
<i>&gt; ewbrownv@mindspring.com</i><br>
<i>&gt; </i><br>
Software layering (or modularity) surely does a lot of work to combat this.
If you can build a layer of software that uses a lower level, adds value,
and is bug-free (possible with enough effort when working on a finite sized
level), you have firm ground on which to build. The only problem is that, as
you add layers, the replacement cost grows.

<p>
This is closely related to the higher-level language argument above, in that
each layer of services provides more functionality that the existing
languages can access, at increasing levels of abstraction. So your 3/4 GL
today looks a lot higher level than your 3/4 GL did 10 years ago. I would
argue that in some practical sense, abstraction is increasing strongly, just
not at the level of pure languages. Rather, the OS and all layers on top
must be included. Paradoxically, this means that as you get more "abstract",
you are also bound to more and more arbitrary technologies.

<p>
As the overall complexity grows in your total system, the number of layers
increases, which means that you are increasingly bound to the layers in
which you have already invested. This is because it would just take too much
time &amp; money to replace those layers. Once, you might have built your own OS
from scratch for a special purpose task. Now, not only are you usually bound
to a particular OS, you are bound to layers and layers of software on top of
that (ODBC? COM? Winsocks? X-many others).

<p>
The trend increases toward choosing an OS, a set of APIs, protocols,
protocols on protocols on protocols, and sticking with them. It's the only
way we can manage the complexity of our desired systems, and must become
more and more prevalent. This will lead to worse homogenisation of the IT
world, and more of the monoculture problems we are getting (catastrophic
effects from bugs, viruses, worms, crackers, monopolies, etc...)

<p>
What can we do to get on top of this?

<p>
Build AIs that can take over the job.

<p>
Then arm yourself for bear and head for the hills.

<p>
Emlyn
<!-- body="end" -->
<p>
<ul>
<!-- next="start" -->
<li><a href="0339.html">[ Next ]</a><a href="0337.html">[ Previous ]</a>
<b>In reply to:</b> <a href="0062.html">Harvey Newstrom</a>
<!-- nextthread="start" -->
</ul>
</body></html>
