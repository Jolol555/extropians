<!-- received="Thu Jul 15 02:36:12 1999 MDT" -->
<!-- sent="Thu, 15 Jul 1999 01:33:53 -0700 (PDT)" -->
<!-- name="Eugene Leitl" -->
<!-- email="eugene.leitl@lrz.uni-muenchen.de" -->
<!-- subject="COMP:WARS: RE: Software/Hardware Architectures" -->
<!-- id="14221.30558.105952.763012@lrz.de" -->
<!-- inreplyto="NDBBLBGGEJLACCFCPNINCEEJCBAA.ewbrownv@mindspring.com" -->
<!-- version=1.10, linesinbody=274 -->
<html><head><title>extropians: COMP:WARS: RE: Software/Hardware Architectures</title>
<meta name=author content="Eugene Leitl">
<link rel=author rev=made href="mailto:eugene.leitl@lrz.uni-muenchen.de" title ="Eugene Leitl">
</head><body>
<h1>COMP:WARS: RE: Software/Hardware Architectures</h1>
Eugene Leitl (<i>eugene.leitl@lrz.uni-muenchen.de</i>)<br>
<i>Thu, 15 Jul 1999 01:33:53 -0700 (PDT)</i>
<p>
<ul>
<li> <b>Messages sorted by:</b> <a href="date.html#691">[ date ]</a><a href="index.html#691">[ thread ]</a><a href="subject.html#691">[ subject ]</a><a href="author.html#691">[ author ]</a>
<!-- next="start" -->
<li><a href="0692.html">[ Next ]</a><a href="0690.html">[ Previous ]</a>
<b>In reply to:</b> <a href="0666.html">Billy Brown</a>
<!-- nextthread="start" -->
</ul>
<!-- body="start" -->

<p>
Billy Brown writes:
<br>
<a href="0666.html#0691qlink1"> &gt; I don't think we were really getting anywhere with the previous line of</a><br>
<i> &gt; responses, so I decided to try it again from the beginning.  Here goes:</i><br>
 
<p>
Yep, this has been also my impression. We do really seem to have
unresolvably different ways of seeing matters. Not that diversity is a
bad thing, but it sure turns tedious having to reiterate
things/sugarcoat them in different verbiage.
 
<p>
<a href="0666.html#0691qlink2"> &gt; Regarding Current Software</a><br>
<i> &gt; Current PC software is written for hardware that is actually in use, not</i><br>
<i> &gt; hypothetical designs that might or might not ever be built.  This is</i><br>
<i> &gt; perfectly logical, and I don't think it makes sense to blame anyone for it.</i><br>

<p>
<a name="0708qlink2">It might be logical, yet there is plenty of reasons to blame
widespread "investment protection" attitude for it. Investment
protection is great for local optimization, but is deletorious 
even on the middle run. And is really really desastrous on the 
long run. 
</a>

<p>
To name a few notorious perpetrators: Big Blue, Intel, Microsoft 
have been reserved a special circle in Dante's Hell. (At least 
in my private universion of it). 

<p>
<a href="0666.html#0691qlink3"> &gt; If a better architecture becomes available, we can expect ordinary market</a><br>
<i> &gt; forces to lead them to support it in short order (look at Microsoft's</i><br>

<p>
<a name="0708qlink3">Alas, woefully, free markets seem to fail here miserably. Technical
excellence has very little to do with market permeation. Deja vu deja
vu deja vu deja vu.
</a>

<p>
<a href="0666.html#0691qlink4"> &gt; efforts with regard to the only-marginally-superior Alpha chip, for</a><br>
<i> &gt; example).</i><br>
 
<p>
<a name="0708qlink4">There is really no fundamental difference between x86 family, PowerPC, 
diverse MIPSen or Alpha. They all suck.
</a>

<p>
<a href="0666.html#0691qlink5"> &gt; The more sophisticated vendors (and like it or not, that included Microsoft)</a><br>

<p>
The trouble with Microsoft is that we're reasoning with a marketplace
flattened by more than a decade of its influence as a point of 
reference. To be fair we must evaluate multiple alternate branches 
of reality-as-it-could-have-been, which necessarily makes for 
extremely subjective judgements. Your mileage WILL vary.

<p>
<a name="0708qlink5">As to Microsoft, I guess all the intelligence cream they've been
skimming off academia/industry for years &amp; all these expenses in R&amp;D 
will eventually lead somewhere. Right now, what I see doesn't strike 
me as especially innovative or even high-quality, no Sir. Particularly 
regarding ROI in respect to all these research gigabucks pourin'
in. Administratory hydrocephalus begets administratory hydrocephalus.
</a>

<p>
<a href="0666.html#0691qlink6"> &gt; have been writing 100% object-oriented, multithreaded code for several years</a><br>
<i> &gt; now.  They use asynchronous communication anywhere there is a chance that it</i><br>

<p>
<a name="0708qlink8">I hear you. It is still difficult to belive.
</a>

<p>
<a href="0666.html#0691qlink7"> &gt; might be useful, and they take full advantage of what little multiprocessor</a><br>
<i> &gt; hardware is actually available.  There is also a trend currently underway</i><br>

<p>
Well, essentially all we've got is SMP. I guess it makes use of 
shared-memory paradigm which is a dead-end. Shared-memory is at 
least as unphysical as caches, in fact more so.

<p>
<a href="0666.html#0691qlink8"> &gt; towards designing applications to run distributed across multiple machines</a><br>
<i> &gt; on a network, and this seems likely to become the standard approach for</i><br>
<a name="0708qlink11"><i> &gt; high-performance software in the near future.</i><br>
 
<p>
I know clustering is going to be big, and is eventually going to find
its way into desktops. It's still a back-assed way of doing things,
maybe smart RAM will have its say yet. If only Playstation 2 would be 
already available, oh well. Marketplace will sure look different a
year downstream. Difficult to do any planning when things are so in 
flux.
</a>
 
<p>
<a href="0666.html#0691qlink9"> &gt; Regarding Fine-Grained Parallelism</a><br>
<i> &gt; Parallel processing is not a new idea.  The supercomputer industry has been</i><br>

<p>
Heck, LISP is the second oldest HLL known to man, and Alonzo
Church invented lambda calculus in the 1940's. Eniac was a RISC
machine. Unix is a 1970's OS. GUIs/mice/Ethernet are 1970's
technologies. Von Neumann invented cellular automata in the 1950's. 

<p>
What has age anything to do with how good an idea it is? If anything,
a brand-new untried idea is something to be wary of.

<p>
<a href="0666.html#0691qlink10"> &gt; doing it for some time now, and they've done plenty of experimenting with</a><br>
<i> &gt; different kinds of architectures.  They have apparently decided that it</i><br>

<p>
Nope, sorry, don't think so. Most of IT landscape is shaped by vogues, 
and right now parallelism is getting fashionable (what a damnable
word) again. (While ALife is heading into oblivion, which is imo a 
damn shame).

<p>
<a href="0666.html#0691qlink11"> &gt; makes more sense to link 1,000 big, fast CPUs with large memory caches than</a><br>
<i> &gt; 100,000 small, cheap CPUs with tiny independant memory blocks.  That fits</i><br>

<p>
Heck, caches hierarchies are unphysical. Fat CPUs are incommensurable 
with nonnegligeable fast on-die SRAM blocks _and_ high good die
yield. Wafer-scale integration is impossible without good die yield 
and failure tolerance. Kbit buses are impossible if you don't have 
embedded DRAM technology due to packaging constraints. Embedded 
RAM technology is hardly one year old. VLIW is at the threshold 
of going mainstream, and VLIW only makes good sense with kBit 
broad buses/on-die memory. High code density is impossible 
without threaded code, and threaded code requires stack CPU 
hardware support. Common HLLs don't support threaded code/stack 
CPUs. No language supports fine-grain maspar systems. 
<a name="0708qlink1">Blahblahblah. I could go on for a long time but (I hope) my
point is nauseatingly clear: it's a big ball of yarn buried in 
yonder tarpit, and requires a whole lotta muscle to haul it out. 
</a>
You have to do it in one piece because everything is 
coherent/contiguous/synergistic. A bit of tarry string wrestled 
from the pit won't excite anybody. Please go for the whole hog.

<p>
IT is just another acronym for Inertia Technology. We're caught 
in a local minimum, but this doesn't mean there is no lower one. 
And a (number of) decision(s) has been made in the past which 
made us land in this particular minimum. It could have been a 
different one.

<p>
Sorry if this sounds like a just another technoshaman mantra, but
that's just how things are.

<p>
<a href="0666.html#0691qlink12"> &gt; perfectly with what I know about parallel computing - the more nodes you</a><br>
<i> &gt; have the higher your overhead tends to be, and tiny nodes can easily end up</i><br>
<i> &gt; spending 100% of their resources on system overhead.</i><br>
 
<p>
There are codes where Amdahl is going to bite ya. There are a lot
where overhead is not a problem. My particular problem (from the
domain of physical simulation on a 3d lattice) is the latter case. 
 
<p>
<a href="0666.html#0691qlink13"> &gt; Now, if someone has found a new technique that changes the picture, great.</a><br>
<i> &gt; But if this is something you've thought up yourself, I suggest you do some</i><br>
<i> &gt; more research (or at least propose a more complete design).  When one of the</i><br>

<p>
Heck I did it years ago. Somebody even used the writeup in a CPU 
design class. As I don't have a fab and several 100 M$ to burn (and,
incidentally, more important research to do) I can hardly be expected 
to assault the buttress alone, can I? You'll wind up in the moat, all
dirty &amp; bloody, and have to listen to stupid French jokes and be used
for carcass target practice in the bargain. 

<p>
<a href="0666.html#0691qlink14"> &gt; most competitive (and technically proficient) industries on the planet has</a><br>
<i> &gt; already tried something and discarded it as unworkable, its going to take</i><br>
<i> &gt; more than arm-waving to convince me that they are wrong.</i><br>

<p>
Right, the whole area of supercomputing is going to vanish into a
logics cloud overnight -- because as everybody knows they are 
all monoprocessors. Beowulf is just a passing fad -- pray no 
attention to exponential growth of 'wulfers. Photolitho-semiconductor 
CPUs will scale in to 10, 100, 1000 GHz regime trivially. Einstein 
was dead wrong, and you can signal faster than speed of 
light in vacuum. It makes actual sense implementing a Merced 
in buckytube logic. People who proved that reversible cellular 
automata in molecular logics are the most efficient way of
doing computation were just dweebs. Right.
 
<p>
<a href="0666.html#0691qlink15"> &gt; Regarding the Applicability of Parallelism</a><br>
<i> &gt; The processes on a normal computer span a vast continuum between the</i><br>
<i> &gt; completely serial and the massively parallel, but most of them cluster near</i><br>
<i> &gt; the serial end of the spectrum.  Yes, you have a few hundred process in</i><br>

<p>
<a name="0708qlink14">Says who.

<p>
<a href="0666.html#0691qlink16"> &gt; memory on your computer at any given time, but only a few of them are</a><br>
<i> &gt; actually doing anything.  Once you've allocated two or three fast CPUs (or a</i><br>
</a>

<p>
<a name="0708qlink15">How would you know? I gave you a list of straightforward jobs my
machine could be doing right now. Sounds all very parallel to
me. Remember, there is a reason why I need to build a Beowulf. 
</a>

<p>
<a href="0666.html#0691qlink17"> &gt; dozen or so slow ones) to the OS and any running applications, there isn't</a><br>
<i> &gt; much left to do on a typical desktop machine.  Even things that in theory</i><br>

<p>
I guess I don't have a typical desktop machine, then. I could really
use an ASCI Red here, or better one of these kCPU QCD DSP jobs.

<p>
<a href="0666.html#0691qlink18"> &gt; should be parallel, like spell checking, don't actually get much benifit</a><br>
<i> &gt; from multiple processors (after all, the user only responds to one dialog</i><br>
<i> &gt; box at a time).</i><br>

<p>
Spell checking? I never do spell checking. I do have the C. elegans
genome sitting on my hard drive here, though, which I'd love to do some
statistical analysis on. Guess what? Another embarrasingly parallel
app. 

<p>
<a href="0666.html#0691qlink19"> &gt; On servers there is more going on, and thus more opportunity for</a><br>
<i> &gt; parallelism.  However, the performance bottleneck is usuall in the network</i><br>

<p>
You know what? We're going to move to xDSL pretty quick. And we're
going to need a database-backed web site, both for the intranet and
the outside. No never fork no more...

<p>
<a href="0666.html#0691qlink20"> &gt; or disk access, not CPU time.  You can solve these problems by introducing</a><br>
<i> &gt; more parallelism into the system, but ultimately it isn't cost-effective.</i><br>
<i> &gt; For 99% of the applications out there, it makes more sense to buy 5</i><br>
<i> &gt; standardized boxes for &lt;$5,000 each than one $100,000 mega-server (and you</i><br>
<i> &gt; get better performance, too).</i><br>
 
<p>
Well, I guess I must be pretty special, because the $100,000
mega-server doesn't make at all sense when you want to do
multi-million particles MD. Lots of cheap PC with full duplex
FastEthernet, very much yes. And there is no bottleneck, since from a
certain minimal system size/node onwards the things scales O(N), and I 
mean _strictly_ O(N).
 
<p>
<a href="0666.html#0691qlink21"> &gt; Of course, there are many processes that are highly amenable to being run in</a><br>
<i> &gt; a parallel manner (video rendering, simulation of any kind, and lots of</i><br>
<i> &gt; other things), but most of them are seldom actually done on PCs.  The one</i><br>

<p>
Well, I hate to keep repeating this, but it is not really that rare
you seem to think it is.

<p>
<a href="0666.html#0691qlink22"> &gt; example that has become commonplace (video rendering) is usually handled by</a><br>
<i> &gt; a specialized board with 1 - 8 fast DSP chips run by custom driver-level</i><br>
<i> &gt; software (once again, the vendors have decided that a few fast, expensive</i><br>
<i> &gt; chips are more economical than a lot of slow, cheap ones).</i><br>
 
<p>
Cheap!=slow. A $30 DSP can outperform a $300 CPU because it don't have 
to put up with legacy bloat.

<p>
<i> &gt; Side Issues</i><br>
<a href="0666.html#0691qlink23"> &gt; 1) Most parallel tasks require that a large fraction of the data in the</a><br>
<i> &gt; system be shared among all of your CPUs.  Thus, your system needs to provide</i><br>

<p>
YMMV. Mine don't.

<p>
<a href="0666.html#0691qlink24"> &gt; for a lot of shared memory if it is going to be capable of tackling</a><br>

<p>
Shared memory does not exist, at least not &gt;2-4 ports. If you attempt to 
simulate that, you will have to pay dearly in logic and cache
coherence issues, which starts to slow you down very quickly (point of 
diminishing returns is just round the corner). You can simulate shared 
memory with message-passing, though. If you really, really really need 
it.

<p>
<a href="0666.html#0691qlink25"> &gt; molecular CAD, atmospheric simulations, neural networks, etc.  That brings</a><br>

<p>
&lt;laugher&gt;. Molecular CAD, weather codes and neural codes are already
are or patently formulable in an embarrasingly parallel
way. Really. Look on the code shelves.

<p>
<a href="0666.html#0691qlink26"> &gt; up all those issues of caching, inter-node communication and general</a><br>
<i> &gt; overhead you were trying to avoid.</i><br>
 
<p>
Caching doesn't exist (pray pay no attention to the clever fata morgana). 
Internode-communication is readily addressable (=solved) by having a 
failure-tolerant routing protocol with switch fabric built into the 
CPU. Next Alpha is going to have multi-10 GByte/s inter-CPU signalling 
with 15 ns signalling latency. 3d lattice topology (6 links/CPU) is 
really sufficient for most codes I care about. 
 
<p>
See SGI/Cray, DSP clusters and Myrinet Beowulfs for illustration.

<p>
<a href="0666.html#0691qlink27"> &gt; 2) You also can't get away from context switching.  Any reasonably complex</a><br>
<i> &gt; task is going to have to be broken down into procedures, and each processor</i><br>
<i> &gt; will have to call a whole series of them in order to get any usefull work</i><br>
<i> &gt; done.  This isn't just an artifact of the way we currently write software,</i><br>

<p>
<a name="0708qlink20">Untrue. You almost never have to switch context if you have 1 kCPUs to 
burn. You only have to do this if you run out of the allocable CPU
heap (when the number of your objects exceed the number of your CPUs).
</a>

<p>
<a href="0666.html#0691qlink28"> &gt; either.  It is an inevitable result of the fact that any interesting</a><br>
<i> &gt; computation requires a long series of distinct operations, each of which may</i><br>
<i> &gt; require very different code and/or data from the others.</i><br>
 
<p>
Strangely, my needs are very different.

<p>
<a href="0666.html#0691qlink29"> &gt; Billy Brown, MCSE+I</a><br>
<i> &gt; ewbrownv@mindspring.com</i><br>
<!-- body="end" -->
<p>
<ul>
<!-- next="start" -->
<li><a href="0692.html">[ Next ]</a><a href="0690.html">[ Previous ]</a>
<b>In reply to:</b> <a href="0666.html">Billy Brown</a>
<!-- nextthread="start" -->
</ul>
</body></html>
